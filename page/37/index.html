<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SeniorZhai&#39;s blog | 苟利国家生死以，起因福祸趋避之</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="专注于移动平台">
<meta property="og:type" content="website">
<meta property="og:title" content="SeniorZhai's blog">
<meta property="og:url" content="http://seniorzhai.github.io/page/37/index.html">
<meta property="og:site_name" content="SeniorZhai's blog">
<meta property="og:description" content="专注于移动平台">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SeniorZhai's blog">
<meta name="twitter:description" content="专注于移动平台">
  
  <meta name="summary" content="专注于移动平台">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="undefined"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Dear宅学长</h5>
        <a href="mailto:developer.zhaitao@gmail.com" title="developer.zhaitao@gmail.com" class="mail">developer.zhaitao@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <div class="scroll-wrap flex-col">
    <ul class="nav">
      
    </ul>

    <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>SeniorZhai&#39;s blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="undefined" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

  </div>
</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">SeniorZhai&#39;s blog</div>
        
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">SeniorZhai&#39;s blog</h1>
    <h5 class="subtitle">
        
        苟利国家生死以，起因福祸趋避之
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-Objective-C块语法"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/03/08/Objective-C块语法/">Objective-C块语法</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-03-08T04:51:07.000Z" itemprop="datePublished" class="post-time">
  2014-03-08
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 块语法与其他变量类似，不同的是，代码块存储的数据是一个函数体。使用代码块时，可以想调用其他标准函数一样，传入参数，并得到返回值 
 脱字符(^)是块的语法标记，按照参数语法定义返回值以及快主题   按照调用函数待方式调用块对象变量就可以了： int result = myBlock(4)// result = 28 
 例子 
 
 
  参数是NSString*的代码块 
      1  2  3  4  5  6      void (^printBlock)(NSString *x)  printBlock = ^(NSString* str)  &#123;  	NSLog(@&quot;print:%@&quot;,str);  &#125;  printBlock(@&quot;hello world&quot;);      
 
  代码用在字符串数组排序 
      1  2  3  4  5  6  7      NSArray *stringArray = [NSArray arrayWithObjects:@&quot;abc 1&quot;,@&quot;abc2&quot;,@&quot;abc 3&quot;,@&quot;abc 4&quot;,nil];  NSCompartor sortBlock = ^(id string2,id string2)  &#123;  	return [string1 compare:string2];  &#125;  NSArray *sortArray = [stringArray sortedArrayUsingComparator:sortBlock];  NSLog(@&quot;sortArray:%@&quot;,sortArray);      
 
  代码快的递归调用 
      1  2  3  4  5  6  7  8      static void(^ const blocks)(int) = ^(int)  &#123;  	if(i &gt; 0)&#123;  		NSLog(@&quot;num:%d&quot;,i);  		blocks(i - 1);  	&#125;	  &#125;;  blocks(3);      
 
  在代码块中使用局部变量和全局变量 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14      int global = 1000;  int main(int argc,const char * argv[])  &#123;  	@autoreleasepool&#123;  		void(^block)(void) = ^(void)  		&#123;  			global++;  			NSLog(@&quot;global:%d&quot;,global);  		&#125;  		block();  		NSLog(@&quot;global:%d&quot;,global);  	&#125;  	return 0;  &#125;       
 

    
    
        <a href="/2014/03/08/Objective-C块语法/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-ReactiveCocoa框架"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/03/04/ReactiveCocoa框架/">ReactiveCocoa框架</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-03-04T04:50:30.000Z" itemprop="datePublished" class="post-time">
  2014-03-04
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 ReactiveCocoa是一款FRP（Functional Reactive Programming，响应式编程）框架，简称RAC。可以在GitHub上找到 他 。 
 

    
    
        <a href="/2014/03/04/ReactiveCocoa框架/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-Foundation框架(二)"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/03/04/Foundation框架(二)/">Foundation框架(二)</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-03-04T04:49:18.000Z" itemprop="datePublished" class="post-time">
  2014-03-04
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##Objective-C集合 
 
 大致可分为：NSArray、NSSet、NSDictionary三种体系，NSAarray代表有序、可重复的集合，NSSet代表无序、不可重复的集合，NSDictionary代表具有映射关系的集合。 ##数组（NSArray和NSMutableArray） 
 NSArray代表元素有序、可重复的一个集合，集合中每一个元素都有对应的顺序索引。 -常用方法 
 array:创建一个不包含任何元素的空NSArray 
 arrayWithContentsOfFile:/initWithContentsOfFile:读取文件内容来创建NSArray 
 arrayWithObject:/initWithObject:创建只包含指定元素的NSArray 
 arrayWithObjects:/initWithObjects:创建包含指定N个元素的NSArray 
 objectAtIndex:根据索引返回元素 
 lastObject:最后一个元素 
 objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRnnge:NSMakeRange(2,3)] 从索引中2~5的元素组成新集合 
 indexOfObject:查找元素的位置 
 indexOfObject: inRange:查找指定范围内元素的位置 
 arrayByAddingObject: 追加元素 
 arrayByAddingObjectsFormArray:追加数组集合 
 writeToFile:写入文件 
 
 
 

    
    
        <a href="/2014/03/04/Foundation框架(二)/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-Android安全(一)"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/03/03/Android安全(一)/">Android安全</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-03-03T11:15:47.000Z" itemprop="datePublished" class="post-time">
  2014-03-03
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##Android安全概述 
 
 安全主要解决4类需求： 
 保密(Security/Confidentiality 
 鉴别/认证(Authentication) 
 完整性(Integrity) 
 不可否认性(non-repudiation) 
 
 
 好的密码术应该是 算法公开 ， 密钥保密 的。 
 
 ###对称加密概述 
 
 典型的加密模型 
 秘钥：分为加密秘钥和解密秘钥。 
 明文：文友进行机密，能够直接表带原文含义的信息。 
 密文：经过加密处理处理之后，隐藏原文含义的信息。 
 加密：将明文转换成密文的实施过程。 
 解密：将密文转换成明文的实施过程。   
 
 
 对称的含义（Symmetric） 
 加密和解密用同一套Key 
 
 
 置换加密、转置加密和乘积加密 
 置换加密,又称换位密码,是一个简单的换位，每个置换都可以用一个置换矩阵Ek来表示。每个置换都有一个与之对应的逆置换Dk。 
 
 
 DES 
 AES 
 优点和缺点 
 高效 
 秘钥交换的问题 
 不如RSA的加密安全程度高，但当选择256bit的AES仍然能胜任大多数安全领域。 
 
 
 
 ###非对称加密 
 
 非对称加密的模型   
 公钥和私钥 
 RSA 
 建立在分解大树的困难度上，公钥/私钥长度至少1024bit 
 
 
 优点和缺点 
 安全性足够高 
 没有密钥交换的问题 
 效率低，对于大数据加密很慢 ###常见场景 
 
 
 保密会话   
 

    
    
        <a href="/2014/03/03/Android安全(一)/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-动画"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/03/03/动画/">动画</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-03-03T04:48:35.000Z" itemprop="datePublished" class="post-time">
  2014-03-03
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##CoreAnimation动画 
 
 CoreAnimation动画使用CALayer来创建用户界面，每个UIView上可以放置几百个CALayer，各个大小不同的CALayer叠加、组合在一起，各CALayer可以自由地控制它们的位置、大小和形状，这样就可以创建复杂的用户界面。 
 CoreAnimation床架动画不仅简单而且具有更好的性能，原因如下： 
 CoreAnimation动画在单独的线程中完成，不会阻塞主线程。 
 CoreAnimation动画只重绘界面上的局部变化（局部刷新）。 
 
 
 

    
    
        <a href="/2014/03/03/动画/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-Objective-C小知识"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/28/Objective-C小知识/">Objective-C小知识</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-28T04:47:43.000Z" itemprop="datePublished" class="post-time">
  2014-02-28
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 Objective-C里面没有public和private的概念，你可以认为全是public。 
 NS代表NextStep，CF代表CoreFoudation，CG代表CoreGraphics,CA代表CoreAnimation，UI代表UserInterface 
 id代表万能指针 
 BOOL本质上是char,NO代表false，YES代表true 
 nil 就是NULL 
 

    
    
        <a href="/2014/02/28/Objective-C小知识/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-Foundation框架(一)"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/28/Foundation框架(一)/">Foundation框架(一)</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-28T04:46:48.000Z" itemprop="datePublished" class="post-time">
  2014-02-28
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##字符串（NSString与NSMutableString） 
 
 NSString代表字符串序列不可变的字符串，NSMutableString代表序列可变的字符串 
  NSString常用方法 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20      NSString *str = @&quot;This is a String!&quot;;//以字符串常量创建字符串  NSString *str = [[NSString alloc] init];  str = @&quot;This is a String!&quot;;//创建空字符串，赋值  NSString *str = [[NSString alloc] initWithString:@&quot;This is a String!&quot;//初始化字符串  char *Cstring = &quot;This is a String!&quot;  NSString *str = [[NSString alloc] initWithCString:Cstring];//以标准c字符串初始化创建字符串  NSString *str = [[NSString alloc] stringWithFormat:@&quot;%s is a String&quot;,&quot;This&quot;];//格式化创建字符串  NSString *path = [[NSBundle mainBundle] pathForResouce:@&quot;text&quot; ofType:@&quot;txt&quot;];  NSString *str = [[NSString alloc] initWithContentsOfFile:path];//从文件创建字符串  [str writeToFile:path atomically:YES];//写入文件  BOOL result = [str1 isEqualToString:str2];//判断相等与否  str = [str stringByAppendingString:@&quot;iOS!&quot;];//追加字符串  char* cstr = [str UTF8String];//获取字符串对应的C风格字符串  [str length];//获取字符串长度  [str lengthOfBytesUsingEncoding:NSUTF8StringEncoding];//str按UTF-8字符集解码后字节数  [str substringToIndex:10];//获取str的前10个字符组成的字符串  [str substringFromIndex:5];/获取从第5个字符串开始，与后面字符组成的字符串  [str substringWithRange:NSMakeRange(5,15)];//获取str从第5个字符开始，到第15个字符组成的字符串  [str rangeOfString:@&quot;ios&quot;];//返回ios在字符串中出现的位置  [str uppercassString];//str所有字符转为大写      
 
  NSMutableString可改变序列 
 
 NSMutableString常用方法      1  2  3  4  5      [str appendString:@&quot;,iOS&quot;];//追加固定字符串  [str appendFormat:@&quot;%s is ios&quot;,@&quot;,iOS&quot;];//追加字符串  [str insertString:@&quot;insert&quot; atIndex:6];//指定位置插入字符串  [str deleteCharactersInRange:NSMakeRange(6,12)];//删除6到12位置的所有字符串  [str replaceCharactersInRange:NSMakeRange(6,9) withString:@&quot;Objective-C&quot;];//替换6到9位置的字符串      
 
 
 ##日期与时间（NSDate） 
 
  常用方法 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19      NSDate* date1 = [NSDate date];//获取代表当前日期、时间的NSDate  NSDate* date2 = [[NSDate alloc] initWithTimeIntervalSinceNow:3600*24];//获取从当前时间开始3天之后的日期  NSDate* date3 = [NSDate dateWithTimeIntervalSince1970:3600*24*366*20];//从1970年1月1日开始，20年之后的日期  NSLo  cale* cn = [NSLocale currentLocale];//获取本地位置  [dete1 descriptionWithLocal:cn];//过去NSDate在当前位置对应的字符串  [date1 earlieDate:date2];//获取两个日期之间较早的日期  [date laterDate:date2];//获取两个日期之间较晚的日期  switch([date1 compare date2])  &#123;      case NSOrderedAscending:          break;  //date1在之前      case NSOrderedSame:          break;  //date1与date2日期相同      case NSOrderedDescending:          break;  //date1在之后  &#125;  [date1 timeIntervalSinceDate:date2];//时间差  [date1 timeIntervalSinceNow];//与现在时间差      
 
 NSLocale待遇一个语言、国际环境 
 
 
 
 ##日期格式器（NSDateFormatter） 
 
 NSDateFoematter代表一个日期格式器，用来完成NSDate与NSString之间的转换 
 
 
 创建一个NSDateFormatter对象 
 调用NSDateFormatter的 setStyle: 、 setTimeStyle: 方法设置格式化日期、时间的风格，日期、时间风格支持如下的枚举值： 
 NSDateFormatterNoStyle:不显示日期、时间的风格 
 NSDateFormatterShortStyle:显示“短”的日期、时间风格 
 NSDateFormatterMediumStyle:显示“中等”的日期、时间风格 
 NSDateFormatterLongStyle:显示“长”的日期、时间风格 
 NSDateFormatterFullStyle:显示“完整”的日期、时间风格 
 
 
 NSDate转换成NSString可以调用NSDateFormatter的stringFromDate:方法执行格式化即可 
 NSString转换成NSDate可以调用NSDateFormatter的dateFromString:方法执行格式化即可      1  2  3  4      // 自定义格式式模板  NSDateFormatter* df = [[NSDateFormatter alloc]init];  [df setDateFormatter:@&quot;公元yyyy年MM月DD日HH时mm分&quot;];  NSLog(@&quot;%@&quot;,[df stringFromDate:date]);      
 
 
 ##日历（NSCalendar）与日期组件（NSDateComponents） 
 
 NSCalender对象用于处理NSDate对象所包含的各个字段的数据 
 NSCalendar常用方法 
 (NSDateComponents*)components:fromDate:从NSDate提取年、月、日、时、分、秒各时间字段的信息。 
 dateFromComponents:(NSDateComponents*)comps:使用comps对象包含的年、月、日、时、分、秒各时间字段的信息来创建NSDate. 
 
 
 
 ##定时器（NSTimer） 
 
 调用NSTimer的scheduledTimerWithTimeInterval:invocation:repeats:或scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:类方法来创建NSTimer对象。 
 timerInterval:指定每个多少秒执行一次任务。 
 invocation或target与selector:指定重复执行的任务。如果指定target和selector参数，则指定用某个对象的特定方法作为重复执行的任务；如果指定invacation参数，该参数需要传入一个NSInvocation对象，其中NSInvocation对象也是封装target和selector的，其中也是指定用某个对象的特定方法作为重复执行的任务。 
 userInfo:该参数用于传入额外的附加信息。 
 repeats:该参数需要指定BOOL值，该参数控制是否需要重复执行任务。 
 
 
 为第一步的任务编写方法。 
 销毁定时器，调用定时器的invalidate方法即可。 
 
 ##对象复制 
 
 NSObject类提供了copy和mutableCopy方法，通过这两个方法即可复制已有对象的副本。 
 copy方法总是返回不可修改的副本，及时改对象本身是可修改的。 
 mutableCopy方法用于复制对象的可变副本，即便对象本事是不可修改的，如NSString，返回的是NSMutableString对象。 
 
 ###NSCopying与NSMutableCopy协议 
 
 为了保证自定义类能够使用copy、mutableCopy方法，需要做如下的事 
 让该类实现NSCopying（NSMutableCopying）协议 
 让该类实现copyWithZone:(mutableCopyWithZone:)方法      1  2  3  4  5  6  7  8  9  10  11  12  13  14      -(id)copyWithZone:(NSZone*)zone  &#123;      ZTApple apple= [[[self class] allocWithZone:zone]init];      ZTApple.color = self.color;      ZTApple.weight = self.weight;      return apple;  &#125;  // 如果父类已经实现了NSCopying协议，那么代码就可简化  -(id)copyWithZone:(NSZone*)zone  &#123;      id obj = [super copy];      //...      return obj;  &#125;      
 
 
 
 
 ###浅复制(shallow copy)与深复制(deep copy) 
 
 当对象的实例变量是指针变量时，程序只是复制该指针的地址，而不是真正复制指针指向的对象，这种方式被称为“浅复制”，对浅复制而言，在内存中复制了两个对象，这两个对象的指针变量将会指向同一个对象，也就是两个对象存在公用的部分。 
  深复制不仅会复制对象本身，而且会“递归”复制每个指针类型的实例变量，直到两个对象没有任何公用的部分。 
      1  2  3  4  5  6  7      -(id)copyWithZone:(NSZone*)zone  &#123;      ZTApple apple= [[[self class] allocWithZone:zone]init];      ZTApple.color = [self.color mutableCopy];      ZTApple.weight = self.weight;      return apple;  &#125;      
 
  一般来说，Foundation框架中的类大部分只实现了浅复制。 ####setter方法的copy选项 
 
 setter的copy只实现copy方法，得到的回事一个不可变的副本。 
 

    
    
        <a href="/2014/02/28/Foundation框架(一)/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-NSBundle"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/27/NSBundle/">NSBundle</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-27T04:45:49.000Z" itemprop="datePublished" class="post-time">
  2014-02-27
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 NSBundle用来访问应用自包含的资源文件。 
 获取NSBundle对象，一般会调用该类的mainBundle方法。 
 URLForResource:withExtension:subdirectory:根据 资源名 、 扩展名 从指定 子目录 获取对用资源的URL 
 URLForResource:withExtension:根据 资源名 、 扩展名 获取该资源对应的URL 
 pathForResouce:ofType:根据 资源名 、 类型名 获取该资源对应的路径 
 URLsForResoucesWithExtension:subdirectory:获取指定 子目录 下匹配特定 扩展名 的所有资源对应的URL组成的数组 
 pathForResouces:ofType:inDirectory:从指定的子目录下，根据 资源名 , 类型名 获取该资源对应的路径 
 pathForResoucesOfType:inDirectory:获取指定子目录下，匹配特定类型名的所有资源对应的路径组成的数组 
 resoucePath:直接根据完整的资源路径来获取对应的资源      1  2      NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;txt&quot;];  NSString* content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];       
 
 
 

    
    
        <a href="/2014/02/27/NSBundle/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-对象归档"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/27/对象归档/">对象归档</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-27T04:45:09.000Z" itemprop="datePublished" class="post-time">
  2014-02-27
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 归档就是用户某种格式把一个或者多个对象保存到指定的文件中，方便以后从文件中恢复它们。 
 
 ##使用NSKeyedArchiver归档 
 
 NSKeyedArchiver负责将对象归档到指定文件中 
  NSKeyedUnarchiver则负责从文件中恢复对象 
 
  直接调用 archivedDataWithRootObject:data 、 archiveRootObject:toFile:file 类方法将指定对象作为root进行归档；恢复时，则调用NSKeyedUnarchiver的 unarchiveObjectWithData:data 或者 unarchiveObjectWithFile:file 类方法。 
      1  2  3  4  5  6  7      // 归档  NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys:      [NSNumber numberWithInt:89],@&quot;objc&quot;,      [NSNumber numberWithInt:88],@&quot;cpp&quot;,      [NSNumber numberWithInt:87],@&quot;java&quot;,      nil];  [NSKeyedArchiver archiveRootObject:dict toFile:@&quot;myDict.archive&quot;];      
      1  2  3  4  5      // 恢复  NSDictionary* dict = [NSKeyedUnarchiver unarchiveObjectWithFile:@&quot;myDict.archive&quot;];  NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;objc&quot;]);  NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;cpp&quot;]);  NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;java&quot;]);      
 
 
 
 
 ##实现NSCoding协议 
 
 自定义类要实现归档、恢复，应该实现NSCoding协议，必须实现该协议中的定义的如下两个方法 
 initWithCoder:该方法负责恢复对象 
 encodeWithCoder:该方法负责归档对象 
 
 
 归档和恢复基本数据类型 
 
 
 
 
 归档数据 
 恢复数据 
 
 
 
 
 encodeBool:forKey 
 decodeBoolForKey 
 
 
 encodeInt:forKey 
 decodeIntForKey 
 
 
 encodeInt32:forKey 
 decodeInt32ForKey 
 
 
 encodeInt64:forKey 
 decodeInt64ForKey 
 
 
 encodeFloat:forKey 
 decodeFloatForKey 
 
 
 encodeDouble:forKey 
 decodeDoubleForKey 
 
 
 
 
 示例 
 
      1  2  3  4  5  6  7      #import &lt;Foundation/Foundation.h&gt;  @interface ZTApple : NSObject &lt;NSCoding&gt;  @property (nonatomic,copy) NSString* color;  @property (nonatomic,assign)double weight;  @property (nonatomic,assign)int size;  - (id) initWithColor:(NSString*) color weight:(double) weight size:(int) size;  @end      
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33      #import &quot;ZTApple.h&quot;  @implementation ZTApple  @synthesize color = _color;  @synthesize weight = _weight;  @synthesize size = _size;  -(id) initWithColor:(NSString*) color weight:(double) weight size:(int) size  &#123;      if(self = [super init])      &#123;          self.color = color;          self.weight = weight;          self.size = size;      &#125;      return self;  &#125;   -(NSString *)description  &#123;      return [NSString stringWithFormat:&quot;@&lt;ZTApple[_color=%@,_weigt=%g,_size=%d]&gt;&quot;,self.color,self.weight,self.size];  &#125;  -(void) encodeWithCoder:(NSCode*) coder  &#123;      [coder encodeOject:_color forKey:@&quot;color&quot;];      [coder encodeDouble:_weight foeKey:@&quot;weight&quot;];      [coder encodeInt:_size forKey:@&quot;size&quot;];  &#125;  -(void) initWithCoder:(NSCoder*) coder  &#123;      _color = [coder decodeObjectForKey:@&quot;color&quot;];      _weight = [coder decodeDoubleForkey:@&quot;weight&quot;];      _size = [coder decodeIntForKey:@&quot;size&quot;];      return self;  &#125;  @end      
   使用NSData完成自定义归档  
 一次性收集多个对象，并将这些对象归档到单个文件中，此时借助NSMutableData来创建NSKeyedArchiver或NSKeyedUnarchiver对象。 
 归档过程 
 
 
 以NSMutableData作为参数，创建NSKeyedArchiver对象。 
 反复调用NSKeyedArchiver对象的encodeXxx:forKey:方法来归档所有需要归档到一个文件的对象。 
 调用NSKeyedArchiver对象的finishEncoding方法来结束归档。 
 根据需要，程序可以选择将保存归档数据的NSMutableData通过网络或输出到磁盘文件上。      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17      NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys:      [NSNumber numberWithInt:66],@&quot;objc&quot;,      [NSNumber numberWithInt:76],@&quot;c++&quot;,      [NSNumber numberWithInt:86],@&quot;java&quot;,nil];  NSSet* set = [NSSet setWithObjects:      @&quot;test1&quot;,@&quot;test2&quot;,@&quot;test3&quot;,nil];  ZTApple* apple = [[ZTApple alloc] initWithColor:@&quot;红色&quot; weight:3.4 size:20];  NSMutableData* data = [[NSMutableData data];  NSKeyedArchiver* arch = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];  [arch encodeObject:dict forKey:@&quot;dict&quot;];  [arch encodeObject:set forKey:@&quot;set&quot;];  [arch encodeObject:apple forKey:@&quot;apple&quot;];  [arch finishEncoding];  if([data writeToFile:@&quot;multi.archive&quot; atomically:YES] == NO)  &#123;      NSLog(&quot;归档失败&quot;);  &#125;      
 
 
 
 恢复过程 
 
 
 以NSData作为参数，创建NSkeyedUnarchiver对象 
 重复调用NSKeyedUnarchiver对象的decodeXxx:forKey:方法从文件中恢复所有归档过的对象 
 调用NSKeyedUnarchiver对象的finishDecoding方法结束恢复      1  2  3  4  5  6      NSData* data = [NSData dataWithContentsOfFile:@&quot;multi.archive&quot;];  NSKeyedUnarchiver* unarch = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];  NSDictionary* dict = [unarch decodeObjectForKey:@&quot;dict&quot;];  NSSet* set = [unarch decodeObjectForKey:@&quot;set&quot;];  NSApple* apple = [unarch decodeObjectForKey:@&quot;apple&quot;];  [unarch finishDecoding];       
 

    
    
        <a href="/2014/02/27/对象归档/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-文件IO"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/27/文件IO/">文件I/O</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-27T04:44:30.000Z" itemprop="datePublished" class="post-time">
  2014-02-27
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##NSData与NSMutableData 
 
 代表数据缓存区，作用有两个①对数据读取NSData、②输出NSData的数据 
 初始化方法(类方法以data开头，实例方法以init开头) 
  data: ：创建一个不包含任何数据的、空的NSData对象 
  dataWithBytes:length: / initWithBytesNoCopy:length: ：复制C数组所包含的数据类初始化NSData的数据 
  dataWithBytesNoCopy:length: / initWithBytesNoCopy:length: ：直接利用C数组所包含数据来初始化NSData对象。当该对象呗执行malloc方法销毁自己时，程序会释放该数组 
  dataWithBytesNoDopy:length:freeWhenDone: / initWithBytesNoCopy:length:freeWhenDone: ：直接利用C数组所包含的数据来初始化NSData对象。只有当最后一个参数为YES，且该对象被执行malloc方法销毁自己时，程序才会释放该C数组 
  dataWithContentsOfFile: / initWithContentsOfFile: ：直接读取文件内容，并利用文件内容来初始化NSData 
  dataWithContentOfURL: / initWithContentOfURL: ：直接读取URL关联的内容，并利用该URL关联的内容初始化NSData 
  dataWithData: / initWithData: ：直接使用另一个NSData所包含的数据来初始化先创建的NSData 
 
 
 常用方法 
  bytes: ：获取该NSData所包含的数据 
  getBytes:length: ：获取NSData所包含的指定长度的数据 
  getBytes:range: ：获取NSData所包含的指定范围的数据 
  subdataWithRange: ：获取NSData所包含的指定范围的数据组成的NSData对象 
  writeToFile:atomically: ：将NSData的数据写入文件 
  writeToURL:atomically: ：将NSData的数据写入URL对应的资源 
 
 
 
 
 
 ##NSFileManager 
 
 NSFileManager代表文件管理器，可以执行文件的移动、复制、链接、删除文件或目录，同时提供一个配套的事件委托（NSFileManagerDelegate），确保文件操作后调用相对应的处理方法。文件名作为文件的唯一标识，可使用绝对路径或相对路径。 
 NSFileManager访问属性和内容提供如下方法： 
 
 
 
 
  方法名  
  说明  
 
 
 
 
 fileExistsAtPath: 
 判断指定文件名对应的文件是否存在 
 
 
 fileExistsAtPath:isDirectoy: 
 判断指定文件名对应的文件或者目录是否存在，最后一个参数可用于返回该文件名是否为目录 
 
 
 isReadableFileAtPath: 
 判断指定目录下的文件是否可读 
 
 
 isWritableFileAtPath: 
 判断指定目录下的文件是否可写 
 
 
 isExcutableFileAtPath: 
 判断指定目录下的文件是否可执行 
 
 
 isDeletableFileAtPath: 
 判断指定目录下的文件是否可删除 
 
 
 componentsToDisplayForPath: 
 获取指定文件名对应文件的各个路径组件 
 
 
 displayNameAtPath: 
 获取指定文件名对应文件的简单文件名 
 
 
 attributesOfItemAtPath:error: 
 获取指定文件名对应文件的属性 
 
 
 attributesOfFileSystemForPath:error: 
 获取指定文件名对应的文件所在文件系统的属性 
 
 
 setAttributes:ofItemAtPath:error: 
 设置指定文件名对应文件的属性 
 
 
 contentsAtPath: 
 获取指定文件名对应文件的内容 
 
 
 contentsEqualAtPath:andPath: 
 判断两个文件名指定的内容是否相同 
 
 
 
 
 NSFileManager为创建、删除、移动、复制文件或目录提供了如下方法 
 
 
 
 
  方法名  
  说明  
 
 
 
 
 createDirectoryAtURL:withIntermediateDirectories:attributes:error: 
 根据指定的URL创建目录 
 
 
 createDirectoryAtPath:withIntermediateDirectories:attributes:error: 
 根据指定的路径创建目录 
 
 
 createFileAtPath:contents:attributes: 
 根据指定的文件路径、内容创建文件 
 
 
 removeItemAtURL:error: 
 删除指定URL对应的文件 
 
 
 removeItemAtPath:error: 
 删除指定路径对应的文件 
 
 
 copyItemAtURL:toURL:error: 
 根据指定的URL复制文件或目录 
 
 
 copyItemAtPath:toPath:error: 
 根据指定的路径复制文件或目录 
 
 
 moveItemAtURL:toURL:error: 
 根据指定URL移动文件或目录 
 
 
 moveItemAtPath:toPath:error: 
 根据指定路径移动文件或目录 
 
 
 
 
 NSFileManager查看目录包含内容提供了如下方法 
 
 
 
 
  方法名  
  说明  
 
 
 
 
 contentsOfDirectoryAtPath:error: 
  
 
 
 enumeratorAtPath: 
  
 
 
 subpathsOf 
 
 
 
 ##NSURL 
 
 URL(Uniform Resource Locator)对象表示同意资源定位器，它是指向互联网“资源”的指针。通常情况下，URL由协议名、主机、端口和资源路径组成，格式如下： 
 scheme://host:port/path 
 
 
 

    
    
        <a href="/2014/02/27/文件IO/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
</ul>

<nav id="page-nav">
    <div class="inner">
    <a class="extend prev" rel="prev" href="/page/36/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><a class="page-number" href="/page/36/">36</a><span class="page-number current">37</span><a class="page-number" href="/page/38/">38</a><a class="page-number" href="/page/39/">39</a><a class="extend next" rel="next" href="/page/38/">下一页</a>
    </div>
</nav>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>










</body>
</html>
