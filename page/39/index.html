<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SeniorZhai&#39;s blog | 苟利国家生死以，起因福祸趋避之</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="专注于移动平台">
<meta property="og:type" content="website">
<meta property="og:title" content="SeniorZhai's blog">
<meta property="og:url" content="http://seniorzhai.github.io/page/39/index.html">
<meta property="og:site_name" content="SeniorZhai's blog">
<meta property="og:description" content="专注于移动平台">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SeniorZhai's blog">
<meta name="twitter:description" content="专注于移动平台">
  
  <meta name="summary" content="专注于移动平台">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="undefined"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Dear宅学长</h5>
        <a href="mailto:developer.zhaitao@gmail.com" title="developer.zhaitao@gmail.com" class="mail">developer.zhaitao@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <div class="scroll-wrap flex-col">
    <ul class="nav">
      
    </ul>

    <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>SeniorZhai&#39;s blog &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="undefined" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

  </div>
</div>

  </nav>
  <main id="main">
    <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">SeniorZhai&#39;s blog</div>
        
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">SeniorZhai&#39;s blog</h1>
    <h5 class="subtitle">
        
        苟利国家生死以，起因福祸趋避之
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-UIImageView-UIAlertView-UIActionSheet"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/21/UIImageView-UIAlertView-UIActionSheet/">UIImageView-UIAlertView-UIActionSheet.</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-21T06:35:32.000Z" itemprop="datePublished" class="post-time">
  2014-02-21
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##UIImageView 
 
 一个显示图片控件，直接继承了UIView基类，没有继承UIControl，不能接受用户输入，不能与用户交互。 
 常用属性  image :访问或设置该控件显示的图片  highlighteImage :访问或设置该控件出于高亮状态时显示的图片 
 UIImage还可以使用动画显示一组图片  animationImages :访问或者设置该UIImageView需要动画显示的多张图片，该属性的值为NSArray对象。  highlightedAnimationImages :访问或设置该UIImageView高亮状态下需要动画显示的多张图片，该属性的值为NSArray对象。  animationDuration :访问或设置该UIImageView的动画持续时间。  animationRepeatCout :访问或设置该UIImageView的动画重复次数。  startAnimating :开始播放动画。  stopAnimating :停止播放动画。  isAnimationg :该方法判断该UIImageView是否正在播放动画。 
 缩放模式  Scale To Fill :不保持纵横比缩放图片，使图片完全适应该UIImageView控件。  Aspect Fit :保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。  Aspect Fill :保持纵横比缩放图片，只保证短边完全显示出来。  Center :不缩放图片，只显示图片的中间区域。  Top :不缩放图片，只显示图片的顶部区域。  Bottom :不缩放图片，只显示图片的底部区域。  Left :不缩放图片，只显示图片的左边区域。  Right :不缩放图片，只显示图片的右边区域。  Top Right :不缩放图片，只显示图片的右上边区域。  Top Left :不缩放图片，只显示图片的左上边区域。  Bottom Left :不缩放图片，只显示图片的左下边区域。  Bottom Right :不缩放图片，只显示图片的右下边区域。 ##UIAlertView(警告框) 
  UIAlertView 
 
 显示在屏幕中央的弹出式警告框。 
 基本用法 
 创建 UIAlertView ,指定标题、消息内容、包含多少个按钮、指定UIAlertViewDelegate委托对象。 
 调用 UIAlertView 显示出来。 
 实现 UIAlertViewDelegate 协议中的方法。 
 
 
  实例代码 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25      -(void)viewDidLoad  &#123;      [super viewDidLoad];  &#125;  -(IBAction)clicked:(id)sender  &#123;      UIAlertView *alert = [[UIAlertView alloc]          initWithTitle:@&quot;提示&quot;          message:@&quot;警告框信息&quot;          deledgate:self          cancelButtonTitle:@&quot;确定&quot;          otherButtonTitles:@&quot;按钮一&quot;,@&quot;按钮二&quot;,@&quot;按钮三&quot;,nil];      [alert show];  &#125;  -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex  &#123;      NSString* msg = [NSString stringWithFormat:@&quot;你点击了第%d按钮&quot;,buttonIndex];      UIAlertView *alert = [[UIAlertView alloc]          initWithTitle:@&quot;提示&quot;          message:msg          delegate:nil          cancelButtonTitle:@&quot;确定&quot;          otherButtonTitles:nil];      [alert show]  &#125;      
 
  UIAlertViewDelegate协议中常用的方法 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14      -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex:  //当用户点击该警告框中某个按钮时激发该方法，buttonIndex参数代表用户单击按钮的索引，索引从0开始。  -(void)willPresenAlertView:(UIAlertView *)alertView:  //当该警告框将要显示出来时将会激发该方法。  -(void)didPresenAlertView:(UIAlertView *)alertView:  //当该警告框将要显示出来后将会激发该方法。  -(BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView:  //当该警告框第一个非Cancel按钮被启用时激发该方法。  -(void)alertView:(UIAlertView *)alerView willDismissWithButtonIndex:(NSInteger)buttonIndex:  //当用户单击某个按钮将要隐藏该警告框时激发该用法。  -(void)alertViewCancel:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInterger)buttonIndex:  //当用户通过单击某个按钮完全隐藏该警告框时激发该方法。  -(void)alertViewCancel:(UIAlertView *)alertView:  //当该警告框被取消时（如用户单击了Home键）激发该方法。      
 
  带输入框的UIAlertView 
 
  UIAlertView支持actionSheetStyle属性，用于设置该UIAlert的风格，支持如下枚举值： 
  UIAlertViewStyleDefault ：默认的警告框风格。  UIAlertViewStyleSecureTextInput ：警告框中包含一个密码输入框。  UIAlertViewStylePlainTextInput ：警告框中包含一个普通的输入框。  UIAlertViewStyleLoginAndPasswordInput ：警告框中包含用户名、密码两个输入框。 
 
 
 
 实例代码      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42      -(void)viewDidLoad  &#123;      [super viewDidLoad];  &#125;  -(IBAction)clicked:(id)sender  &#123;      UIAlertView *alert = [[UIAlertView alloc]          initWithTitle:@&quot;登录&quot;          message:@&quot;&quot;          delegate:self          cancelButtonTitle:@&quot;取消&quot;          otherButtonTitles:@&quot;确定&quot;,nil];      alert.alertViewStyle = UIAlertViewStyleLoginAndPasswordInput;      [alert textFieldAtIndex:1].keyboardType = UIKeyboardTypeNumberPad;      [alert show];  &#125;  -(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInterger)buttonIndex  &#123;      if(buttonIndex == 1)&#123;          UITextField* nameField = [alertView textFieldAtIndex:0];          UITextField* passField = [alertView textFieldAtIndex:1];          NSString* msg = [NSString stringWithFormat:&quot;输入的用户名为：%@，密码为%@&quot;,nameField.text,passField.text];          UIAlertView *alert = [[UIAlertView alloc]              initWithTitle:@&quot;提示&quot;              message:msg              delegate:nil              cancelButtonTitle:@&quot;确定&quot;              otherButtonTitles:nil];          [alert show];      &#125;  &#125;  -(void)willPresentAlerView:(UIAlertView *)alertView  &#123;      for(UIView * view in alertView.subViews)      &#123;          if([view isKindOfClass[UILabel class])          &#123;              UILabel* label = (UILabel*)view;              label.textAlignment=UITextAlignmentLeft;          &#125;      &#125;  &#125;      
 
 
 
 
 ##UIActionSheet 
 
  显示在底部的按钮列表，用户通过单击某个按钮来表明自己的态度。 
 
  风格(actionSheetStyle)： 
  UIActionSheetStyleDefault :默认风格，灰色背景上显示白色文字。  UIActionSheetStyleBlackTranslucent :在透明的黑色背景上显示白色文字。  UIActionSheetStyleBlackOpaque :在纯黑的背景上显示白色文字 
 
 
 
 示例代码      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23      -(void)viewDidLoad  &#123;      [super viewDidLoad];  &#125;  -(IBAction)clicked:(id)sender&#123;      UIActionSheet* sheet = [[UIActionSheet alloc]           initWithTitle:@&quot;请确认是否确认&quot;          delegate:self          cancelButton:@&quot;取消&quot;          destrutiveButtonTitle:@&quot;确定&quot;          otherButtonTitle:@&quot;按钮一&quot;,@&quot;按钮二&quot;,nil];      sheet.actionSheetStyle = UIActionSheetStyleAutomaic;      [sheet showInView:self.view];  &#125;  -(void)actionSheet:(UIActionSheet *)actionSheetclickedButtonAtIndex:(NSInteger)buttonIndex  &#123;      UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot;          message:[NSString stringWithFormat:@&quot;你单击了第%d个按钮&quot;,buttonIndex          delegate:nil          cancelButtonTitle:@&quot;确定&quot;          otherButtonTitles:nil];      [alert show];  &#125;       
 

    
    
        <a href="/2014/02/21/UIImageView-UIAlertView-UIActionSheet/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIActionSheet/">UIActionSheet.</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIAlertView/">UIAlertView</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIImageView/">UIImageView</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-Anroid-NDK的安装与配置"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/20/Anroid-NDK的安装与配置/">Anroid NDK的安装与配置</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-20T14:14:20.000Z" itemprop="datePublished" class="post-time">
  2014-02-20
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Android/">Android</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##Mac版 
 
 到Google的官网下载 Andorid NDK  
 解压到你要存放的位置 
 开启终端，输入命令pico .bash_profile   
  添加NDK的绝对路径  export PATH=${PATH}:/Users/userName/Documents/android-ndk-r9c   A_NDK_ROOT=/Users/userName/Documents/android-ndk-r8d   export A_NDK_ROOT    
 
 注：图片中有SDK的部分，具体路径视个人情况而定。 
 
 
  测试：关闭终端后重启，输入ndk-build,出现以下提示，证明配置成功   
 
 
 ##Windows版 
 
 到Google的官网下载 Andorid NDK  
 解压到你要存放的位置 
 计算机-属性-高级系统设置-高级-环境变量-系统环境变量-编辑 Path 变量-添加NDK的存放路径 
 测试：在命令行中输入ndk-build,出现以下提示，证明配置成功   
 

    
    
        <a href="/2014/02/20/Anroid-NDK的安装与配置/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-导航栏"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/20/导航栏/">导航栏</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-20T07:34:50.000Z" itemprop="datePublished" class="post-time">
  2014-02-20
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 UINavigationBar 
 一个导航栏一般包括四个对象：UINavigationController、UINavigationBar、UIViewControllerUINavigationItem;其中UINavigationItem存放在UINavigationBar上。   
 
 
 导航栏结构剖析图     
  定制标题视图 
 
 通过NavigationItem的titleView属性，定制标题视图，titleView属性是一个视图类，因此可以添加一个UIView的实例，也可以添加UIView的子类，也可以在UIView的实例中添加子视图。      1  2  3  4      UIView *cView = [[UIView alloc]initWithFrame:CGRectMake(0,0,160,44)];  cView = [UIColor redColor];  self.navigationItem.titleView = cView;  [cView release];      
 
 
 
  定制左、右栏目 
 
 NavigationItem实例有一个leftBarButtonItem和reightBarButtonItem，而这两个属性又是UIBatButtonItem的实例，可以通过初始化实例，定制。 
 UIBarButtonItem类提供了常用的四个初始化方法，通过这些不同的初始化方法，用户可以得到不同风格的Item。      1  2  3  4  5  6  7  8      // 初始化一个UIBarButtonItem的实例，初始化一个系统的Item  -(id)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem taget:(id)target action:(SEL)action;  // 初始化一个带图片的UIButtonItem实例  -(id)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;  // 初始化一个自带标题的UIBarButtonItem实例  -(id)initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;  // 初始化一个自定义视图  -(id)initWithCustomView:(UIView *)customView;      
 
 
 
  设置风格 
      1  2  3  4      // 设置导航栏的风格为黑色  self.navigationController.navigationBar.barStyle = UIBarStyleBlack;  // 设置导航栏为透明  self.navigationController.navigationBar.translucent = YES;      
 
  设置颜色 
      1  2  3  4  5  6      // 设置导航栏的颜色  self.navigationController.navigationBar。tintColor = [UIColor redColor];  // 设置自定义颜色，注意每一个颜色的范围是0~1之间  [UIColor colorWithRed:0/255.0 green:225/255.0 blue:122/255.0 alpha:1];  // 以图片作为颜色，注意这里是无法设置NavigationBar  [UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;img.png&quot;]];      
 
  隐藏返回按钮 
      1  2  3      // 隐藏返回按钮，后者带动画效果  [self.navigationItem setHidesBackButton:YES];  [self.navigationController setToolbarHidden：YES animated:YES];      
 
  设置prompt属性 
 
 导航栏的prompt属性，通过navigationItem来设置，其主要作用是用于提示用户。比如，用户正在请求网络数据时，提示用户数据正在被加载，待加载完成后可以将它的值设置为nil，取消显示。   ##工具栏 
 
 
  创建UIToolBar的实例 
      1  2  3  4  5  6  7      UIToolBar *toolBar = [[UIToolBar alloc]initWithFrame:CFrectMake(0,460-88,320,44)];  // 初始化UIToolBar的UIBarButtonItem实例，与UINavigationItem中左、右栏目是相同的  UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithTitle:@&quot;天气&quot; style:UIBarButtonItemStyleBordered target:self action:nil];  // 向UIToolBar添加UIBarButtonItem  NSArray *itemArray = [NSArray arrayWithObjects:item1,nil];  // 设置UIToolBar的间隔，前者是item之前选择一个合适的列宽，后者用户可以自定义item之间的列宽，需要通过UIBar实例中的width属性来设置。  UIBarButtonSystemItemFlexibleSpace|UIBarButtonSystemItemFixedSpace      
 
  导航控制器中的UIToolBar 
 
 在导航控制器中会带有一个UIToolBar的实例，但默认是隐藏的，如果需要显示，需要通过 [self.navigationController setToolbarHidden:No animated:YES] 将其打开。 
 导航控制器只拥有一个UIToolBar实例，但UIToolBar所拥有的UIBarButtonItem实例，由视图控制器管理。      1  2  3  4      // 将UIBarButtonItem放入数组中，最后添加至UIToolBar中，self表示视图控制器  [self setToolbarItems:itemArray animated:YES];  // 以下代码UIBarButtonItem不会出现在UIToolBar中，且toolbar是制度属性  [self.navigationController.toolbar setItem:itemsArray animated:YES];      
 
 
 
 
      1  2  3  4  5  6  7  8  9  10  11      UIToolbar *toolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0,460-44-44,320,44)];  toolBar.barStyle = UIBarStyleDefault;  [self.view addSubView:toolBar];  [toolBar release];  UIBarButtonItem *addItem = [[UIBarButton alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:nil];  UIBarButtonItem *saveItem = [[UIBarButton alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemSave target:self action:nil];  UIBarButtonItem *titleItem = [[UIBarButton alloc]initWithTitle:@&quot;title&quot; style:UIBarButtonItemStylePlain target:self action:nil];  UIBarButtonItem *imageItem = [[UIBarButton alloc]initWithImage:[UIImage imageNamed:@&quot;1&quot;] style:UIBarButtonItemStylePlain target:self action:nil];  UIBarButtonItem *flexibleItem = [[UIBar]  NSArray *items = @[addItem,saveItem,titleItem,imageItem];  [toolBar setItems:items animated:Yes];      
    
    
        <a href="/2014/02/20/导航栏/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-UIControl"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/20/UIControl/">UIControl</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-20T07:33:50.000Z" itemprop="datePublished" class="post-time">
  2014-02-20
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 UIControl 
 作用：具有事件处理的控件的父类 
 事件响应的3种形式：基于触摸、基于值、基于编辑 
 
 
  常用方法 
      1  2      -(void)addTarget:(id)taget action:(SEL)action forControlEvent:(UIControlEvents)controlEvents //添加一个事件  -(void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents // 移除某一个事件      
 
  事件处理 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34      // 按下时触发  UIControlEventTouchDown  // 多击触发  UIControlEventTouchDownRepeat  // 控件内拖动触发  UIControlEventTouchDragInside  // 控件外拖动触发  UIControlEventTouchDrageOutside  // 当触摸从控件外拖动到控件内部时  UIControlEventTouchDragEnter  // 当触摸从控件内拖动到控件外部时  UIControlEventTouchDragExit  // 控件之内触摸抬起时  UIControlEventTouchupInside  // 控件之外触摸抬起时  UIControlEventTouchUpOutside  // 触摸事件取消  UIControlEventTouchCancel  // 当控件的值发生改变时  UIControlEventTouchValueChanged  // 文本控件中开始编辑  UIControlEventEditingDidBegin  // 文本控件中的文本被改变  UIControlEventEditingChanged  // 文本孔家中编辑结束  UIControlEventEditingDidEnd  // 文本孔家中通过按下回车键结束编辑时  UIControlEventEditingDidOnExit  // 所有触摸事件  UIControlEventAlltouchEvents  // 所有编辑事件  UIControlEventAllEditingEvents  // 所有事件  UIControlEventAllEvents      
 
 
 ##导航控制器 
 
 基本概念   + UINavigationController 用于构建分层应用程序的主要工具，管理着多个内容视图的换入（压入）和换出（弹出）。自身提供了视图切换的动画效果。 
 它的父类是 UIViewController ，是所有视图控件器的基类。 
 导航控制器以栈的形式来实现。   
 
 
 栈的基本概念和性质 
 栈是一种先进后出（后进先出）的数据结构，导航控制器以栈的形式来管理视图控制器，任何视图控制器都可以放入栈中。 
 向栈添加一个对象的操作称为入栈（push） 
 第一个入栈的对象叫做基栈 
 最后一个入栈的对象叫栈顶 
 栈删除一个对象的操作叫做出栈（pop） 
 当前现实点视图控制器，即为栈顶。选择”返回”时，这个视图控制器就出栈了。 
 
 
 基本样式 
 蓝色部分：导航控制器的导航栏（NavigationBar） 
 橙色部分：控制器包含的内容视图 
 绿色部分：导航控制器的工具栏（UIToolBar，默认是隐藏的）   
 
 
 元素尺寸   
  代码示例 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14      // 控制器的初始化，为控制器添加导航控制器  RootViewController *rootVC = [[RootViewController alloc] init];  UINavigationController *navigation = [[UINavigationController alloc] initWithRootViewController:rootVC];  // 子控制器设置title，显示在导航栏上的标题  self.title = @&quot;根控制器&quot;；  // 控制器之间的导航  SecondViewController *secondVC = [[SecondViewController alloc] init];  [self.navigationController pushViewController:secondVC animated:YES];  [secondVC release];  // 隐藏（显示）导航栏、工具栏目  [self.navigationController setNavigationBarHidden:NO animated:YES];  [self.navigationController setToolbarHidden:NO animated:YES];  // 延时调用hidden方法  [self performSelector:@selector(hidden) withObject:nil afterDelay:0.3];      
 
  Demo代码片段 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58  59  60  61  62  63  64  65  66  67  68      // AppDelegate.m  // didFinshLunchingWithOptions()  // ...  RootViewcController * rootViewController = [[RootViewcController alloc] init];  UINavigationController *navigation = [[UINavigationController alloc]initWithRootViewController:rootViewController];  self.window.rootViewController = navigation;  [rootViewController release];  [navigation release];  //RootController.m   -(void)loagView  &#123;  	UIView *baseView = [[UIView alloc] initWithFrame:[UIScreen mainScreen] applicationFrame];  	baseView.backgroundColor = [UIColor purpleColor];  	self.view = baseView;  	[baseView release];    	UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];  	[button setTitle:@&quot;Push&quot; forState:UIControlStateNormal];  	[button setFrame:CGRectMake(90,100,140,35)];  	[button addTaget:self action:@selector(pushVC) forControlEvents:UIControlEventTouchUpInside];  	[self addSubview:button];  &#125;  -(void)pushVC  &#123;  	SencondViewController *secondVC = [[SencondViewController alloc] init];  	[self navigationController pushViewController:secondVC animated:YES];  	[secondVC release];  &#125;  //SencondViewController.m  -(void)loagView  &#123;  	UIView *baseView = [[UIView alloc] initWithFrame:[UIScreen mainScreen] applicationFrame];  	baseView.backgroundColor = [UIColor orangeColor];  	self.view = baseView;  	[baseView release];    	UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];  	[button setTitle:@&quot;HiidenOrShow&quot; forState:UIControlStateNormal];  	[button setFrame:CGRectMake(90,150,140,35)];  	[button addTaget:self action:@selector(hiddenOrShow) forControlEvents:UIControlEventTouchUpInside];  	[self addSubview:button];    	UIButton *back = [UIButton buttonWithType:UIButtonTypeRoundedRect];  	[back setTitle:@&quot;backRootVC&quot; forState:UIControlStateNormal];  	[back setFrame:CGRectMake(90,200,140,35)];  	[back addTaget:self action:@selector(hiddenOrShow) forControlEvents:UIControlEventTouchUpInside];  	[self addSubview:back];  &#125;  -(void)viewWillAppear:(BOOL)animated  &#123;  	[super viewWillAppear:animated];  	[self.navigationController setToolBarHidden:YES animated:YES];  &#125;  -(void)hiddenOrShow  &#123;  	if(self.navigationController.toolbarHidden)  	&#123;  		[self.navigationController setToolBarHidden:NO animated:YES];  		[self.navigationController setNavigationBarHidden:NO animated:YES];  	&#125;else&#123;  		[self.navigationController setToolBarHidden:YES animated:YES];  		[self.navigationController setNavigationBarHidden:NO animated:YES];  	&#125;  &#125;  -(void)backRootVC  &#123;  	[self.navigationController popViewControllerAnimated:YES];  &#125;      
 
  导航控制器常用属性 
      1  2  3  4  5  6  7  8  9  10      // 获取到在栈中最顶层的视图控制器  @property(nonatomic,readonly,retain)UIViewController *topViewController;  // 获取到在斩重当前显示的视图控制器  @property(nonatomic,readonly,retain)UIViewController *visibleViewController;  // 在栈中当前视图控制器  @property(nonatomic,copy)NSAraay *viewControllers;  // 隐藏导航栏，默认不隐藏  @property(nonatomic,getter=isNavigationBarHidden)BOOL navigationBarHidden;  // 获取到导航栏  @property(nonatomic,readonly)UINavigationBar *navigatuonBar;      
 
  导航控制器常用方法 
      1  2  3  4  5  6  7  8  9  10      // 初始化一个根视图控制器，在栈的最底层  -(id)initWithRootViewController:(UIViewController *)rootViewController;  // 压入一个新的视图控制器  -(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;  // 弹出一个新的视图控制器  -(UIViewController *)popViewControllerAnimated:(BOOL)animated;  // 弹出到指定的视图控制器  -(NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;  // 回到跟视图控制器  -(NSArray *)popToRootViewControllerAnimated:(BOOL)animated;       
 

    
    
        <a href="/2014/02/20/UIControl/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-常用UIView组件"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/18/常用UIView组件/">常用UIView组件</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-18T04:46:08.000Z" itemprop="datePublished" class="post-time">
  2014-02-18
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##UIButton 
 
 常用属性 
 
 1.Type 
  + Custom:选择此属性外观主要依靠自定义实现。
+ System:系统能够默认风格。
+ Detail Disclosure:详情标示。
+ Info Light:显示“i”图标的图形按钮。
+ IndoDark:显示“i”图标的图形按钮。
+ Add Contact:显示黑色“+”图标图形按钮。
   
 State Config 
 按钮的状态 
 默认状态（Default） 
 高亮状态（Highlighted） 
 选中状态（Selected） 
 禁用状态（Disable） 
 
 
 
 
 Title 
 可以选择Plain和Attributed文本方式 
 制定显示的字符信息 
 
 
 Font 
 文本字体、大小、字体风格 
 
 
 Text Color 
 文本的颜色 
 
 
 Shadow Color 
 阴影颜色 
 
 
 Image 
 设置为图片按钮，Title属性将不会起作用。 
 
 
 Background 
 设置背景图片 
 
 
 Shadow Offset 
 文本和阴影的偏移量 
 
 
 Link Break 
 省略方式 
 
 
 Edge 
 Content:内容作为边界 
 Title:文本作为边界 
 Image:图片作为边界 
 
 
 Inset 
 边界距离 
 
 
 
 ##UIAlert And UIActionSheet       1  2      UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:nil cencelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;other&quot;,nil];  [alertView show];       
      1  2  3  4      UIActionSheet *actionSheet = [[UIActionSheet alloc] initWIthTitle:@&quot;title&quot; delegate:nil cancelButtonTitle:@&quot;cancel&quot;  destructiveButtonTitle:@&quot;destrutive&quot;  otherButtonTitles:@&quot;other1&quot;,nil];  [actionSheet show];      
 ##UIButton 
 
 UIButton 
 作用：响应用户的点击事件的View 
 
 
  常用方法 
      1  2  3  4  5  6  7  8  9  10      // 设置指定状态对应的标题文本  -(void)setTitle:(NSString *)title forState:(UIControlState)state;  // 设置指定状态对应的标题颜色  -(void)setTitleColor:(UIColor *)color forState:(UIControlState)state;  // 设置指定状态对应的显示图片  -(void)setImage:(UIImage *)image forState:(UIControlState)state;  // 设置指定状态对应的背景图片  -(void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;  // 为按钮添加事件  -(void)addtarget:(id *)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;      
 
  UIButton状态 
      1  2  3  4  5  6      UICtrolStateNormal          // 正常状态  UICtrolStateHighlighted     // 高亮状态  UICtrolStateDisabled        // 禁用状态  UICtrolStateSelected        // 选中状态  UICtrolStateApplication  UICtrolStateReserved      
 
  事件处理 
 
 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18      // 用户按下时触发  UIControlEventTouchDown  // 点击计数大于1的触发  UIControlEventTouchDownRepeat  // 当触摸在控件内部拖动时触发  UIControlEventTouchDragInside  // 当触摸在控件之外拖动时触发  UIControlEventTouchDragDutside  // 当触摸从控件之外拖到内部时  UIControlEventTouchDragEnter  // 当触摸从控件内部拖到外部时  UIControlEventTouchDragExit  // 控件之内触摸抬起时  UIControlEventTouchUpInside  // 控件之外触摸抬起时  UIControlEventTouchUpOutside  // 触摸取消时间，设备被上锁或者电话呼叫打断  UIControlEventTouchCanel      
 
 代码示例 
 
      1  2  3  4  5  6  7      UIButton *button = [UIButton buttonWithType:UIButttonTypeRoundedRect];  [button setTitle:@&quot;Normal&quot; forState:UIControlNormal];  [button setTitle:@&quot;Highlighted&quot; forState:UIControlHighlighted];  [button setTitle:@&quot;Disabled&quot; forState:UIControlDisabled];  [button setTitle:@&quot;Selected&quot; forState:UIControlSelected];  button.frame = CGRectMake(90,100,140,40);  [self.window.addSubview:button];      
 ##图片视图 
 
  UIImageView 
 
 作用：专用于显示图片的视图 
 
 
  常用属性和方法 
      1  2  3  4  5  6  7  8  9  10      // 初始化图片  -(id)initWithImage:(UIImage *)image;  // 初始化高亮的图片  -(id)initWithImage:(UIImage *)image hightlightedImage:(UIImage *)highlightedImage  // 点语法设置图片  @property(nonatomic,retain)UIImage *image;  // 点语法设置高亮图片  @property(nonatomic,retain)UIImage *highlightedImage;  // 是否打开用户交互，默认为NO  @preperty(nonatomic,getter=isUserInteractionEnabled)BOOL userInteractionEnabled;      
 
  示例代码 
      1  2  3  4      UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0,0,100,100)];  imageView.image = [UIImage imageNamed:@&quot;t.png&quot;];  imageView.highlightImage = [UIImage imageNamed:@&quot;t1.png&quot;];  imageView.userInteractionEnabled = YES;      
 
 
 ##UIActivityIndicatorView 
 
 UIActivityIndicatorView 
 作用：提示用户当前页面正在加载数据 
 
 
  常用属性和方法 
      1  2  3  4  5  6  7  8  9  10  11  12      // 设置风格  @property(nonatomic)UIActivityIndicatorViewStylr;  // 停止时、隐藏视图，默认为YES  @property(nonatomic)BOOL hideWhenStopped;  // 修改颜色、注意版本问题  @property(readWrite,nonatomic,retain)UIColor *color;  // 开始动画  -(void)startAnimating;  // 停止动画  -(void)stopAnimating;  // 判断动画的状态（停止或开始）  -(BOOL)isAnimating;      
 
  示例代码 
      1  2  3      UIActivityIndicatorView *activityView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorViewStyleWhite];  activityView.frame = CGRectMake(0,0,100,100);  [activityView startAnimating];      
 
 
 ##滑动控件 
 
 UISlider视图 
 作用：控制系统声音，或者表示播放进度等等 
 
 
  常用属性 
      1  2  3  4  5  6  7  8  9  10  11  12      // 设置获取slider的value值  @property(nonatomic)float value;  // 设置slider的最小值  @property(nonatomic)float minimumValue;  // 设置slider的最大值  @property(nonatomic)float maximumValue;  // 设置图片  @property(nonatomic,retain)UIImage *minimumValueImage;  // 设置图片  @property(nonatomic,retain)UIImage *maximumValueImage;  // 设置slider的value值，是否存在动画  -(void)setValue:(float)value animated:(BOOL)animated;      
 
  示例代码 
      1  2  3  4  5      UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(20,0,150,25)];  [slider addTarget:self action:@selector(sliderAction:) forControlEvent:UIControlEventValueChanged];  slider.maxmumValue = 100;  slider.minmumValue = 0;  slider.value = 50;      
 
 
 ##分段控件 
 
 UISegmentedControl 
 作用：分段控件、页面切换等 
 
 
 示例代码      1  2  3  4  5  6      NSArray *array = [NSArray arrayWithObjects:@&quot;选择&quot;,@&quot;搜索&quot;,@&quot;工具&quot;,nil];  UISegmentedControl *segmentCtrl = [[UISegmentedControl alloc] initWithItems:array];  segmentCtrl.frame = CGRectMake(20,0,150,25);  segmentCtrl.segmentedControlStyle = UISegmentedControlStyleBar;  segmentCtrl.selectedSegmentIndex = 0;  [segmentCtrl addTarget:self action:@selector(segmentAction:) forControlEvents:UIControlEventValueChanged];      
 
 
 ##分页控件 
 
 UIPageControl 
 作用：通常和UIScrollView连用，提示用户当前显示页数 
 
 
  常用属性和方法 
      1  2  3  4  5  6  7  8      // 共有几个分页“圆圈”  @property(nonatomic)NSInteger numberOfPages;  // 显示当前的页  @property(nonatomic)NSInteger currentPage;  // 只存在一页时，是否隐藏，默认为YES  @property(nonatomic)BOOL hidesForSinglePage;  // 刷新视图  -(void)updateCurrentPageDisplay;      
 
  示例代码 
      1  2  3  4  5      UIPageControl *pageControl = [[UIPageControl alloc]initWithFrame:CGRectMake(0,100,320,40)];  pageControl.numberOfPages = 10;  pageControl.currentPage = 2;  pageControl.backgroundColor = [UIColor grayColor];  [pageControl addTarget:self action:@selector(change:) froControlEvents:UIControlEventValueChanged];      
 
 
 ##UITextField 
 
 常用代理方法      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17      // 将要开始输入时调用  -(BOOL)textFieldShoudBeginEdting:(UITextField *)textField&#123;      return YES;  &#125;  // 将要输入结束时调用  -(BOOL)textFieldShouldEndEditing:(UITextField *)textField&#123;      return YES;  &#125;  // 清除文字按钮点击事件  -(BOOL)textFieldShouldClear:(UITextField *)textField&#123;      return YES;  &#125;  // 键盘上的return按钮  -(BOOL)textFieldShouldReturn:(UITextField *)textField&#123;      [textField resignFirstResponder];      return YES;  &#125;      
 
 
 ##UILabel 
 
 UILabel 
 作用：显示文本 
 
 
  常用属性 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20      // 设置文本内容，默认为nil  @property(nonatomic,copy)NSString *text;  // 设置字体大小  @property(nonatomic,retain)UIFont *font;  // 设置字体颜色  @property(nonatomic,retain)UIColor *textColor;  // 设置阴影，默认没有阴影，若果设置需要设置偏移量  @property(nonatomic,retain)UIColor *shadowColor;  // 设置偏移量  @property(nonatomic）CGSize shadowOffset;  // 文本内容对齐方式  @property(nonatomic)NSTextAlignment textAlignment;  // 当文本超出frame时，文本截取的方式  @property(nonatomic)NSLineBreakMode lineBreakMode;  // 文本选中时，高亮的颜色  @property(nanatomic,retain)UIColor *highlightedTextColor;  // 是否存在高亮，默认为nil  @property(nanatomic,getter=isHighlighted)BOOL highlighted;  // 交互是否打开，默认为NO  @property(nanatomic,getter=isUserInteractionEnabled)BOOL userInteractionEnabled;      
 
  示例代码 
      1  2  3  4  5  6  7  8  9      UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(90,100,140,40)];  label.text = @&quot;text&quot;;  label.backgroundColor = [UIColor redColor];  label.textAligment = NSTextAligmentCenter;  label.textColor = [UIColor blueColor];  label.shadowColor = [UIColor yellowColor];  label.shadowOffset = CGSizeMake(-2,2);  [self.window addSubview:label];  [label release];       
 

    
    
        <a href="/2014/02/18/常用UIView组件/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-利用代理"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/18/利用代理/">利用代理</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-18T04:01:25.000Z" itemprop="datePublished" class="post-time">
  2014-02-18
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 代理是一种简单而功能强大的设计模式，这种模式用于一个对象“代表”另外一个对象和程序中其他的对象进行交互。 主对象（这里指的是delegating object）中维护一个代理（delegate）的引用并且在合适的时候向这个代理发送消息。这个消息通知“代理”主对象即将处理或是已经处理完了某一个事件。这个代理可以通过更新自己或是其它对象的UI界面或是其它状态来响应主对象所发送过来的这个事件的消息。或是在某些情况下能返回一个值来影响其它即将发生的事件该如何来处理。代理的主要价值是它可以让你容易的定制各种对象的行为。注意这里的代理是个名词，它本身是一个对象，这个对象是专门代表被代理对象来和程序中其他对象打交道的。 
 
      1  2  3  4  5  6  7  8  9  10  11  12  13      // RootViewController.h  #import &quot;ModalViewContorller.h&quot;  @optional  //optional 强制必须实现的方法  -(void)changeLabelText:(NSString *)text;  @end  @interface ModalViewController:UIViewController  &#123;  @private      UITextField *textFiled;  &#125;  @property(nonatomic,assign)id &lt;ModalViewControllerDelegate&gt; delegate;  @end      
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39      // RootViewController.m  -(void)viewDidLoad  &#123;      [super viewDidLoad];      self.view.backgroundColor = [UIColor redColor];            UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];      button.tag = 101;      button.frame = CGRectMake(320/2-140/2,200,140,40);      [button setTile:@&quot;进入&quot; forState:UIControlStateNormal];      [button addTarget:self action:@selector(presentModalVC) forControlEvent:UIControlEventTouchUpInside];      [self.view addSubiew:button];      UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(90,100,140,40)];      label.text = @&quot;hello world&quot;;      label.tag = 102;      label.textAligment = NSTextAligmentCenter;      [self.view addSubView:label];  &#125;  -(void)presentModalVC  &#123;      ModalViewController *modalVc = [[ModalViewController alloc] init];      modalVc.delegate = self;      // 动画效果      modalVc.modalTranstionSyle = UIModalTransitionStylePatialCurl;      if([[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0)&#123;          [self.presentModalViewController:modalVc animated:YES];      &#125;else&#123;          [self.presentModalViewController:modalVc animated:YES completion:^&#123;          NSLog(@&quot;call back&quot;);          &#125;];      [modalVC relese];      &#125;  &#125;  -(void)changeLabelText:(NSString *)text  &#123;      UILabel *label = (UILable *)[self.view viewWithTag:102];      label.text = text;        &#125;      
      1  2  3  4  5  6  7  8  9  10  11  12  13      // ModalViewController.h  @protocol ModalViewControllerDelegate &lt;NSObject&gt;  @optional  //optional 强制必须实现的方法  -(void)changeLabelText:(NSString *)text;  @end  @interface ModalViewController:UIViewController  &#123;  @private      UITextField *textFiled;  &#125;  @property(nonatomic,assign)id &lt;ModalViewControllerDelegate&gt; delegate;  @end      
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25      //ModalViewController.m  -(void)viewDidLoad  &#123;      [super viewDidLoad];      self.view.backgroundColor = [UIColor greenColor];            *textField = [[UIText alloc] initWithFrame:CGRectMake(70,100,100,30)];      textField.borderStyle = UITextBorderStyleRoundedRect;      [self.view addSubview:textField];            UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];      button.frame = CGRectMake(320/2-140/2,100,140,40);      [button setTitle:@&quot;dismiss&quot; forState:UIControlEvent:UIControlEventTouchUpInside];      [self.view addSubview:button];  &#125;  -(void)dismiss  &#123;         if([self.delegate respondsToSelector:@selector(changeLabelText:)])&#123;       [self.delegate changeLabelText:textField.text];      &#125;      // 将模态视图关闭      [self dismissViewControllerAnimated:YES completion:^&#123;          NSLog(@&quot;dismiss&quot;)];      &#125;];  &#125;      
 #利用通知       1  2  3      // 在通知中心注册一条名为ChangeLabelTextNotification的通知  [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(changeLabelText:) name:@&quot;ChangeLabelTextNotification&quot; object:nil];  // deallco时需要删除       
      1  2  3  4  5  6      -(void)changeLabelText:(NSNotification *)notification  &#123;      id text = notification.object;      UILabel *label = (UILabel *)[self.view viewWithTag:102];      label.text = text;  &#125;      
      1      [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;ChangeLabelTextNotification&quot; object:_textField.text]      
    
    
        <a href="/2014/02/18/利用代理/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-UIView"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/17/UIView/">UIView</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-17T06:00:00.000Z" itemprop="datePublished" class="post-time">
  2014-02-17
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 视图，表示屏幕上的一块矩形区域，同时处理该区域的绘制和触屏事件。 
 一个视图也可以作为其他视图的父视图，同时决定着这些子视图的位置和大小. 
 UIView类做了大量的工作去管理这些内部视图的关系。 
 视图同时也是App中MVC的View部分 
 iPhone的视图以左上角为原点 
 每个View的frame所使用的坐标系以它的父视图的左上角为坐 关函数 
 视图结构和相      1  2  3      CGPoint Point = CGPointMake(x,y);//设置  CGSize size = CGSizeMake(width,height);//大小  CGRect rect = CGRectMake(x,y,width,height);//位置和大小      
 
 
 
 
 ##Frame和Bounds 
 
 Frame以其父视图为起点，得出它自己的位置信息 
 Bounds以iOS系统的坐标原点为起点，坐标是(0,0) 
 Center表示视图中心所在的位置，设置此属性可改变视图的位置 
 默认情况下，视图边框并不会被父视图的边框裁剪。如果需要裁剪，将其clipsToBounds属性设置为YES. 
 
 
 
 ##创建UIView 
 
 创建UI有两种方式，xib文件和代码创建 
 
      1  2  3  4  5      //通过xib方式来创建视图对象  NSBundle *bundle = [NSBundle mainBundle];  NSArray *arr = [bundle loadNibNamed:@&quot;myView&quot; owner:self  options:nil];  UIView *myView = [arr objectAtIndex:0];      
      1  2  3      //代码创建视图对象  CGRect viewRect = CGRectMake(0,0,100,100);  UIView *myView =[[UIView alloc] initWithFrame:viewRect];      
 ##视图的层次结构 
 
 UIView层次结构可以理解为“视图树”————view hierarychy 
 一个视图就是一个容器，当一个视图包含其他的视图的时候，两个视图之间就建立了一个父子关系，被包含的视图被称为“姿势图（subView）”，包含的视图称为“父视图（superView）” 
 从视觉上看，子视图会覆盖父视图的内容，设置透明属性可以看到父视图的内容。 
 每个父视图都有一个有序的数组存储着它的子视图，存储的顺序就会影响到每个子视图的显示效果，后加的视图会覆盖之前的视图。 
 一个视图可以嵌入多个subView，但是只能有一个superView。 
 视图的常用方法      1  2  3  4  5  6  7  8      addSubView:                     // 添加子视图  insertSubview:atIndex:          // 视图插入到指定索引位置  insertSubview:ahoveSubview:     // 视图插入指定视图之上  insertSubview:belowSubview:     // 视图插入指定视图之下  bringSubviewToFront:            // 把视图移动到最顶层  sendSubviewToBack:              // 把视图移动到最底层  exchangeSubViewAtIndex:withSubviewAtIndex://把两个索引对应的视图调换位置  removeFromSuperview:            // 把视图从父视图中移除      
 
 
 
 
 ##查找视图 
 
 UIView类中有一个tag属性，通过这个属性可以标志一个视图对象（整数） 
 获取的方法，viewWithTag:方法来检索标志过的子视图        1  2  3  4      UIView *myView = [[UIView alloc] initWithFrame:CGRectmake(0,0,100,100)];  myView.tag = 100;  // 通过tag查找view  UIView *myView = [self.view vieWithTag:100];      
 
 
 ##UIView的常用属性 
 
 alpha                         // 透明度 
 backgroundColor               // 背景颜色 
 subViews                      // 子视图集合 
 hidden                        // 是否隐藏 
 tag                           // 标签值 
 superview                     // 父视图 
 mulitpleTouchEnaled           // 是否开启多点触摸 
 userInteractionEnabled        // 是否响应触摸事件 
 
   坐标系统变换  
 坐标变换通过transform属性来改变 
 CGAffineTransformScale        对视图比例缩放 
 CGAffineTransformRotae        对视图做变焦旋转 
 CGAffineTransformTranslate    对视图相对原位置做平移      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21          CGAffineTransform transform = rootView.transform;      rootView.transform = CGAffineTransformScale(transform,0.5,0.5);      rootView.transform = CGAffineTransformRotae(transform,0.33);      CGAffineTransformScale(transform,0.5,0.5);      rootView.transform = CGAffineTransformTranslate(transform,100,100);        ##视图的内容模式  - 视图的contentMode属性决定了边界变化和缩放操作  ```Objective-c      UIImageView *imgeView1 = [[UIImageView alloc] initWithFrame:CFRectMake(320/2-200/2,30,200,200)];      imgeView1.imge = [UIImage imageNamed:@&quot;01&quot;];      imgeView1.backgroundColor = [UIColor redColor];      imgeView1.contentMode = UIViewContentModeScaleAspectFit;      [self.window addSubview:imgeView1];      [imView1 release];            UIImageView *imgeView2 = [[UIImageView alloc] initWithFrame:CFRectMake(320/2-200/2,240,200,200)];      imgeView2.backgroundColor = [UIColor yelloColor];      imgeView2.contentMode = UIViewContentModeBottom;      [self.window addSubview:imgeView2];      [imView2 release];      
 
 
 
 
 ##UIView属性的动画 
 
  UIView类的很多属性都被设计为动画，动画的属性是指当属性从一个值变为另一个值的时候，可以半自动地支持动画，你仍然必须告诉UIKit希望执行什么类型的动画，但是动画一旦开始，Core Animation就会全权负责。UIView对象中支持动画的属性有如下几个： 
 
 frame - 动画的改变视图的尺寸和位置 
 bounds - 动画的改变视图的尺寸 
 center - 动画的改变视图的位置 
 transform - 动画的翻转或者缩放视x图 
 alpha - 动画的改变视图的透明度 
 backgroundColor - 改变视图的背景色 
 contentStetch - 改变视图内容如何拉伸 ###配置动画委托 
 
 
 可以为动画分配一个委托，并通过该委托接受动画开始和结束的消息。当需要在动画开始前和动画结束后极力执行其他任务时，可能就需要设置委托。 
  通过UIView调用setAnmationDelegate:方法来设置委托，并通过setAnimationWillStartSelector:和setAnimationDidStopSelector:方法来指定接受消息的选择器方法。消息处理方法形式如下:  (void)animationWillStart:(NSString *)animationID context:(void *)context;   (void)animationDidStop:(NSString *)animationID finished context:(void *)context;  上面的两个方法的animationID和context参数和动画块开始时传给 beginAnimations:context: 方法的参数相同 
 
 animationID - 应用程序提供的字符串，用于标识一个动画块中的动画 
 context - 应用程序提供的对象，用于向委托对象传递额外的信息 
 
 setAnimationDidStopSelector:选择器方法还有一个参数——即一个布尔值。如果动画顺利完成，没有被其他动画取消或停止，则该值为YES。 ###配置动画的参数 
 
 用 setAnimationStartDateS 方法来设置动画在 commitAnimations: 方法返回之后的发生日期。 
 用 setAnimationDelay: 方法来设置实际发生动画和 commitAnimations: 方法返回的时间点之间的间隔 
 用 setAnimationDuration: 方法来设置动画的持续秒数 
 用 setAnimationCurve: 方法来设置动画过程的相对速度，比如动画可能在启动阶段逐渐加速、而在结束阶段逐渐减少，或者这个过程都保持相同的速度 
 用 setAnimationRepeatCount: 方法来设置动画的重复次数 
 用 setAnimationRepeatAutoreverses: 方法来指定动画在到达目标值时是否自动反向播放。可是结合使用这个方法和 setAnimationRepeatCount: 方法，使各个属性在初始值和目标值之间平滑切换一段时间。 
 缺省情况下，所有支持动画的属性在动画块中发生的变化都会形成动画。如果希望让动画块中发生的某些变化不产生动画效果，可以通过 setAnimationsEnableed: 方法来暂时禁止动画，在完成修改后才重新激活动画，在调用 setAnimationsEnabled: 方法并传入NO值之后，所有的改变都不会产生动画效果，指定用YES值再次调用这个方法或者提交这个动画块是，动画才会恢复，可以用 areAnimationsEnable: 方法来确定当前是否激活动画。      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16      -(void)animationAlpha  &#123;      [UIView beginAnimations:nil context:NULL];// 需要设置代理时      [UIView setAnimationDuration:1];// 动画的持续时间      [UIview setAnimationDelay:1];// 动画延迟时间      view2.apleha = 0.0;      [UIView commitAnimations];// 标记着动画块的结束  &#125;  -(void)animationFrame  &#123;      [UIView beginAnimations:nil context:NULL];      [UIView setAnimationDuration:5];      [UIView setAnimationCurve:UIViewAnimationCurveEaseOut];// 动画相对速度，开始和结束的时候慢，中间快      view.center = CGPointMake(0,0);      [UIView commitAnimations];  &#125;       
 
 
 

    
    
        <a href="/2014/02/17/UIView/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-视图控制器与通知"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/17/视图控制器与通知/">视图控制器与通知</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-17T04:00:50.000Z" itemprop="datePublished" class="post-time">
  2014-02-17
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         ##UIViewController 
 
 视图控制器是数据和视图之间的桥梁，视图供职器提供了一个基本的框架来构建应用程序。 
 UIViewController是所有视图控制器的父类 
 iOS提供了许多内置的视图控制器，以支持标准的用户界面部分，比如导航控制器 UINavigationController ，标签栏控制器 UITabBarController ,表视图控制器 UITableViewController 等 
 
 ##视图控制器与视图的关系 
 
 视图控制器是传统Modle-View-Controller(MVC)设计模式中————控制器对象 
 视图控制器提供了许多控制器的基本功能 
 对于某些功能，基类提供了解决方案的一部分，其他的自定义的功能由视图控制器的子类去实现，比如：用户选择设备，可以由子类去控制是否旋转 
 视图控制器负责创建和管理一组视图，它本身提供一个视图，称为该试图控制器的根视图，协调管理数据的视图之间的交互 
 UIScreen对象时链接物理屏幕的标示 
 UIWindow为UIScreen对象提供画布 
 一组UIView对象就可以显示内容 
 每个视图控制器管理和控制一系列的视图 
 永远不要把UIView添加到UIWindow上，二是添加一个UIViewController 
 
 
 
 ##视图控制器(UIViewController)的创建       1  2  3  4  5  6  7      // 代码创建  UIViewController *mainViewController = [[UIViewCtroller alloc] init];  mainViewController.view.backgroundColor = [UIColor redColor];  self.window.rootViewController = mainViewCtroller;  // nib创建  RootViewController *rootViewController = [[RootViewController alloc] initWithNibName:@&quot;view&quot; bundle:nil];  self.window.rootViewController = rootViewController;       
 ##UIViewController生命周期         1  2  3  4  5  6  7      -(void)loadView  &#123;      // 调用父类来创建view      // 从nib、storybord加载View，否则创建一个empty view      // 创建一个自定义的视图，覆盖即可  &#125;  -(void)view       
 ###加载过程 
 
 首先去访问view属性 
 如果存在view，判断之间加载。否则，则UIViewCtroller调用loadView方法 
 loadView方法执行如下操作 
 如果覆盖了该方法，则必须创建View给UIViewCtroller的View属性 
 如果没有覆盖该方法，UIViewControlller会调用父类的方法 ###各个方法执行顺序 
 (id)initWithNibName:(NSString  )nibNameOrNil bundle:(NSBundle  )nibBundleOrNil 
 (void)loadView 
 (void)viewDidLoad 
 (void)viewWillAppear:(BOOL)animated 
 (void)viewDidAppear:(BOOL)animated 
 (void)viewWillDisappear:(BOOL)animated 
 (void)viewDidDisappear:(BOOL)animated 
 
 
 
 
 
 
 
 ##视图卸载   
 
 iOS6之前使用 viewDidUnload: 方法来释放对象的引用 
 iOS6之后使用 didRecevelMemoryWarning 内存紧张的时候调用 
 
 
 viewWillDisappear    视图将被从屏幕上移除之前执行 
 viewDidDisappear  视图已经被从屏幕上移除，用户看不到这个视图    
 dealloc  视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放 
 
 ##试图控制器的响应链 
 
 事件传递流程   当前触发的事件-&gt;视图控制器的跟视图-&gt;视图控制器-&gt;窗口-&gt;UIApplication对象-&gt;不处理 
 
 ##模态视图 
 
 模态视图不是特定的某个类，而是通过视图控制器的pressntModalViewController:方法弹出的视图称为模态视图 
 模态视图出现的场景一般是临时弹出的窗口，譬如：登入窗口 
 模态视图弹出时通过modalTransitionStyle属性设置不同的动画效果 
 调用dismissModalViewControllerAnimated:方法关闭窗口 
 
      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24      -(void)viewDidLoad  &#123;      [super viewDidLoad];      self.view.backgroundColor = [UIColor purpleColor];      UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundeRect];      button.frame = CGRectMake(320/2 - 140/2,80,140,40);      [button setTitle:@&quot;Present&quot; forState:UIControlStateNormal];      [button addTarget:self action:@selector[presentModalVc] forControlEvents:UIControlEventTouchUpInside];      [self.view addSubview:button];  &#125;  -(void)presentModalVC  &#123;      ModalViewController *modalVc = [[ModalViewController alloc] init];      // 动画效果      modalVc.modalTranstionSyle = UIModalTransitionStylePatialCurl;      if([[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0)&#123;          [self.presentModalViewController:modalVc animated:YES];      &#125;else&#123;          [self.presentModalViewController:modalVc animated:YES completion:^&#123;          NSLog(@&quot;call back&quot;);          &#125;];      [modalVC relese];      &#125;  &#125;      
      1  2  3  4  5  6  7  8      //ModalViewController.m  -(void)dismiss  &#123;         // 将模态视图关闭      [self dismissViewControllerAnimated:YES completion:^&#123;          NSLog(@&quot;dismiss&quot;)];      &#125;];  &#125;      
 ##支持多个方向 
   
 
 iOS设备中的加速计可以确定设备的当前方向。默认情况下，一个应用支持纵向和横向。当设备方向改变时，系统会发送UIDiviceOrientationDidChangeNotfication通知，默认情况下UIKit框架监听这个通知，并自定义更新这个方向。      1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36      -(void)viewDidLoad  &#123;      // ...      // 采用通知获取屏幕方向切换      [[UINotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientation:)name:UIDeviceOrientationDidChangeNotifitation object:nil];  &#125;  -(void)deviceOrientation:(NSNotification *)notification  &#123;      UIDevice *device = (UIDevice *)[notification object];      NSLog(@&quot;device:%d&quot;,device.orientation);  &#125;  -(BOOL)shoudlAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation  &#123;      return NO;   //NO为不支持      // return (toInterfaceOrientation != UIterfaceOrientationLandscapeLeft); // 不支持一个方向  &#125;  #pragma mark - Orientation iOS 3.0_5.0  -(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrienttation)toInterfaceOrientation  &#123;      return NO;  &#125;  #pragma mark - Orientation iOS 6.0  -(BOOL)shouldAutorotate  &#123;      return YES;  &#125;  -(void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration  &#123;      NSLog(@&quot;duration:%f&quot;,duration);      UIView* button = [self.view viewWithTag:101];      if(toInterfaceOrientation == UIInterfaceOrientationPortrait)&#123;          button.frame = CGRectMake(320/2-140/2,80,140,40);      &#125;else&#123;          button.frame = CGRectMake(480/2-140/2,80,140,40);      &#125;  &#125;      
 
 

    
    
        <a href="/2014/02/17/视图控制器与通知/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
    <li class="post-list-item">
        <article id="post-UIKIT框架"
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2014/02/17/UIKIT框架/">UIKIT框架</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2014-02-17T03:59:00.000Z" itemprop="datePublished" class="post-time">
  2014-02-17
</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/iOS/">iOS</a></li></ul>



    </div>

    <div class="post-content" id="post-content" itemprop="postContent" >

    
         
 UIView是视图的基类 
 UIViewController视图控制器的基类 
 UIResponder表示一个可以接受触摸屏上触摸事件的对象 
 UIWin（窗口）是视图的一个子类，窗口的主要功能：1、提供一个区域来显示视图，2、将事件（event）分发给视图。      1  2  3      self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen] bounds];  self.window.rootViewController = self.viewController;  [self.window makeKeyAndVisible];      
 
 
 ##UIScreen 
  - UIScreen对象可以充当iOS设备物理屏幕的替代者，通过`[[UIScreen mainScreen] bounds]`可以获得设备的屏幕大小
   ##UIWindow 
  - 通过UIApplication获取当前keyWindow，keyWindow是用来管理键盘以及触摸类的消息，并且只能有一个window是keyWindow.
- UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;
- 每个UIWindow对象配置windowLevel属性，大部分时候不应该去改变windowL.
- UIWindow有3个级别，对应了3种显示优先级。通过windowLevel设置，优先级为：UIWindowLevel &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal
        1  2  3  4  5  6  7  8  9  10  11  12      //didFinishLauchingWithOptions  self.windonw = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScrren] bounds]];  self.window.backgrondColor = [UIColor whiteColor];  [self.window makeKeyAndVisible];  NSLog(@&quot;self.window level: %@&quot;,self.windonw.level);    UIButton *startButton = [UIButton buttonWithType:UIButtonTypeRounedRect];  startButton.frame = CCRectMake(320/2-120/2,180,120,35);  [startButton setTile:@&quot;警告&quot; action:@selector(alertUser) forControlEvents:UIControlEventTouchUpInside];  [self.window addSubview:startButton];    return YES;      
      1  2  3  4  5  6  7  8  9  10  11      // alerUser  -(void)alertUser  &#123;      UIAlertView *alertView = [[UIAlertView alloc]                                  initWithTitle:@&quot;提示&quot;                                  message:@&quot;警告框是alert Level级别的&quot;                                  delegate:nil                                  cancelButtonTitle:@&quot;确定&quot;                                  otherButtonTitles:nil];      [alertView show];  &#125;      
    
    
        <a href="/2014/02/17/UIKIT框架/" class="post-more waves-effect waves-button">
            
        </a>
    </div>
    
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

</article>

    </li>
  
</ul>

<nav id="page-nav">
    <div class="inner">
    <a class="extend prev" rel="prev" href="/page/38/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="page-number" href="/page/38/">38</a><span class="page-number current">39</span>
    </div>
</nav>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>










</body>
</html>
