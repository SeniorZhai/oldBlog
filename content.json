[{"title":"API可用性检测","date":"2016-08-26T05:37:00.000Z","path":"2016/08/26/API可用性检测/","text":"Swift有检查API可用性的内置支持，确保我们在使用时不会不小心使用当前不可用的API12345if # available(platform name version, ..., *) &#123; statements&#125; else &#123; statements&#125; 可用性条件获取了一系列平台的名字和版本，平台名可以是iOS、OSX、watchOS，版本号可以是主版本号或者小版本，比如1# available(iOS 9, OSX10.10, *) 最后一个参数*是必须写的，用于处理未来潜在的平台","tags":[{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"guard和defer","date":"2016-08-25T11:01:12.000Z","path":"2016/08/25/guard和defer/","text":"在看swift的代码的时候，遇见两个新的关键字，语法特性很特别 guardguard有点像断言1234567if age &lt; 13 &#123; return&#125;// 与上面代码等价guard age &gt;= 13 else &#123; return&#125; guard起来保证的作用，age大于13否则return在if-let解包的时候使用，会使得代码看清来更简洁12345678910guard let name = user.name else &#123; return&#125;/* 逻辑 */if let name = user.name &#123; /* 处理逻辑 */&#125; else &#123; return&#125; deferdefer是使代码延后处理的新特性12345678910// ...openDirectory()defer&#123; closeDirectory()&#125;opeFile()defer &#123; closeFile()&#125;// ... defer会在将代码块以入栈出栈的方式延后运行，比如上面的代码会先执行打开文件夹(openDirectory)后打开文件(openFile)，在所有处理完成后，执行关闭文件(closeFile)，再关闭文件夹(closeDirectory)的操作","tags":[{"name":"swift","slug":"swift","permalink":"http://seniorzhai.github.io/tags/swift/"},{"name":"关键字","slug":"关键字","permalink":"http://seniorzhai.github.io/tags/关键字/"}]},{"title":"专用图层","date":"2016-08-03T06:05:38.000Z","path":"2016/08/03/专用图层/","text":"iOS里有很多专用的Layer，用来处理各种不同绘制需求 CATextLayer123456789101112131415let textLayer = CATextLayer()textLayer.frame = self.view.boundsself.view.layer.addSublayer(textLayer)textLayer.foregroundColor = UIColor.blueColor().CGColortextLayer.alignmentMode = kCAAlignmentJustifiedtextLayer.wrapped = truelet font = UIFont.systemFontOfSize(15)let fontRef = CGFontCreateWithFontName(font.fontName)textLayer.font = fontReftextLayer.fontSize = font.pointSizeCFRelease(fontRef)textLayer.string = \"示例文字\\n示例文字\" 注: 需要指定contentScale才能按设备放大系数准确渲染 CATextLayer的font属性不是一个UIFont类型，二是一个CFTypeRef类型，这样可以根据需要来使用CGFontRef还是CTFontRef 富文本","tags":[]},{"title":"图层几何学","date":"2016-06-26T13:10:50.000Z","path":"2016/06/26/图层几何学/","text":"UIView有三个比较重要的布局属性：frame，bounds，center，对应到CALayer叫做frame，bounds，position frame代表图层的外部坐标，也就是父图层上占据的空间 bounds内部坐标，{0，0}是图层的左上角 center、position都代表了相对父图层的anchorPoint所在的位置 锚点默认的anchorPoint位于图层的中点，所以图层将会以这个点为中心放置，anchorPoint属性并没有暴露个UIView接口暴露出来，这也就是视图position属性被叫做center，但是图层的anchorPoint可以被移动anchorPoint用单位坐标来描述，图层左上角是{0,0}，右下角是{1,1}，默认坐标是{0.5,0.5}，anchorPoint也可以通过指定x和y值小于或大于1，使它放置在图层范围之外。","tags":[{"name":"布局","slug":"布局","permalink":"http://seniorzhai.github.io/tags/布局/"}]},{"title":"图层几何学","date":"2016-06-26T13:10:50.000Z","path":"2016/06/26/Hit-Testing/","text":"UIView有三个比较重要的布局属性：frame，bounds，center，对应到CALayer叫做frame，bounds，position frame代表图层的外部坐标，也就是父图层上占据的空间 bounds内部坐标，{0，0}是图层的左上角 center、position都代表了相对父图层的anchorPoint所在的位置 锚点默认的anchorPoint位于图层的中点，所以图层将会以这个点为中心放置，anchorPoint属性并没有暴露个UIView接口暴露出来，这也就是视图position属性被叫做center，但是图层的anchorPoint可以被移动anchorPoint用单位坐标来描述，图层左上角是{0,0}，右下角是{1,1}，默认坐标是{0.5,0.5}，anchorPoint也可以通过指定x和y值小于或大于1，使它放置在图层范围之外。 坐标系一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动定义一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形 convertPoint(p: CGPoint, toLayer:CALayer) convertPoint(p: CGPoint,toLayer:CALayer) convertRect(rect: CGRect,fromLayer: CALayer) convertRect(rect: CGRect,toLayer: CALayer) 翻转几何结构通常iOS一个图层的position位于父图层的左上角，Mac OS则位于左下角，Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标系是否相对父图层垂直翻转。 Z坐标轴CALayer存在一个三维空间，除了posistion和anchorPoint属性外，CALayer还有另外两个属性，zPosition和anchorPointZ两者都是在Z轴上描述图层位置的浮点类型。zPosition决定图层显示顺序，图层根据子图层的sublayers出现的顺序来类绘制。1self.greenView.layer.zPosition = 1.0f","tags":[{"name":"布局","slug":"布局","permalink":"http://seniorzhai.github.io/tags/布局/"}]},{"title":"CALayer","date":"2016-06-25T12:29:25.000Z","path":"2016/06/25/CALayer/","text":"在iOS当中，所有的视图都从UIView的基类派生二来，UIView 可以处理触摸时间，可以支持基于Core Graphics绘图，可以做旋转或者缩放。 CALayerCALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容，管理子图层的位置。和UIView不同的是CALayer不处理用户交互。每一个UIView都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层。UIView没有暴露出一些CALayer的功能： 阴影、圆角、带颜色的边框 3D变换 非矩形范围 透明遮罩 多级非线性动画 12345678override func viewDidLoad() &#123; super.viewDidLoad() contentView.backgroundColor = UIColor.grayColor() let layer = CALayer() layer.frame = CGRectMake(50, 50, 100, 100) layer.backgroundColor = UIColor.blueColor().CGColor contentView.layer.addSublayer(layer)&#125; 一个视图只有一个相关联的图层(自动创建)，同时也可以支持添加无数个子图层，并且把它直接添加视图关联图层的子图层 使用图层关联的视图而不是CALayer的好处在于，能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API当满足以下条件的时候，使用CALayer更为合适 开发同时在Mac OS上运行的跨平台应用 使用多种CALayer的子类，并且不想创建额外的UIView去包装它们所有 做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同 contents属性CALayer有一个属性contents，这个属性的类型是id，意味着它可以是任何类的对象，给contents赋任何值，都可以编译通过，但是contents不是CGImage，那么得到的图层将是空白。12345678910override func viewDidLoad() &#123; super.viewDidLoad() contentView.backgroundColor = UIColor.grayColor() let layer = CALayer() layer.frame = CGRectMake(50, 50, 100, 100) layer.contents = UIImage(named: \"icon\")?.CGImage contentView.layer.addSublayer(layer) &#125; 简单的添加就可以显示在UIView中显示图片 contentGravity和UIView的contentMode一样，contentGravity可以指定内容在同层边界中对齐方式 kCAGravityCenter kCAGravityTop kCAGravityBottom kCAGravityLeft kCAGravityRight kCAGravityTopLeft kCAGravityTopRight kCAGravityBottomLeft kCAGravityBottomRight kCAGravityResize kCAGravityResizeAspect kCAGravityResizeAspectFillcontentsScalecontentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数如果contentsScale设置为1.0，将会每个点1一个像素绘制1个像素绘制图片，如果设置为2.0，则会每两个点像素绘制图片maskToBoundsUIView有一个clipsToBounds的属性用来指定是否显示超出边界的内容，CALayer对应的属性叫做maskToBoundscontentsCentercontentsCenter定义了一个固定的边框和一个图层上可拉伸的区域。改变contentsCenter的值并不会影响到寄宿图的显示。默认情况下，contentsCenter是{0,0,1,1}，这意味着如果大小改变了，那么寄宿图将会均匀地拉伸开。 自定义绘制给contents赋CGImage并不是唯一设置寄宿图的方法，也可以直接用Core Graphics直接绘制寄宿图，也能够继承UIView并实现drawRect方法来绘制当视图在屏幕上显示的时候，drawRect方法会被调用，在方法里可以使用Graphics去绘制一个寄宿图。然后内容就会被缓存起来直到它需要更新（通常因为开发者调用了setNeedsDisplay方法）CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容 特定的信息时，就会从协议中请求drawLayer方法，CALayerDelegate是非正式协议1234567891011override func viewDidLoad() &#123; super.viewDidLoad() contentView.layer.delegate = self contentView.layer.display()&#125;override func drawLayer(layer: CALayer, inContext ctx: CGContext) &#123; CGContextSetLineWidth(ctx, 10) CGContextSetStrokeColorWithColor(ctx, UIColor.redColor().CGColor) CGContextStrokeEllipseInRect(ctx, layer.bounds)&#125;","tags":[{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"},{"name":"view","slug":"view","permalink":"http://seniorzhai.github.io/tags/view/"}]},{"title":"GoogleIO第一份惊喜-ConstraintLayout","date":"2016-05-19T06:03:07.000Z","path":"2016/05/19/GoogleIO第一份惊喜-ConstraintLayout/","text":"了解iOS开发的童鞋应该知道，自iPhone6推出后，iOS也进入多屏适配时代，AutoLayout成为了适配的首选，Storyboard+AutoLayout成为了iOS布局的主要流派之一（代码适配也是不错的选择）。拖拽组件，设定约束，一个界面就基本完成了（当然，还有一堆高级的用法）。而Android开发工程师还在苦逼地将设计稿分割，这部分用一个RelativeLayout，这部分用LinearLayout……然后嵌套一下，或者再套一层。对于很多对几大布局不是很了解的同学，往往几个界面的组成就够头痛一阵了。拯救你们的救星来了，ConstraintLayout将解决你的难言之隐，还在等待什么，赶快拿起电话*&amp;……%￥(不好意思出戏了) 开始首先确保你的Android Studio是2.2 preview或者更高版本，预览拖拽设定约束需要新的布局编辑窗口，低版本AS应该可以用ConstraintLayout，但没用设置约束功能（光手写XML，为什么还用ConstraintLayout） ConstraintLayout是一个单独的支持包，所以需要在gradle中添加引用1234dependencies &#123; ... compile &apos;com.android.support.constraint:constraint-layout:1.0.0-alpha&apos;&#125; 在Layout文件中引用12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 使用在布局编辑窗口中选择Design(我几乎是第一次选择他，而不是直接去使用TextV去写XML) 约束Constraints约束可以帮助你设定不同组件之间的位置关系，比如，这个A组件在B组件右边25dp且位于C组件下方8dp的位置。 在布局编辑窗口中，当你选中一个组件可以看到以下情况拖拽边角的方形，可以控制组件的大小拖拽四边的圆形，可以设置组件相对四个方向上的距离约束拖拽下方圆角矩形，可以设置组件间的基线对齐 基本使用当拖动大小约束时，大小会被改变当拖动位置约束时，锚点变绿即建立约束成功当约束建立成功后，再次点击锚点即可删除约束设置基线约束，可以对齐文本 当然拖动并不能准确的设置约束，这个时候我们看看到右边的属性窗口在这里你可以设置组件的相关约束和组件的相关属性在属性窗口中，你可以看到约束的UI界面是这样的每个约束是一个I型的图标，点击可以切换如下三个状态Fixed：固定尺寸约束，指定组件大小AnySize：占用可用空间Wrap Content：包含组件内容大小 以上可以在官方示例中查看 缺点 UI操作并不顺畅，控件经常点击不到 缺少等宽等约束，复杂的需求不一定能实现 当ConstraintLayout不是根布局时， UI操作基本不可用 注：以上可能是本人并不熟练或不够了解导致的","tags":[{"name":"AutoLayout","slug":"AutoLayout","permalink":"http://seniorzhai.github.io/tags/AutoLayout/"},{"name":"约束","slug":"约束","permalink":"http://seniorzhai.github.io/tags/约束/"},{"name":"布局","slug":"布局","permalink":"http://seniorzhai.github.io/tags/布局/"},{"name":"Layout","slug":"Layout","permalink":"http://seniorzhai.github.io/tags/Layout/"}]},{"title":"Weex初探","date":"2016-05-10T09:53:42.000Z","path":"2016/05/10/Weex初探/","text":"目前weex还在内测阶段，还是一个github的私有项目 基础环境 Node.js 4.0+ Android SDK Android Studio如何开始clone项目，在项目目录下执行npm install,./start将android/playground/app/java/com/alibaba/weex/WXMainActivity修改CURRENT_IP将本地IP之后运行项目简单的使用可以看到weex的写法和原生的html很像，简单的hello weex如下：12345&lt;template&gt; &lt;div&gt; &lt;text style=\"style-size:100px;\"&gt;Hello weex!&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"weex","slug":"weex","permalink":"http://seniorzhai.github.io/tags/weex/"}]},{"title":"UIStackView的使用","date":"2016-04-25T06:28:56.000Z","path":"2016/04/25/UIStackView的使用/","text":"Stack View是一个方便垂直或水平排布subView，与Android中的LinearLayout非常相似。 布局使用Stack View在Attributes Inspector中，Axis表示Stack View的SubView是水平排布还是垂直布局。Alignment控制SubView的对齐方式。Distribution定义SubView的分布方式。Spacing为SubView间的最小间距。","tags":[]},{"title":"ProGuard详解","date":"2016-04-11T06:16:42.000Z","path":"2016/04/11/ProGuard详解/","text":"ProGuard包括4各功能： 压缩(Shrink) 移除代码中无用的类、字段、方法、和特性 优化(Optimize) 对字节码进行优化，移除无用的指令 混淆(Obfuscate) 使用剪短无意义的名称对类、字段、方法重命名 预检(Preveirfy) 在Java平台上对处理后的代码进行预检 ProGuard的工作原理ProGuard由Shrink,Optimize,Obfuscate,Preveirfy四个步骤组成，其中每个步骤都是可选的 编写ProGuard文件 基本指令 代码混淆压缩比，在0~7之间，默认为5，-optimizationpasses 5 混淆时不使用大小写混合，混淆的类名为小写 -dontusemixedcaseclassnames 指定不去忽略废公共的库的类 -dontskipnonpubliclibaryclasses 指定不去忽略废公共的库的类的成员 -dontskipnonpubliclibaryclassesmembers 不做预校验 -dontpreverify 生成映射文件 -verbose 使用printmapping指定映射文件的名称 -printmapping proguardMapping.txt 指定混淆时采用的算法 -optimizations ! code/ simplification/ arithmetic,!fiedld/*,class/merging/* 保护代码中的Annotation不被混淆 -keepattributes *Annotation* 避免混淆泛型 -keepattributes Signature 抛出异常时保留代码行数 -keepattributes SourceFile,LineNumberTable 需要保留的 保留本地native方法不被混淆 123- keepclasseswithmembernames class * &#123; native &lt;methods&gt;;&#125; 保留某些子类不被混淆 1- keep public class * extends android.app.Activity 保护在XML中设置onClick不被影响 123- keepclassmembers class * extends android.app.Activity &#123; public void *(android.view.View);&#125; 保护Fragment - keep public class android.support.v4.app.Fragment.** {*;} 保留枚举不被混淆 1234- keepclassmembers enum * &#123; public static **&#123;&#125; values(); public static ** valueOf(Java.lang.String);&#125; 保留自定义控件不被混淆 1234567- keep public class * extends android.view.View &#123; *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context,android.util.ArrtibuteSet); public &lt;init&gt;(android.content.Context,android.util.ArrtibuteSet,int);&#125; 保留Parcelable序列化不被混淆 123- keep class * implements android.os.Parcelable &#123; public static final android.os.Parcelable$Creator *;&#125; 保留Serializable序列化类不被混淆 12345678- keepclassemembers class * implements java.io.Serializable &#123; static final long serialVersionID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve();&#125; 保留R文件下的资源不被混淆 1- keep class **.R$&#123;*;&#125; 保留内部类不被混淆 1- keep class com.example.app.ui.MainActivity$*&#123;*;&#125; 对WebView的处理 1234567- keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.WebView,java.lang.String,android.graphics.Bitmap); public boolean *(android.webkit.WebView,java.lang.String);&#125;- keepclassmembers class * extends android.webkit.webViewClient &#123; public void *(android.webkit.webView,java.lang.String);&#125; 对JavaScript 123- keepclassemembers class com.example.app.MainActivity$JSInterface &#123; &lt;methods&gt;;&#125; 针对第三方库的混淆保护123456- libraryjas libs/android-support-v4.jar- dontwarn android.support.v4.**- keep class android.support.v4.**&#123;*;&#125;- kepp interface android.support.v4.app.**&#123;*;&#125;- kepp public class * extends android.support.v4.**- keep public class * extends android.app.Fragment","tags":[{"name":"ProGuard","slug":"ProGuard","permalink":"http://seniorzhai.github.io/tags/ProGuard/"},{"name":"混淆","slug":"混淆","permalink":"http://seniorzhai.github.io/tags/混淆/"}]},{"title":"在Drawable里指定ripple","date":"2016-03-15T03:05:29.000Z","path":"2016/03/15/在Drawable里指定ripple/","text":"在drawable中12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_pressed=\"true\"&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"@android:color/darker_gray\" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"@android:color/white\" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 在drawable-v21中123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ripple xmlns:android=\"http://schemas.android.com/apk/res/android\" android:color=\"@android:color/darker_gray\"&gt; &lt;item&gt; &lt;shape android:shape=\"rectangle\"&gt; &lt;solid android:color=\"@android:color/white\" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/ripple&gt;","tags":[{"name":"ripple","slug":"ripple","permalink":"http://seniorzhai.github.io/tags/ripple/"}]},{"title":"使用jadx","date":"2016-03-10T06:11:00.000Z","path":"2016/03/10/使用jadx/","text":"使用将jadx克隆到本地，进行编译123git clone https://github.com/skylot/jadxcd jadx./gradlew dist 编译完成后可以在build/jadx/bin中找到运行文件 运行GUI界面可以点击运行jadx-gui文件命令行可以使用./jadx1jadx demo.apk 命令格式12345678910111213141516jadx[-gui] [options] &lt;input file&gt; (.dex , .apk , .jar or .class)options: -d,--output-dir 指定输出文件夹 -j,--threads-count 执行线程数量 -f,--fallback -r,--no-res 不解码资源文件 -s,--no-src 不反编代码 --show-bad-code 显示不正确的反编译代码 --cfg --raw-cfg -v,--verbose 详细输出 --deobf 激活deofuscation --deobf-min --deobf-max --deobf-rewrite-cfg -h,--help –deobf –deobf-rewrite-cfg","tags":[{"name":"反编译","slug":"反编译","permalink":"http://seniorzhai.github.io/tags/反编译/"}]},{"title":"Kotlin简单的开始","date":"2016-02-18T09:23:49.000Z","path":"2016/02/18/Kotlin简单的开始/","text":"安装Kotlin插件 Kotlin 使Android Studio可以识别kotlin代码 Kotlin Android Extensions 使Android Studio可以自动地从XML中注入所有的View到Activity 修改Gradle1234567891011121314151617181920212223242526apply plugin: 'com.android.application'apply plugin: 'kotlin-android'android &#123; ... sourceSets &#123; main.java.srcDirs += 'src/main/kotlin' &#125;&#125;dependencies &#123; ... compile \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"&#125;buildscript &#123; ext.kotlin_version = '1.0.0' repositories &#123; mavenCentral() &#125; dependencies &#123; classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" &#125;&#125;repositories &#123; mavenCentral()&#125; PS：未修改处省略 修改MainActivity选择MainActivity.java-&gt;Code-&gt;Convert Java File to Kotlin File","tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://seniorzhai.github.io/tags/Kotlin/"}]},{"title":"(转)ReactNative-ES5 ES6写法对照","date":"2016-01-25T12:37:20.000Z","path":"2016/01/25/-转-ReactNative-ES5-ES6写法对照/","text":"转至http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8/2很多React/React Native的初学者都被ES6的问题迷惑：各路大神都建议我们直接学习ES6的语法(class Foo extends React.Component)，然而网上搜到的很多教程和例子都是ES5版本的，所以很多人在学习的时候连照猫画虎都不知道怎么做。今天在此整理了一些ES5和ES6的写法对照表，希望大家以后读到ES5的代码，也能通过对照，在ES6下实现相同的功能。 模块引用在ES5里，如果使用CommonJS标准，引入React包基本通过require进行，代码类似这样：1234567//ES5var React = require(\"react-native\");var &#123; Image, Text, PropTypes&#125; = React; //引用不同的React Native组件 在ES6里，import写法更为标准123456//ES6import React, &#123; Image, Text, PropTypes&#125; from 'react-native'; 注意在React Native里，import直到0.12+才能正常运作。 导出单个类在ES5里，要导出一个类给别的模块用，一般通过module.exports来导出12345//ES5var MyComponent = React.createClass(&#123; ...&#125;);module.exports = MyComponent; 在ES6里，通常用export default来实现相同的功能：1234//ES6export default class MyComponent extends React.Component&#123; ...&#125; 引用的时候也类似：12//ES5var MyComponent = require('./MyComponent.js'); 12//ES6import MyComponent from './MyComponent.js'; 定义组件在ES5里，通常通过React.createClass来定义一个组件类，像这样：12345678//ES5var Photo = React.createClass(&#123; render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;); 在ES6里，我们通过定义一个继承自React.Component的class来定义一个组件类，像这样：12345678//ES6class Photo extends React.Component &#123; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 给组件定义方法从上面的例子里可以看到，给组件定义方法不再用 名字: function()的写法，而是直接用名字()，在方法的最后也不能有逗号了。1234567891011//ES5var Photo = React.createClass(&#123; componentWillMount: function()&#123; &#125;, render: function() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;,&#125;); 1234567891011//ES6class Photo extends React.Component &#123; componentWillMount() &#123; &#125; render() &#123; return ( &lt;Image source=&#123;this.props.source&#125; /&gt; ); &#125;&#125; 定义组件的属性类型和默认属性在ES5里，属性类型和默认属性分别通过propTypes成员和getDefaultProps方法来实现1234567891011121314151617181920//ES5var Video = React.createClass(&#123; getDefaultProps: function() &#123; return &#123; autoPlay: false, maxLoops: 10, &#125;; &#125;, propTypes: &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return ( &lt;View /&gt; ); &#125;,&#125;); 在ES6里，可以统一使用static成员来实现123456789101112131415161718//ES6class Video extends React.Component &#123; static defaultProps = &#123; autoPlay: false, maxLoops: 10, &#125;; // 注意这里有分号 static propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired, &#125;; // 注意这里有分号 render() &#123; return ( &lt;View /&gt; ); &#125; // 注意这里既没有分号也没有逗号&#125; 也有人这么写，虽然不推荐，但读到代码的时候你应当能明白它的意思：123456789101112131415161718//ES6class Video extends React.Component &#123; render() &#123; return ( &lt;View /&gt; ); &#125;&#125;Video.defaultProps = &#123; autoPlay: false, maxLoops: 10,&#125;;Video.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired, posterFrameSrc: React.PropTypes.string.isRequired, videoSrc: React.PropTypes.string.isRequired,&#125;; 注意: 对React开发者而言，static成员在IE10及之前版本不能被继承，而在IE11和其它浏览器上可以，这有时候会带来一些问题。React Native开发者可以不用担心这个问题。 初始化stateES5下情况类似，12345678//ES5var Video = React.createClass(&#123; getInitialState: function() &#123; return &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;,&#125;) ES6下，有两种写法：123456//ES6class Video extends React.Component &#123; state = &#123; loopsRemaining: this.props.maxLoops, &#125;&#125; 不过我们推荐更易理解的在构造函数中初始化（这样你还可以根据需要做一些计算）：123456789//ES6class Video extends React.Component &#123; constructor(props)&#123; super(props); this.state = &#123; loopsRemaining: this.props.maxLoops, &#125;; &#125;&#125; 把方法作为回调提供很多习惯于ES6的用户反而不理解在ES5下可以这么做：1234567891011121314//ES5var PostInfo = React.createClass(&#123; handleOptionsButtonClick: function(e) &#123; // Here, 'this' refers to the component instance. this.setState(&#123;showOptionsModal: true&#125;); &#125;, render: function()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick&#125;&gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125;); 在ES5下，React.createClass会把所有的方法都bind一遍，这样可以提交到任意的地方作为回调函数，而this不会变化。但官方现在逐步认为这反而是不标准、不易理解的。 在ES6下，你需要通过bind来绑定this引用，或者使用箭头函数（它会绑定当前scope的this引用）来调用1234567891011121314151617//ES6class PostInfo extends React.Component&#123; handleOptionsButtonClick(e)&#123; this.setState(&#123;showOptionsModal: true&#125;); &#125; render()&#123; return ( &lt;TouchableHighlight onPress=&#123;this.handleOptionsButtonClick.bind(this)&#125; onPress=&#123;e=&gt;this.handleOptionsButtonClick(e)&#125; &gt; &lt;Text&gt;&#123;this.props.label&#125;&lt;/Text&gt; &lt;/TouchableHighlight&gt; ) &#125;,&#125; 箭头函数实际上是在这里定义了一个临时的函数，箭头函数的箭头=&gt;之前是一个空括号、单个的参数名、或用括号括起的多个参数名，而箭头之后可以是一个表达式（作为函数的返回值），或者是用花括号括起的函数体（需要自行通过return来返回值，否则返回的是undefined）。12345678910111213// 箭头函数的例子()=&gt;1v=&gt;v+1(a,b)=&gt;a+b()=&gt;&#123; alert(\"foo\");&#125;e=&gt;&#123; if (e == 0)&#123; return 0; &#125; return 1000/e;&#125; 需要注意的是，不论是bind还是箭头函数，每次被执行都返回的是一个新的函数引用，因此如果你还需要函数的引用去做一些别的事情（譬如卸载监听器），那么你必须自己保存这个引用1234567891011121314151617181920212223242526// 错误的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener('change', this.onAppPaused.bind(this)); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this.onAppPaused.bind(this)); &#125; onAppPaused(event)&#123; &#125;&#125;// 正确的做法class PauseMenu extends React.Component&#123; constructor(props)&#123; super(props); this._onAppPaused = this.onAppPaused.bind(this); &#125; componentWillMount()&#123; AppStateIOS.addEventListener('change', this._onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this._onAppPaused); &#125; onAppPaused(event)&#123; &#125;&#125; 从这个帖子中我们还学习到一种新的做法：123456789101112// 正确的做法class PauseMenu extends React.Component&#123; componentWillMount()&#123; AppStateIOS.addEventListener('change', this.onAppPaused); &#125; componentDidUnmount()&#123; AppStateIOS.removeEventListener('change', this.onAppPaused); &#125; onAppPaused = (event) =&gt; &#123; //把方法直接作为一个arrow function的属性来定义，初始化的时候就绑定好了this指针 &#125;&#125; Mixins在ES5下，我们经常使用mixin来为我们的类添加一些新的方法，譬如PureRenderMixin12345678var PureRenderMixin = require('react-addons-pure-render-mixin');React.createClass(&#123; mixins: [PureRenderMixin], render: function() &#123; return &lt;div className=&#123;this.props.className&#125;&gt;foo&lt;/div&gt;; &#125;&#125;); 然而现在官方已经不再打算在ES6里继续推行Mixin，他们说：Mixins Are Dead. Long Live Composition。 尽管如果要继续使用mixin，还是有一些第三方的方案可以用，譬如这个方案 不过官方推荐，对于库编写者而言，应当尽快放弃Mixin的编写方式，上文中提到Sebastian Markbåge的一段代码推荐了一种新的编码方式：1234567891011121314151617181920212223242526//Enhance.jsimport &#123; Component &#125; from \"React\";export var Enhance = ComposedComponent =&gt; class extends Component &#123; constructor() &#123; this.state = &#123; data: null &#125;; &#125; componentDidMount() &#123; this.setState(&#123; data: 'Hello' &#125;); &#125; render() &#123; return &lt;ComposedComponent &#123;...this.props&#125; data=&#123;this.state.data&#125; /&gt;; &#125;&#125;;//HigherOrderComponent.jsimport &#123; Enhance &#125; from \"./Enhance\";class MyComponent &#123; render() &#123; if (!this.data) return &lt;div&gt;Waiting...&lt;/div&gt;; return &lt;div&gt;&#123;this.data&#125;&lt;/div&gt;; &#125;&#125;export default Enhance(MyComponent); // Enhanced component 用一个“增强函数”，来某个类增加一些方法，并且返回一个新类，这无疑能实现mixin所实现的大部分需求。 ES6+带来的其它好处解构&amp;属性延展 结合使用ES6+的解构和属性延展，我们给孩子传递一批属性更为方便了。这个例子把className以外的所有属性传递给div标签：1234567891011121314class AutoloadingPostsGrid extends React.Component &#123; render() &#123; var &#123; className, ...others, // contains all properties of this.props except for className &#125; = this.props; return ( &lt;div className=&#123;className&#125;&gt; &lt;PostsGrid &#123;...others&#125; /&gt; &lt;button onClick=&#123;this.handleLoadMoreClick&#125;&gt;Load more&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 下面这种写法，则是传递所有属性的同时，用覆盖新的className值：123&lt;div &#123;...this.props&#125; className=\"override\"&gt; …&lt;/div&gt; 这个例子则相反，如果属性中没有包含className，则提供默认的值，而如果属性中已经包含了，则使用属性中的值123&lt;div className=\"base\" &#123;...this.props&#125;&gt; …&lt;/div&gt;","tags":[{"name":"SE5","slug":"SE5","permalink":"http://seniorzhai.github.io/tags/SE5/"},{"name":"SE6","slug":"SE6","permalink":"http://seniorzhai.github.io/tags/SE6/"},{"name":"ReactNative","slug":"ReactNative","permalink":"http://seniorzhai.github.io/tags/ReactNative/"}]},{"title":"ReactNative-Flex","date":"2016-01-22T18:29:50.000Z","path":"2016/01/23/ReactNative-Flex/","text":"https://github.com/SeniorZhai/FlexDemo","tags":[{"name":"Flex","slug":"Flex","permalink":"http://seniorzhai.github.io/tags/Flex/"}]},{"title":"简单配置","date":"2016-01-22T04:10:49.000Z","path":"2016/01/22/简单配置/","text":"用了一段时间Atom来写React，觉得还是不够好用，虽然漂亮重回老路，配置下WebStrom，发现也还可以 最新的版本，是WebStrom 11，好像激活的方法有变更，不复述。http://www.oschina.net/question/1184821_2142539?fromerr=tlf5g1xd 关于Code Theme方面，这款Obsidian也是不错的选择。 为了方便开发，我还配置了一些Live Templeates，简单的处理下一个组件的初始化123456789101112131415161718192021'use strict'var React = require('react-native')var &#123; StyleSheet, View, &#125; = React;var $NAME$ = React.createClass(&#123; render: function () &#123; return ( &lt;View&gt;$END$&lt;/View&gt; ); &#125;&#125;);var styles = StyleSheet.create(&#123;&#125;);exports.module = $NAME$;","tags":[{"name":"Atom","slug":"Atom","permalink":"http://seniorzhai.github.io/tags/Atom/"},{"name":"配置","slug":"配置","permalink":"http://seniorzhai.github.io/tags/配置/"},{"name":"WebStrom","slug":"WebStrom","permalink":"http://seniorzhai.github.io/tags/WebStrom/"},{"name":"Sublime","slug":"Sublime","permalink":"http://seniorzhai.github.io/tags/Sublime/"}]},{"title":"SystemUI与FitsSystemWindows","date":"2016-01-20T04:30:17.000Z","path":"2016/01/20/SystemUI与FitsSystemWindows/","text":"在亘古时代(Android 2.+)的时候，全屏操作简单粗暴，但是切换显示、隐藏时丑陋之极。 在theme中设置 1234&lt;application android:theme=\"@android:style/Theme.Holo.NaoActionBar.Fullscreen\"...&lt;/application&gt; 在activity渲染之前 1234567891011... @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); if (Build.VERSION.SDK_INT &lt; 16) &#123; getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); &#125; setContentView(...); ... &#125;... 因为设置了WindowManager的flag，想要切换只能重置flag，而且因为大小变了，activity的界面也会改变。 在改革春风吹满地的新时代(Android 4.0+)，SDK提供了我们新的选择，使用setSystemUiVisibility()来操控SystemUI，这里不只StatusBar还有NavigationBar 4.0可使用的方法123View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN;decorView.setSystemUiVisibilit(uiOptions); 触摸屏幕任何位置都会使得导航、状态栏出现，且SYSTEM_UI_FLAG_HIDE_NAVIGATION被清除 一旦标志位被清除，需要重新设置 在不用地方UI FLAG是不同的，所有最好在onReasume()和onWindowFocusChaned()中设置 被调用的View显示时才会生效4.1以后上面的方法设置后，内容还是会因为场景的变化而变化，所以我们需要让我们的内容放在SystemUI的后面123View decorView = getWindow().getDecorView();int uiOptions = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION |View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;decorView.setSystemUiVisibilit(uiOptions); 值得注意的是，有些控件我们是不希望不覆盖住的，比如toolbar，这个时候需要给它加上FitsSystemWindows属性，保证不会被SystemUI遮住。从示例上看，系统会为View设置上Padding，所以，如果要做切换时，可能要考虑还原View的Padding。 示例https://github.com/SeniorZhai/SystemUI","tags":[]},{"title":"gradle下载地址","date":"2016-01-18T14:19:42.000Z","path":"2016/01/18/gradle下载地址/","text":"https://services.gradle.org/distributions/ 放到~/.gradle/wrapper/dists目录下 不知道是不是我环境的问题，用P2P下载文件一直有问题，还是直接下载的好","tags":[]},{"title":"ReactNative-ListView","date":"2016-01-17T15:26:29.000Z","path":"2016/01/17/ReactNative-ListView/","text":"","tags":[]},{"title":"ReactNative-Navigator","date":"2016-01-17T15:22:02.000Z","path":"2016/01/17/ReactNative-Navigator/","text":"基本用法Navigator可以切换不同场景，导航器通过路由来分辨不同的场景。renderScene方法用来指定渲染的场景，configureScene属性指定路由对象的配置信息，可以指定进场动画或者手势。 方法 getCurrentRoutes() 获取当前栈里的路由 jumpBack() 跳回之前的路由，当前场景保留 jumpForward() 跳回之后的路由 jumpTo(route) 跳转到已有的场景并且不卸载 push(route) 跳转到新的场景 pop() 跳转出去并且卸载当前场景 replace(route) 用一个新的路由替换掉当前场景 replaceAtIndex(rote,index) 替换掉指定序列的场景 replacePrevious(route) 替换掉之前的场景 immediatelyResetRouteStack(routeStack) 用新的路由重置路由栈 popToRoute(route) pop到路由指定的场景，其他的场景将被卸载 popToTp() pop到栈中单第一个场景，卸载掉所有的其他场景属性 configureScene 可选函数，用来指定场景动画和手势 initialRoute 指定启动时加载的路由 initialRouteStack 指定一个路由集合来初始化 navigatorBar 可选参数，提供一个场景切换时保持的导航栏 navigator 可选参数，提供父类导航获取导航器对象 renderScene 必选参数，用来指定路由渲染的场景 sceneStyle 指定每个场景的容器上的样式","tags":[{"name":"Navigator","slug":"Navigator","permalink":"http://seniorzhai.github.io/tags/Navigator/"},{"name":"路由","slug":"路由","permalink":"http://seniorzhai.github.io/tags/路由/"},{"name":"切换","slug":"切换","permalink":"http://seniorzhai.github.io/tags/切换/"}]},{"title":"AsyncStorage的使用","date":"2016-01-17T13:50:50.000Z","path":"2016/01/17/AsyncStorage的使用/","text":"AsyncStorage是一个Key-Value存储系统，对于App是全局的。 static getItem(key:string,callback?:?(error:?error,result:?string) =&gt; void) 读取key字段，将结果作为参数，传递给callback static setItem(key:string,value:string,callback?:?(error:?Error)=&gt;void) 将key字段的值设置为value,结果调用callback static removeItem(key:string,callback?:?(error:?Error)=&gt;void) 删除一个字段 static mergeItem(key:string,value:string,callback?:?(error:?Error)=&gt;) 假设已有的值和新的值都是字符串的JSON，将两个值合并 static clear(callback?:?(error:?Error)=&gt;void) 删除所有数据 static getAllKeys(callback?:?(error:?Error,keys:?Array)=&gt;void) 获取所有key static flushGetRequests() 清除所有进行中的查询操作 static multiGet(keys:Array,callback?:?(errors: ?Array, result: ?Array","tags":[{"name":"缓存","slug":"缓存","permalink":"http://seniorzhai.github.io/tags/缓存/"},{"name":"持久化","slug":"持久化","permalink":"http://seniorzhai.github.io/tags/持久化/"}]},{"title":"@ViewDebug.ExportedProperty注解","date":"2016-01-12T13:16:27.000Z","path":"2016/01/12/-ViewDebug-ExportedProperty注解/","text":"使用@ViewDebug.ExportedProperty注解，可以在Monitor的Hierarchy Viewer中的调试View属性，可以直接观察注解过的变量和方法的值，实时观察View的状态变化。 使用 category 指定属性的类别，比如measurement,layout,drawing等。 resolveId 当resolveId为true时，变量或方法的值为int数据，那么这个值会被转换成Android对应的资源名称 mapping 可以将int值映射成指定的字符串 indexMapping 可以将数组的序号映射成指定的字符串1234567891011121314151617181920212223242526272829303132333435@ViewDebug.ExportedProperty(category = \"seniorzhai\")int x = 1;@Override@ViewDebug.ExportedProperty(category = \"seniorzhai\")public boolean isFocused() &#123; return true;&#125;@Override@ViewDebug.ExportedProperty(category = \"seniorzhai\")public boolean isFocused() &#123; return true;&#125;@ViewDebug.ExportedProperty(category = \"seniorzhai\",resolveld = true)int b = R.id.no;@Override@ViewDebug.ExportedProperty(category = \"seniorzhai\", mapping = &#123; @ViewDebug.IntToString(from = VISIBLE, to = \"SENIOR_VISIBLE\"), @ViewDebug.IntToString(from = INVISIBLE, to = \"SENIOR_INVISIBLE\"), @ViewDebug.IntToString(from = GONE, to = \"SENIOR_GONE\") &#125;)public int getVisibility() &#123; return super.getVisibility(); &#125;@ViewDebug.ExportedProperty(category = \"seniorzhai\",indexMapping = &#123; @ViewDebug.IntToString(from = 0, to = \"SENIOR_FIRST\"), @ViewDebug.IntToString(from = 1, to = \"SENIOR_SECOND\"), @ViewDebug.IntToString(from = 2, to = \"SENIOR_THIRD\") &#125;)int[] elements = new int[] &#123;123, 223, 323&#125;;","tags":[{"name":"注解","slug":"注解","permalink":"http://seniorzhai.github.io/tags/注解/"}]},{"title":"View的一些重要方法","date":"2016-01-10T08:42:42.000Z","path":"2016/01/10/View的一些重要方法/","text":"onFinishInflate()从XML加载组件后回调 onSizeChanged()组件大小改变时回调 onMeasure()测量大小 onLayout()确定显示位置 onTouchEvent监听触摸事件","tags":[{"name":"自定义","slug":"自定义","permalink":"http://seniorzhai.github.io/tags/自定义/"},{"name":"View","slug":"View","permalink":"http://seniorzhai.github.io/tags/View/"},{"name":"绘制","slug":"绘制","permalink":"http://seniorzhai.github.io/tags/绘制/"}]},{"title":"Xcode上的ActivatePowerMode也来了","date":"2015-12-02T07:10:09.000Z","path":"2015/12/02/Xcode上的ActivatePowerMode也来了/","text":"前天介绍才ActivatePowerMode很快的Xcode上的插件也来了https://github.com/qfish/XActivatePowerMode在Alcatraz搜索安装，Edit-&gt;Activate Power Mode-&gt;Enable运行即可","tags":[{"name":"插件","slug":"插件","permalink":"http://seniorzhai.github.io/tags/插件/"},{"name":"XCode","slug":"XCode","permalink":"http://seniorzhai.github.io/tags/XCode/"}]},{"title":"牛逼到天上的Atom插件","date":"2015-11-30T11:57:02.000Z","path":"2015/11/30/牛逼到天上的Atom插件/","text":"前几天为了学习React Native开始使用Atom，默默的替代了Sublime Text在我Dock上的地位但activate-power-mode的出现让准备彻底走向Atom 注:要使用时用option+control+o开启，插件只能作用在当前Tab页，如果不起效，选择View-&gt;Reload重载页面","tags":[{"name":"插件","slug":"插件","permalink":"http://seniorzhai.github.io/tags/插件/"},{"name":"Atom","slug":"Atom","permalink":"http://seniorzhai.github.io/tags/Atom/"}]},{"title":"ReactNative-样式","date":"2015-11-24T11:57:26.000Z","path":"2015/11/24/ReactNative-样式/","text":"声明123456789var styles = StyleSheet.create(&#123; base: &#123; width:38, height:38, &#125;, background:&#123; backgroundColor:\"# 222222\", &#125;,&#125;) 使用123&lt;Text style=&#123;styles.base&#125; /&gt;&lt;View style=&#123;styles.background&#125; /&gt;&lt;View style=&#123;[styles.base,style.background]&#125; /&gt; //可以接受多个style属性","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"样式","slug":"样式","permalink":"http://seniorzhai.github.io/tags/样式/"},{"name":"Style","slug":"Style","permalink":"http://seniorzhai.github.io/tags/Style/"}]},{"title":"ReactNative-真机运行","date":"2015-11-12T06:57:26.000Z","path":"2015/11/12/ReactNative-第一个项目/","text":"iOS 在项目中运行Debug Server 根据电脑的IP，修改AppDelegate.m中的jsCodeLocation的host改为电脑的IP 或者使用jsCodeLocation = [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;] Android Android 5.0以上机型使用adb reverse tcp:8081 tcp:8081反向代理到Mac上 Android 5.0以下选择菜单中Dev Setting &gt; Debug Service host for device选择Mac的IP 使用react-native run-android启动应用 或者启动Debug Server(react-native start) 使用Android Studio进行调试","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"第一个项目","slug":"第一个项目","permalink":"http://seniorzhai.github.io/tags/第一个项目/"}]},{"title":"Android Studio上的NDK开发","date":"2015-10-14T03:51:41.000Z","path":"2015/10/14/Android-Studio上的NDK开发/","text":"在AndroidStudio全面支持NDK开发前，使用的方法大概是这样的http://seniorzhai.github.io/2015/03/19/AndroidStudio%E4%B8%8A%E4%BD%BF%E7%94%A8NDK/在AS 1.3版本后，NDK终于可以在AndroidStudio正式支持了，不过还在实验阶段，后续可能还会有些许不同，但至少能管中窥豹了。 环境 Android Studio 1.3+ Gradle 2.5 NDK r10e Build Tools 19.0.0+ 修改配置文件 gradle/wrapper/gradle-wrapper.properties，修改distributionUrl使用Gradle2.5 1distributionUrl=https\\://services.gradle.org/distributions/gradle-2.5-all.zip build.gradle，使用gradle-experimental替代gradle 1classpath &apos;com.android.tools.build:gradle-experimental:0.2.0&apos; app/build.gradle，新版的Gradle语法有很大的改变，最外层为model，赋值使用=，新增项使用+=（具体可以在这儿查看） 创建JNI 创建JNI的目录 定义JNI Java类，使用javah生产头文件 编写c文件详情见https://github.com/SeniorZhai/AS_NDK/commit/81ea7c1285e1a0ca61c79f035b3af01bff14ab11","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"ndk","slug":"ndk","permalink":"http://seniorzhai.github.io/tags/ndk/"}]},{"title":"SD的种类","date":"2015-10-04T11:10:56.000Z","path":"2015/10/04/SD的种类/","text":"SD卡的种类SD卡包括SD、SDHC和SDXC卡，这三种卡的区别在存储容量：SD卡≤2GB，SDHC卡4-32GB，SDXC卡式64-2048GB。SD卡的版本是向下兼容的，比如支持SDXC卡的相机，也支持SD卡和SDHC卡。值得注意的是SDXC存储卡由于采用了恶心FAT格式，WinXP SP2或者更低版本系统式无法识别的 存储卡的速度SD卡上通常会标注速度，有倍速(如300X)或者是+MB/s两种表示方式。1倍速=150KB/s=0.15MB/s(存储算法，不是理论算法)，所以300X是45MB/s，600X是90MB/s如果卡面上只标注倍速或一个数字，那么一般都是读取速度。写入速度影响了拍摄间隔时间、持续连拍张数、视频记录的最高格式，读取速度则会影响回放、传输速度。一般情况存储设备的写入速度都要低于读取速度。SD卡有速度等级(Class)、高速等级(UHS Class)两个评价等级，可以辅助判断SD卡的速度。 Class 6代表了最低写入速度6M/s；Class 10表示最低写入速度10MB/s UHS-Ⅰ Class 1表示最低写入速度是10MB/s；UHS-Ⅰ Class 3表示最低写入速度是30MB/sClass 10和UHS-Class 1都表示存储卡的最低写入速度是10MB/s，那么它们又有事吗区别呢？非UHS存储卡的理论最高速度只有25MB/s，而UHS-I存储卡则能达到104MB/s。即使两张卡的写入速度相同，UHS-I存储卡的读取速度通常也会更高一些。","tags":[{"name":"SD卡","slug":"SD卡","permalink":"http://seniorzhai.github.io/tags/SD卡/"}]},{"title":"ReactNative-如何开始","date":"2015-09-24T09:00:31.000Z","path":"2015/09/24/ReactNative-如何开始/","text":"基本环境 Mac OS X Node.js 4.0 Xcode 6.3以上版本 Android SDK watchman和flow安装1npm install -g react-native-cli 初始化1react-native init AwesomeProject 开发环境配置 iOS XCode6.3及以上即可 Android 环境变量ANDROID_HOME SDK Manager Android SDK Build-tools version 23.0.1 Android 6.0(API 23) Android Support Repository 运行 iOS在Xcode中打开工程，直接运行即可 Android在./android/目录下新建local.properties文件把SDK的路径保存在其中1sdk.dir=.../Android/sdk 执行命令1react-native run-android https://github.com/SeniorZhai/ReactNative_Demo","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"React","slug":"React","permalink":"http://seniorzhai.github.io/tags/React/"},{"name":"开始","slug":"开始","permalink":"http://seniorzhai.github.io/tags/开始/"}]},{"title":"判断iOS设备种类","date":"2015-09-04T13:35:43.000Z","path":"2015/09/04/判断iOS设备种类/","text":"UIDevice的静态方法currentDevice可以获取到设备信息(UIUserInterfaceIdiom枚举类型)，包括Phone、Pad、Unspecifid其中Phone为手机设备、Pad为平板设备、Unspecifid为未知设备 各类栏的尺寸状态栏的高度为20PX，NavigationBar为44PX，底栏为49PX","tags":[{"name":"swift","slug":"swift","permalink":"http://seniorzhai.github.io/tags/swift/"}]},{"title":"Android、iOS大不同(八)-新的开始","date":"2015-09-01T12:30:16.000Z","path":"2015/09/01/Android、iOS大不同-八-新的开始/","text":"离上一篇大不同的文章都快一年了，这一年Swift渐渐成为主流，Android Studio也成为了主力IDE，可以说Android、iOS的技术都在日新月异的变化。最近准备整理下这些知识，Android、iOS大不同系列也正式重启啦。 Android Studio自从Android Studio的第一个正式版发布后，我就将AS“提拔”为主力Android开发工具。虽然开始时，会有很多不习惯，但是只要几天的适应后，你就会有再也回不去的感觉，丰富的插件、强大的Gradle、准确的预览等优点，不禁让我呐喊Android终于TMD有自己的IDE了。相比Eclipse，Android Studio确实有一些门槛和学习曲线，除了目录结构的变化和快捷键的不同，Gradle应该是很多人的瓶颈。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Swift版Masonry-SnapKit布局框架","date":"2015-08-26T15:00:38.000Z","path":"2015/08/26/Swift版Masonry-SnapKit布局框架/","text":"和Masonry一样，SnapKit是一套轻量级的布局框架，同样适用链式语法封装Apple的自动布局约束。 导入1234platform :ios, &apos;7.0&apos;use_frameworks!pod &apos;SnapKit&apos;, &apos;~&gt; 0.12.0&apos; 约束对应的属性 ViewAttribute NSLayoutAttriubute 说明 view.snp_left NSLayoutAttributeLeft 左侧 view.snp_top NSLayoutAttributeTop 上侧 view.snp_right NSLayoutAttributeRight 右侧 view.snp_bottom NSLayoutAttributeBottom 下侧 view.snp_leading NSLayoutAttributeLeading 首部 view.snp_trailing NSLayoutAttributeTrailing 尾部 view.snp_width NSLayoutAttributeWith 宽 view.snp_height NSLayoutAttributeHeight 高 view.snp_centerX NSLyoutAttributeCenterX 横向中点 view.snp_centerY NSLyoutAttributteCenterY 纵向中点 view.snp_baseline NSLayoutAttributeBaseline 文本基准线 居中123456let view1 = UIView() view1.backgroundColor = getColor(0x6FBFAC) view.addSubview(view1) view1.snp_makeConstraints&#123;(make)-&gt;Void in make.edges.equalTo(view).insets(UIEdgeInsetsMake(20, 20, 20, 20)) &#125; 等宽12345678910111213141516171819202122232425let view2 = UIView()let view3 = UIView() view2.backgroundColor = getColor(0xE5395F)view3.backgroundColor = getColor(0x402516) view1.addSubview(view2)view1.addSubview(view3)view1.addSubview(view4)view2.snp_makeConstraints&#123;(make)-&gt;Void in make.top.equalTo(view1.snp_top).offset(20) make.width.equalTo(view3) make.left.equalTo(view1.snp_left).offset(20) make.right.equalTo(view3.snp_left).offset(-20) make.height.equalTo(200)&#125; view3.snp_makeConstraints&#123;(make)-&gt;Void in make.top.equalTo(view1.snp_top).offset(20) make.width.equalTo(view2) make.right.equalTo(view1.snp_right).offset(-20) make.left.equalTo(view2.snp_right).offset(-20) make.height.equalTo(200)&#125; 相对在下123456view4.snp_makeConstraints&#123;(make)-&gt;Void in make.width.equalTo(view1).offset(-40) make.centerX.equalTo(view.snp_centerX) make.top.equalTo(view2.snp_bottom).offset(20) make.bottom.equalTo(view1.snp_bottom).offset(-20)&#125; 在使用自动布局的时候只要记住View需要大小、间隔、位置(中心点、X、Y)常见的布局都可以完成例子可以在https://github.com/SeniorZhai/SnapDemo看到更多用法可以参考文档","tags":[]},{"title":"Data Binding（二）","date":"2015-08-16T06:00:11.000Z","path":"2015/08/16/Data-Binding（二）/","text":"在Fargment中使用1234567&lt;layout&gt; &lt;date&gt; &lt;variable name=\"user\" type=\"io.github.seniorzhai.databindingdemo.model.PlainUser\" /&gt; &lt;/date&gt;&lt;/layout&gt; 在Fragment.java中123456789onCreateView() &#123; ItemGridBinding binding = DataBindingUtil.inflate(inflater, R.layout.item_grid, container, false); PlainUser user = new PlainUser(); user.name.set(\"SBBBBBBBB\"); user.age.set(111); binding.setUser(user); binding.getRoot().setBackgroundColor(RandomColor.getColor()); return binding.getRoot();&#125; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/java/io/github/seniorzhai/databindingdemo/BingdingFragment.java 在GridView中使用主要的实现代码需要在Adapter的getView方法中实现1234567891011public View getView(int position,View convertView,ViewGroup parent) &#123; if (convertView == null) &#123; binding = DataBindingUtil.inflate(inflater,R.layout.item_grid,parent,false); convertView = binding.getRoot(); convertView.setTag(binding); &#125; else &#123; binding = convertView.getTag(); &#125; binding.setVariable(BR.user,getItem(position)); return converView;&#125; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/java/io/github/seniorzhai/databindingdemo/MyAdapter.java","tags":[{"name":"KVO","slug":"KVO","permalink":"http://seniorzhai.github.io/tags/KVO/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://seniorzhai.github.io/tags/数据绑定/"},{"name":"MVVM","slug":"MVVM","permalink":"http://seniorzhai.github.io/tags/MVVM/"}]},{"title":"常用的Gradle命令","date":"2015-08-16T03:44:16.000Z","path":"2015/08/16/常用的Gradle命令/","text":"在Android Studio的Android项目中，都会有一个gradlew文件，代表gradle wrapper在使用命令编译时，也使用./gradlew，使用本地的配置和环境编译 常用的Gradle命令 ./gradlew -v 版本号 ./gradlew clean 清除build文件夹 ./gradlew build 检查依赖并打包 ./gradlew assembleDebug 编译打包Debug包 ./gradlew assembleRelease 编译打包Release包 ./gradlew installRelease 打包并安装Release包 ./gradlew unstallRelease 卸载Release包","tags":[{"name":"gradle","slug":"gradle","permalink":"http://seniorzhai.github.io/tags/gradle/"},{"name":"gradlew","slug":"gradlew","permalink":"http://seniorzhai.github.io/tags/gradlew/"}]},{"title":"Data Binding（一）","date":"2015-08-16T01:20:21.000Z","path":"2015/08/16/Data-Binding（一）/","text":"在iOS有个概念叫KVO，它提供一致机制，当制定对象的属性被修改时，会发出一条通知。这样每次被观察的对象的属性被修改后，KVO就会自动通知响应的观察者。Google推出的Data Binding也可以帮我们实现这一点。Binding是Google提供的一个Support库，最低可以支持到Android 2.1(API 7+)。 环境：Android Studio 1.3-beta1 以上版本 有了Data Binding，我们就可以使用使用MVVM模式构建我们的APP了。在Android的传统模式(MVC)下，Model一般是Json数据，V就是我们的Layout文件生成的View，C作为核心的控制器，一般由Activity、Fragment出任。当时这个模式下，C的责任比较大，所以逻辑最复杂，代码量也最多(而且还有很大部分的findViewById)。在MVVM模式下，解决了Android UI编程的一大痛点，只要建立好MVVM之间的联系，我们可以减少很大一部分的setText()、getValue()之类的代码。 构建环境在项目的gradle文件中添加1234denpendcies &#123; classpath &quot;com.android.tools.build:gradle:1.3.0&quot; classpath &quot;com.android.databinding:dataBinder:1.0rc1&quot;&quot;&#125; 同时确保jcenter在repostiories列表里12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; 在module的gradle文件中添加插件12apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.android.databinding&apos; 基本概念在基本的使用下，M依旧是Json为主的Java Bean对象，V还是XML为主的Layout布局，但是承当的责任会更多，VM作为中间的桥梁需要建立他们的联系，同时完成自己的本质工作(Acticity和Fragment等) 静态数据首先完成Model的定义1234567891011121314151617public class User &#123; public String name; public int age; public StaticUser(String name, int age) &#123; this.name = name; this.age = age; &#125; public boolean isAudlt ()&#123; return this.age &gt;=18; &#125; public String getName() &#123; return this.name; &#125;&#125; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/java/io/github/seniorzhai/databindingdemo/model/StaticUser.java然后创建View，使用Data Binding，布局的跟标签为layout12345678910111213141516171819202122232425262728293031&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 定义数据 --&gt; &lt;data&gt; &lt;!-- 导入View类 --&gt; &lt;import type=\"android.view.View\" /&gt; &lt;!-- 导入StaticUser类 --&gt; &lt;variable name=\"user\" type=\"io.github.seniorzhai.databindingdemo.model.StaticUser\" /&gt; &lt;/data&gt; &lt;!-- 布局 --&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;user.getName()&#125;\" /&gt; &lt;!-- 默认无需导入java.lang包 --&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@&#123;String.format(`Age : %d`,user.age)&#125;\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"Adult\" android:visibility=\"@&#123;user.isAudlt ? View.VISIBLE : View.GONE&#125;\" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/res/layout/activity_static.xml最后在Activity中建立联系123456789StaticUser user;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 默认情况下Data Binding插件会根据layout文件的名称产生Binding类 ActivityStaticBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_static); user = new StaticUser(\"SeniorZhai\", 24); binding.setUser(user); &#125; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/java/io/github/seniorzhai/databindingdemo/StaticActivity.java 动态数据首先需要完成我们的Model，这时候Model需要继承BaseObservable，并且通过制定一个Bindable注解给getter以及setter内通知实现属性改变时发出通知。12345678910111213public class ObservableUser extends BaseObservable &#123; public String name; @Bindable public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; notifyPropertyChanged(BR.name); &#125;&#125; 在XML中12345&lt;data&gt; &lt;variable name=\"user\" type=\"io.github.seniorzhai.databindingdemo.model.ObservableUser\" /&gt;&lt;/data&gt; https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/res/layout/activity_observale.xml最后在Activity中添加代码，建立联系12ActivityObservaleBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_observale);binding.setUser(user); https://github.com/SeniorZhai/DataBindingDemo/blob/master/app/src/main/java/io/github/seniorzhai/databindingdemo/ObservaleActivity.java","tags":[{"name":"KVO","slug":"KVO","permalink":"http://seniorzhai.github.io/tags/KVO/"},{"name":"数据绑定","slug":"数据绑定","permalink":"http://seniorzhai.github.io/tags/数据绑定/"},{"name":"MVVM","slug":"MVVM","permalink":"http://seniorzhai.github.io/tags/MVVM/"}]},{"title":"Android Lint工具","date":"2015-08-12T09:51:04.000Z","path":"2015/08/12/Android-Lint工具/","text":"Android Lint是SDK Tools 16(ADT 16)之后Google提供的新工具，它是一个代码扫描工具，能够帮助我们识别代码结构存在的问题，比如： 无效布局，多重嵌套等 未使用的冗余资源文件 国际化的问题(未翻译的文本) 数组资源大小不一致 图标缺失、重复、错误尺寸 AndroidManifest.xml中的错误 LintLint工具在/AndroidSDK/tools/文件夹下 使用 lint &lt;project directory&gt; lint命令后添加工程目录 lint --html &lt;project directory&gt; 生成html格式的报告 lint --simplehtml &lt;project directory&gt; 生成简单html格式的报告 lint --xml &lt;project directory&gt; 生成xml格式的报告 lint --check &quot;UnusedResources&quot; &lt;project directory&gt; 清理冗余资源文件 lint --show可获得详细问题列表 AdapterViewChildren 确保没有在XML文件中定义它的子view OnClick 确保XML文件声明的OnClick的调用函数在代码中实际存在 SuspiciousImport 可疑import的检查 UsesMinSdkAttributes 检查是否在AndroidManifest.xml文件中定义了minimum SDK 和 target SDK这两个属性 WrongViewCast View强转换的检查 MissingRegistered 检查manifest文件中声明的类实际是否存在于工程或工程的libraries中 NamespaceTypo 命名空间拼写检查 Proguard 混淆配置检查 ScrollViewCount 检查ScrollViews是否只有一个child ……","tags":[{"name":"Lint","slug":"Lint","permalink":"http://seniorzhai.github.io/tags/Lint/"}]},{"title":"自定义属性汇总","date":"2015-08-10T06:45:43.000Z","path":"2015/08/10/自定义属性汇总/","text":"自定义属性类型1.reference 资源类型1&lt;attr name=\"backimg\" format=\"reference\"/&gt; 2.color 颜色类型1&lt;attr name=\"textColor\" format=\"color\" /&gt; 3.boolean 布尔类型1&lt;attr name=\"focusable\" format=\"boolean\" /&gt; 4.dimension 尺寸类型1&lt;attr name=\"layout_width\" format=\"dimension\" /&gt; 5.float 浮点类类型1&lt;attr name=\"toAlpha\" format=\"float\"/&gt; 6.integer 整数类型1&lt;attr name=\"visible\" format=\"integer\" /&gt; 7.string 字符串类型1&lt;attr name=\"key\" format=\"string\" /&gt; 8.fraction 百分比类型1&lt;attr name=\"pivotX\" format=\"fraction\" /&gt; 9.enum 枚举类型1234&lt;attr name=\"orientation\"&gt; &lt;enum name=\"horizontal\" value=\"0\" /&gt; &lt;enum name=\"vertical\" value=\"1\" /&gt;&lt;/attr&gt; 10.flag 标记类型(可以与或运算)1234&lt;attr name=\"mode\"&gt; &lt;flag name=\"stateVisible\" value=\"0x01\"&gt; &lt;flag name=\"statePan\" value=\"0x10\"&gt;&lt;/attr&gt; 注意属性可以同时指定多个类型值1&lt;attr name=\"background\" format=\"referce|color\" /&gt;","tags":[{"name":"属性","slug":"属性","permalink":"http://seniorzhai.github.io/tags/属性/"}]},{"title":"Swift闭包表达式","date":"2015-08-09T15:05:13.000Z","path":"2015/08/09/Swift闭包表达式/","text":"闭包(closure)包含了可执行程序(跟方法主体(statements)类似)以及接收(capture)的参数，格式如下123&#123;(parameters) -&gt; return type in statements&#125; 闭包可以省略参数的类型和返回值的类型，如果省略了参数类型也要省略in关键字 闭包省略参数，可以使用$0,$1,$2……来引用出现的第一个、第二个、得三个……参数 如果闭包只包含一个表达式，那么表达式就会自动成为该闭包的返回值12345678910111213func1 &#123; (x:Int,y:Int) -&gt; Int in return x + y&#125;func2 &#123; (x,y) in return x + y&#125;func3 &#123;return $0 + $1&#125;func4 &#123; $0 + $1 &#125;","tags":[{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"},{"name":"闭包","slug":"闭包","permalink":"http://seniorzhai.github.io/tags/闭包/"},{"name":"lambda","slug":"lambda","permalink":"http://seniorzhai.github.io/tags/lambda/"}]},{"title":"Android反编译——Mac篇","date":"2015-08-06T05:12:52.000Z","path":"2015/08/06/Android反编译——Mac篇/","text":"目前Mac上流行的Android反编译工具有两款，分别是Jadx和AndroidDecompiler JadxJadx是一款跨平台的反编译工具，有GUI界面 使用方法 下载Jadx 运行bin/jadx-gui，选择APK文件 可以看到Java源码，选择File-&gt;Save ALL即可保存文件 AndroidDecompilerAndroidDecompiler是一款命令行工具 使用方法 下载AndroidDecompiler 切换到它的目录下，执行decompileAPK.sh脚本 1decompileAPK.sh -p xxx.apk 在当前目录下的output文件夹就是反编译之后的文件","tags":[{"name":"Mac","slug":"Mac","permalink":"http://seniorzhai.github.io/tags/Mac/"},{"name":"反编译","slug":"反编译","permalink":"http://seniorzhai.github.io/tags/反编译/"},{"name":"OSX","slug":"OSX","permalink":"http://seniorzhai.github.io/tags/OSX/"},{"name":"APK","slug":"APK","permalink":"http://seniorzhai.github.io/tags/APK/"}]},{"title":"获取NavBar高度的方法","date":"2015-08-05T13:27:04.000Z","path":"2015/08/05/获取NavBar高度的方法/","text":"判断是否存在虚拟键1234567891011121314151617181920212223242526272829303132private final static String SHOW_NAV_BAR_RES_NAME = \"config_showNavigationBar\";public String getNavBarOverride() &#123; if (Build.VERSION&gt;SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); try &#123; // 相当于SystemProperties.get Class c = Class.forName(\"android.os.SystemProperties\"); Method m = c.getDeclaredMethod(\"get\",String.class); m.setAccessible(true); return (String)m.invoke(null,\"qemu.hw.mainkeys\"); &#125; catch (Throwable e) &#123; return null; &#125; &#125; &#125;@TargetApi(14)private boolean hasNavBar(Context context) &#123; Resources res = context.getResources(); // resources.getIdenttifier() 方法可以获取指定报名下的资源文件ID，后两个参数表示资源类型和默认报名 int resourceId = res.getIdentifier(SHOW_NAV_BAR_RES_NAME,\"bool\",\"android\"); if(resourceId != 0)&#123; if (\"1\".equals(getNavBarOverride())) &#123; hasNav = false; &#125; else if (\"0\".equals(getNavBarOverride())) &#123; hasNav = true; &#125; return hasNav; &#125; else &#123; return !ViewConfiguration.get(context).hasPermanentMenuKey(); &#125;&#125; 获取虚拟键的高度12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int getNavigationBarHeight(Context context) &#123; Resources res = context.getResources(); int result = 0; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; if (hasNavBar(context)) &#123; String key; if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) &#123; key = NAV_BAR_HEIGHT_RES_NAME; &#125; else &#123; if (!isNavigationAtBottom()) return 0; key = NAV_BAR_HEIGHT_LANDSCAPE_RES_NAME; &#125; return getInternalDimensionSize(res,key); &#125; &#125; return result;&#125;private int getInternalDimensionSize(Resources res, String key) &#123; int result = 0; int resourceId = res.getIdentifier(key, \"dimen\", \"android\"); if (resourceId &gt; 0) &#123; result = res.getDimensionPixelSize(resourceId); &#125; return result;&#125;private boolean isNavigationAtBottom() &#123; WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); float mSmallestWidthDp = getSmallestWidthDp(wm); return (mSmallestWidthDp &gt;= 600 || mInPortrait);&#125;private float getSmallestWidthDp(WindowManager wm) &#123; DisplayMetrics metrics = new DisplayMetrics(); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN) &#123; wm.getDefaultDisplay().getRealMetrics(metrics); &#125; else &#123; //this is not correct, but we don't really care pre-kitkat wm.getDefaultDisplay().getMetrics(metrics); &#125; float widthDp = metrics.widthPixels / metrics.density; float heightDp = metrics.heightPixels / metrics.density; return Math.min(widthDp, heightDp);&#125;","tags":[{"name":"NavBar","slug":"NavBar","permalink":"http://seniorzhai.github.io/tags/NavBar/"},{"name":"虚拟键","slug":"虚拟键","permalink":"http://seniorzhai.github.io/tags/虚拟键/"},{"name":"NavtigationBar","slug":"NavtigationBar","permalink":"http://seniorzhai.github.io/tags/NavtigationBar/"}]},{"title":"PreferenceActivity的使用","date":"2015-08-04T10:56:37.000Z","path":"2015/08/04/PreferenceActivity的使用/","text":"PreferenceScreen 设置页面，可嵌套二级设置页面 PreferenceCategory 设置类，可用Title参数设置标题 CheckBoxPreference 可选设置，可用Title设置标题，用summaryOn和summaryOff参数设置控件选中和未选中时的提示，可用defaultValue设置缺省值 ListPreference 下拉框选择设置，可用Title设置标题，用Summary参数设置说明，点击出现下拉框，用dialogTitle设置下拉框的标题，entries和entryValues分别表示显示的值和代码中获取的真正的值 EditTextPreference 输入框设置，点击输入字符串设置，用Title参数设置标题，Summary参数设置说明，dialogTitle参数设置输入框的标题 RingtonePreference 铃声选择设置，点击后可选择系统铃声，用Title参数设置标题，Summary参数设置说明，dialogTitle参数设置铃声选择的标题","tags":[{"name":"PerferenceScreencreen","slug":"PerferenceScreencreen","permalink":"http://seniorzhai.github.io/tags/PerferenceScreencreen/"}]},{"title":"Android Support Annotations","date":"2015-08-03T12:05:45.000Z","path":"2015/08/03/Android-Support-Annotations/","text":"Android Support Library 19.1版本中加入了几个好用的注解通过gradle导入工程中1compile &apos;com.android.support:support-annotations:22.2.0&apos; 有以下三种注解： Nullness注解 资源类型注解 IntDef和StringDef注解 Nullness注解 使用@NonNull注解修饰的参数不能为null 12345void say(@NonNull String s)&#123; // ...&#125;say(null); // 在IDE中，这行代码会提示警告 使用@Nullable注解修饰的函数参数或者返回值可以为null 1234@NullableString getName(@NonNull String str)&#123; return str;&#125; 资源类型注解 使用@StringRes注解表示函数期望接受一个字符串类型的id，而不是一个普通的int123void show(@StringRes int id) &#123; getResources().getString(id); &#125; 同理可用的注解还有AnimatorRes,AnimRes,ArrayRes,ColorRes,DimenRes,DrawableRes,IdRes,StyleRes IntDef和StringDef注解很多时候我们用枚举类型来控制一些模式这个时候可以使用@IntDef来代替12345678910public static final int VANILLA = 0;public static final int CHOCOLATE = 1;@InDef(&#123;VANILLA,CHOCOLATE&#125;)public @interface Flavour&#123;&#125;// 使用@Flavour自定义注解，表示它可以接受的值的类型public void setFlavour(@Flavour int flavour) &#123; &#125;","tags":[]},{"title":"手动导入本地support包","date":"2015-07-17T02:26:59.000Z","path":"2015/07/17/手动导入本地support包/","text":"不知道有多少人和我一样使用support的时候，会去查下compile命令（没有补全，每次都记不住）其实AS早就有导入的方法了 步骤右击项目选中Open Module Settings选中你的Module(示例为app)，选中Dependencies在左下角点击+号在新的弹出框中找到你需要添加的包","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"support","slug":"support","permalink":"http://seniorzhai.github.io/tags/support/"}]},{"title":"JavaSpcript-strict","date":"2015-07-14T07:30:22.000Z","path":"2015/07/14/JavaSpcript-strict/","text":"JavaScript在设计之初不强制变量需要var申明不使用var申明的变量，会变成全局变量为了修补JavaScript这一严重的设计缺陷，ECMA在后续的规范中退出了srict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用，会导致运行错误启用strict模式的方法就是在JS代码的第一行写上1'use strict';","tags":[{"name":"设计缺陷","slug":"设计缺陷","permalink":"http://seniorzhai.github.io/tags/设计缺陷/"}]},{"title":"Android引导功能的实现","date":"2015-07-13T08:04:29.000Z","path":"2015/07/13/Android引导功能的实现/","text":"TourGuide是一个能够实现Android View上引导动画的库 引入在gradle文件中123456789repositories &#123; mavenCentral() maven()&#123; url &quot;https://oss.sonatype.org/content/repositories/snapshots&quot; &#125;&#125;compile (&apos;com.github.worker8:tourguide:1.0.10-SNAPSHOT@aar&apos;)&#123; transitive=true&#125; 注：SDK支持到Android 3.0.x(API 11) 使用12345TourGuide mTourGuideHandler = TourGuide,init(this).with(TourGuide,Technique,Click) .setPointer(new Pointer()) .setToolTip(new ToolTip().setTitle(\"Welcome!\").setDescription(\"Get Started to begin...\")) .setOverlay(new Overlay()) .playOn(button); setPoninter 自定义提示的样式 seToolTip 设置提示标题 setOverlay","tags":[{"name":"引导","slug":"引导","permalink":"http://seniorzhai.github.io/tags/引导/"}]},{"title":"魅族手机连接Mac的问题","date":"2015-06-24T06:12:55.000Z","path":"2015/06/24/魅族手机连接Mac的问题/","text":"部分三星、魅族的手机，连接Mac时，执行adb devices不能发现设备 解决方法 打开系统信息，在USB中找到手机，然后查找厂商ID 在~/.android/adb_usb.ini文件中添加厂商ID 执行adb kill-server和adb start-server重启ADB","tags":[{"name":"Mac","slug":"Mac","permalink":"http://seniorzhai.github.io/tags/Mac/"},{"name":"魅族","slug":"魅族","permalink":"http://seniorzhai.github.io/tags/魅族/"},{"name":"连接","slug":"连接","permalink":"http://seniorzhai.github.io/tags/连接/"}]},{"title":"红杏公益代理——妈妈再也不用当心我翻不了墙了","date":"2015-06-19T10:20:17.000Z","path":"2015/06/19/红杏公益代理——妈妈再也不用当心我翻不了墙了/","text":"虽然我不是红杏的用户（因为我们公司有翻墙路由我会乱说），但是红杏应该有很多人在使用。最近红杏开放了一个公益代理，专门为开发者开放。从今以后更新Android SDK，使用Android Studio就可以飞起来啦。网络再也不是借口和障碍了。 使用 github加速1git config --global http.proxy http://hx.gy:1080 如果要移除，编译~/.gitconfig 命令行更新Android SDK 1./android list sdk -u --proxy-host=hx.gy --proxy-port=1080 Android SDK Manager加速打开SDK Manager的设置 给Android Studio配置，加速gradle打开Preference页面，找到HTTP Proxy","tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://seniorzhai.github.io/tags/翻墙/"},{"name":"妈妈再也不用担心系列","slug":"妈妈再也不用担心系列","permalink":"http://seniorzhai.github.io/tags/妈妈再也不用担心系列/"}]},{"title":"RecyclerView多Item的情况","date":"2015-06-19T03:38:56.000Z","path":"2015/06/19/RecyclerView多Item的情况/","text":"如果你在ListView中实现过多Item功能时，那么你一个不会对下面的方法不陌生123456789@Overridepublic int getItemViewType(int postion)&#123; return super.getItemViewType(postion);&#125;@Overridepublic int getViewTypeCount()&#123; return super.getViewTypeCount();&#125; 其中getItemViewType用来返回当前项是哪种类型布局，getViewTypeCount返回当前ListView总共多少种类型的布局 如果在RecyclerView实现多种Item，只需要实现一个getItemType方法，用来返回item的种类在onCreateViewHolder和onBindViewHolder方法中，第二个参数就是item的类型123456789101112131415161718192021222324252627282930public class MultipeItemAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; &#123; public static enum ITEM_TYPE &#123; ITEM_TYPE_IMAGE, ITEM_TYPE_TEXT &#125; @Override public RecylerView.ViewHolder onCreateViewHolder(ViewGroup parent,int viewType)&#123; if (viewType == ITEM_TYPE.ITEM_TYPE_IMAGE.ordinal()) &#123; return new ImageViewHolder(); &#125; else &#123; return new TextViewHolder(); &#125; &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; if (holder instanceof TextViewHolder) &#123; ((TextViewHolder) holder).mTextView.setText(mTitles[position]); &#125; else if (holder instanceof ImageViewHolder) &#123; ((ImageViewHolder) holder).mTextView.setText(mTitles[position]); &#125; &#125; @Override public int getItemViewType(int position) &#123; return position % 2 == 0 ? ITEM_TYPE.ITEM_TYPE_IMAGE.ordinal() : ITEM_TYPE.ITEM_TYPE_TEXT.ordinal(); &#125; @Override public int getItemCount() &#123; return mTitles == null ? 0 : mTitles.length; &#125;&#125;","tags":[{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://seniorzhai.github.io/tags/RecyclerView/"}]},{"title":"[转]Android 手机屏幕录制并制作成 GIF 演示图片","date":"2015-06-16T08:41:03.000Z","path":"2015/06/16/-转-Android-手机屏幕录制并制作成-GIF-演示图片/","text":"声明本教程，也不应该叫做教程，反正就是毫无技术；只能说是纯手工打造，当然需要完成该教程还是需要你动动手指才行滴~~话说主要是前3天连续写了3天长文章的博客，一章比一章用心，最后一章写到了昨晚1：30才写好；汗~真的是Hold 不住了；今天就来一个轻松一点儿的吧~~为什么？自己想分享手机屏幕短片给朋友看看怎么办？想给你的软件做一个展示GIF怎么办？不知道还有没有其他原因；我就这么两个了~~ 开工这个就来一个3部曲吧，走起！！！ 录制前提：手机版本》=4.0；电脑有 adb现在手机用数据线连接你的电脑，就是两边都用USB插上~~电脑 CMD 命令输入：adb shell screenrecord /sdcard/movie.mp4如果显示如上面所示则进入了录制了~~然后动动你的手指在手机上操作操作12345678910111213141516171819202122232425在录像过程中，`可以随时按下Ctrl+C快捷键终止录制操作`。此时进入你的手机文件中，查看SD卡根目录是不是多了一个`movie.mp4`；现在把该文件拷贝到你的电脑上~~注意：1. 只能使用adb命令2. 最长时常180秒3. 没有同步声音## 导入PS前提：PS 软件一枚打开PS：文件-导入-视频帧到图层![](http://img.blog.csdn.net/20150107234525981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWl1anVlcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)等待一回儿，具体多久看自个电脑了，然后会弹出选择视频文件，此时选择我们的 movie.mp4 文件选择后，我们可以微调一下开始时间和结束时间，另外可以调整一下转换后的图片密度，最后确认。![](http://img.blog.csdn.net/20150107234912041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWl1anVlcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)切换窗口模式：窗口-工作区-动感![](http://img.blog.csdn.net/20150107235122343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWl1anVlcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)然后自己调整 调整 你的时间速度。导出GIF调整好了，现在就保存为GIF吧。点击：文件-存储为Web所用格式...选择类型：GIF 类型![](http://img.blog.csdn.net/20150107235555006?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWl1anVlcg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)为了让你的文件更小，你可以在进入前调整图片的整体大小；同时可以调整其中的颜色与仿色值。最后点击 存储 吧~ 注意：如果你的视频的像素较高，那么在PS中可能会占用大量内存，这个要有心理准备啊~~ 成果 总的来说教程较为简单，今天早上起来看的时候恰好看见有人问怎么截图的，这个就巧了哈哈~","tags":[{"name":"录屏","slug":"录屏","permalink":"http://seniorzhai.github.io/tags/录屏/"}]},{"title":"Android M meterial 控件 - Snackbar","date":"2015-06-04T10:23:32.000Z","path":"2015/06/04/Android-M-meterial-控件-Snackbar/","text":"Android M发布的Android Design Support Library提供了很多Material Design控件，支持Android 2.1及以后的版本。再也不用担心第三方的Material Design不可靠了。 SnackbarSnackbar类型于Toast用作轻量级的操作反馈，与Crouton相似(Snackbar显示在父视图的底部)，但是功能要简单的多。 关于Crouton可以查看http://seniorzhai.github.io/2014/12/15/Crouton%E7%9A%84%E4%BD%BF%E7%94%A8/1234Snackbar .make(parentLayout, R.string.snackbar_text, Snackbar.LENGTH_LONG) // 显示的文本及显示的位置 .setAction(R.string.snackbar_action, myOnClickListener) // 自定义点击时间 .show(); https://github.com/SeniorZhai/SnackbarDemo","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Meterial","slug":"Meterial","permalink":"http://seniorzhai.github.io/tags/Meterial/"}]},{"title":"布局属性汇总","date":"2015-05-29T07:47:59.000Z","path":"2015/05/29/布局属性汇总/","text":"第一类：属性值 true或者 false 属性 说明 android:layout_centerHrizontal 水平居中 android:layout_centerVertical 垂直居中 android:layout_centerInparent 相对于父元素完全居中 android:layout_alignParentBottom 贴紧父元素的下边缘 android:layout_alignParentLeft 贴紧父元素的左边缘 android:layout_alignParentRight 贴紧父元素的右边缘 android:layout_alignParentTop 贴紧父元素的上边缘 android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物 android:layout_alignParentStart 紧贴父元素结束位置开始 android:layout_alignParentEnd 紧贴父元素结束位置结束 android:animateLayoutChanges 布局改变时是否有动画效果 android:clipChildren 定义子布局是否一定要在限定的区域内 android:clipToPadding 定义布局间是否有间距 android:animationCache 定义子布局也有动画效果 android:alwaysDrawnWithCache 定义子布局是否应用绘图的高速缓存 android:addStatesFromChildren 定义布局是否应用子布局的背景 android:splitMotionEvents 定义布局是否传递touch事件到子布局 android:focusableInTouchMode 定义是否可以通过touch获取到焦点 android:isScrollContainer 定义布局是否作为一个滚动容器 可以调整整个窗体 android:fadeScrollbars 滚动条自动隐藏 android:fitsSystemWindows 设置布局调整时是否考虑系统窗口(如状态栏) android:visibility 定义布局是否可见 android:requiresFadingEdge 定义滚动时边缘是否褪色 android:clickable 定义是否可点击 android:longClickable 定义是否可长点击 android:saveEnabled 设置是否在窗口冻结时（如旋转屏幕）保存View的数据 android:filterTouchesWhenObscured 所在窗口被其它可见窗口遮住时,是否过滤触摸事件 android:keepScreenOn 设置屏幕常亮 android:duplicateParentState 是否从父容器中获取绘图状态(光标,按下等) android:soundEffectsEnabled 点击或触摸是否有声音效果 android:hapticFeedbackEnabled 设置触感反馈 第二类：属性值必须为id的引用名“@id/idname” 属性 说明 android:layout_alignBaseline 本元素的文本与父元素文本对齐 android:layout_below 在某元素的下方 android:layout_above 在某元素的的上方 android:layout_toLeftOf 在某元素的左边 android:layout_toRightOf 在某元素的右边 android:layout_toStartOf 本元素从某个元素开始 android:layout_toEndOf 本元素在某个元素结束 android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐 android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐 android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐 android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐 android:layout_alignStart 本元素与开始的父元素对齐 android:layout_alignEnd 本元素与结束的父元素对齐 android:ignoreGravity 指定元素不受重力的影响 android:layoutAnimation 定义布局显示时候的动画 android:id 为布局添加ID方便查找 android:tag 为布局添加tag方便查找与类似 android:scrollbarThumbHorizontal 设置水平滚动条的drawable。 android:scrollbarThumbVertical 设置垂直滚动条的drawable android:scrollbarTrackHorizontal 设置水平滚动条背景（轨迹）的色drawable android:scrollbarTrackVertical 设置垂直滚动条背景（轨迹）的色drawable android:scrollbarAlwaysDrawHorizontalTrack 设置水平滚动条是否含有轨道 android:scrollbarAlwaysDrawVerticalTrack 设置垂直滚动条是否含有轨道 android:nextFocusLeft 设置左边指定视图获得下一个焦点 android:nextFocusRight 设置右边指定视图获得下一个焦点 android:nextFocusUp 设置上边指定视图获得下一个焦点 android:nextFocusDown 设置下边指定视图获得下一个焦点 android:nextFocusForward 设置指定视图获得下一个焦点 android:contentDescription 说明 android:OnClick 点击时从上下文中调用指定的方法 第三类：属性值为具体的像素值，如30dip，40px,50dp 属性 说明 android:layout_width 定义本元素的宽度 android:layout_height 定义本元素的高度 android:layout_margin 本元素离上下左右间的距离 android:layout_marginBottom 离某元素底边缘的距离 android:layout_marginLeft 离某元素左边缘的距离 android:layout_marginRight 离某元素右边缘的距离 android:layout_marginTop 离某元素上边缘的距离 android:layout_marginStart 本元素里开始的位置的距离 android:layout_marginEnd 本元素里结束位置的距离 android:scrollX 水平初始滚动偏移 android:scrollY 垂直初始滚动偏移 android:padding 指定布局与子布局的间距 android:paddingLeft 指定布局左边与子布局的间距 android:paddingTop 指定布局上边与子布局的间距 android:paddingRight 指定布局右边与子布局的间距 android:paddingBottom 指定布局下边与子布局的间距 android:paddingStart 指定布局左边与子布局的间距与android:paddingLeft相同 android:paddingEnd 指定布局右边与子布局的间距与android:paddingRight相同 android:fadingEdgeLength 设置边框渐变的长度 android:minHeight 最小高度 android:minWidth 最小宽度 android:translationX 水平方向的移动距离 android:translationY 垂直方向的移动距离 android:transformPivotX 相对于一点的水平方向偏转量 android:transformPivotY 相对于一点的垂直方向偏转量 第四类：属性值问Android内置值的 属性 说明 android:gravity 控件布局方式 android:layout_gravity 布局方式 android:persistentDrawingCachehua 定义绘图的高速缓存的持久性 android:descendantFocusability 控制子布局焦点获取方式 常用于listView的item中包含多个控件 点击无效 android:scrollbars 设置滚动条的状态 android:scrollbarStyle 设置滚动条的样式 android:fitsSystemWindows 设置布局调整时是否考虑系统窗口(如状态栏) android:scrollbarFadeDuration 设置滚动条淡入淡出时间 android:scrollbarDefaultDelayBeforeFade 设置滚动条N毫秒后开始淡化，以毫秒为单位。 android:scrollbarSize 设置滚动调大小 android:fadingEdge 设置拉滚动条时 ,边框渐变的放向 android:drawingCacheQuality 设置绘图时半透明质量 android:OverScrollMode 滑动到边界时样式 android:alpha 设置透明度 android:rotation 旋转度数 android:rotationX 水平旋转度数 android:rotationY 垂直旋转度数 android:scaleX 设置X轴缩放 android:scaleY 设置Y轴缩放 android:verticalScrollbarPosition 设置垂直滚动条的位置 android:layerType 设定支持 android:layoutDirection 定义布局图纸的方向 android:textDirection 定义文字方向 android:textAlignment 文字对齐方式 android:importantForAccessibility 设置可达性的重要行 android:labelFor 添加标签 android:background 本元素的背景","tags":[{"name":"layout","slug":"layout","permalink":"http://seniorzhai.github.io/tags/layout/"},{"name":"属性","slug":"属性","permalink":"http://seniorzhai.github.io/tags/属性/"}]},{"title":"[转]json实体类快速生成插件","date":"2015-05-28T12:27:33.000Z","path":"2015/05/28/-转-json实体类快速生成插件/","text":"转至 http://www.jianshu.com/p/b83ea5e32ee1写在前头:本插件只适用 android studio和 Intellij IDEA 工具,eclipse 的少年无视我吧!!! 这是一个根据JSONObject格式的字符串,自动生成实体类参数. github jetbrains版本更新1.1.0. 1.1.0 版本更新内容: 支持数组中嵌套数组的解析; 支持过滤Json格式中的注释代码. Usage安装方法1:1231.Android studio File-&gt;Settings..-&gt;Plugins--&gt;Browse repositores..搜索GsonFormat2.安装插件,重启android studio 安装方法2:12341.下载GsonFormat.jar ;2.Android studio File-&gt;Settings..-&gt;Plugins --&gt; install plugin from disk..导入下载的GsonFormat.jar 3重启android studio 使用方式在实体类中使用Generate的快捷键. 快捷键:图中选中的部分我这边的快捷键是 command+n; 简单的实体类:图中简单的 json 格式123456&#123; &quot;name&quot;: &quot;王五&quot;, &quot;gender&quot;: &quot;man&quot;, &quot;age&quot;: 15, &quot;height&quot;: &quot;140cm&quot;,&#125; 图中的实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849** * Created by 轻微 on 15/1/9. */public class Bean extends JSONModel &#123; /** * height : 140cm * age : 15 * name : 王五 * gender : man */ private String height; private int age; private String name; private String gender; public void setHeight(String height) &#123; this.height = height; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public String getHeight() &#123; return height; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public String getGender() &#123; return gender; &#125;&#125; 复杂的实体类:实体类不仅包含另外一个实体,还包含另外实体的数组.图中复杂的json 格式123456789101112131415161718192021&#123; &quot;name&quot;: &quot;王五&quot;, &quot;gender&quot;: &quot;man&quot;, &quot;age&quot;: 15, &quot;height&quot;: &quot;140cm&quot;, &quot;addr&quot;: &#123; &quot;province&quot;: &quot;fujian&quot;, &quot;city&quot;: &quot;quanzhou&quot;, &quot;code&quot;: &quot;300000&quot; &#125;, &quot;hobby&quot;: [ &#123; &quot;name&quot;: &quot;billiards&quot;, &quot;code&quot;: &quot;1&quot; &#125;, &#123; &quot;name&quot;: &quot;computerGame&quot;, &quot;code&quot;: &quot;2&quot; &#125; ]&#125; 图中的实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** * Created by 轻微 on 15/1/9. */public class Bean extends JSONModel &#123; /** * height : 140cm * age : 15 * name : 王五 * hobby : [&#123;&quot;name&quot;:&quot;billiards&quot;,&quot;code&quot;:&quot;1&quot;&#125;,&#123;&quot;name&quot;:&quot;computerGame&quot;,&quot;code&quot;:&quot;2&quot;&#125;] * gender : man * addr : &#123;&quot;province&quot;:&quot;fujian&quot;,&quot;code&quot;:&quot;300000&quot;,&quot;city&quot;:&quot;quanzhou&quot;&#125; */ private String height; private int age; private String name; private List&lt;HobbyEntity&gt; hobby; private String gender; private AddrEntity addr; public void setHeight(String height) &#123; this.height = height; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setHobby(List&lt;HobbyEntity&gt; hobby) &#123; this.hobby = hobby; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public void setAddr(AddrEntity addr) &#123; this.addr = addr; &#125; public String getHeight() &#123; return height; &#125; public int getAge() &#123; return age; &#125; public String getName() &#123; return name; &#125; public List&lt;HobbyEntity&gt; getHobby() &#123; return hobby; &#125; public String getGender() &#123; return gender; &#125; public AddrEntity getAddr() &#123; return addr; &#125; public class HobbyEntity &#123; /** * name : billiards * code : 1 */ private String name; private String code; public void setName(String name) &#123; this.name = name; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getName() &#123; return name; &#125; public String getCode() &#123; return code; &#125; &#125; public class AddrEntity &#123; /** * province : fujian * code : 300000 * city : quanzhou */ private String province; private String code; private String city; public void setProvince(String province) &#123; this.province = province; &#125; public void setCode(String code) &#123; this.code = code; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getProvince() &#123; return province; &#125; public String getCode() &#123; return code; &#125; public String getCity() &#123; return city; &#125; &#125;&#125;","tags":[{"name":"插件","slug":"插件","permalink":"http://seniorzhai.github.io/tags/插件/"},{"name":"Android Studio","slug":"Android-Studio","permalink":"http://seniorzhai.github.io/tags/Android-Studio/"}]},{"title":"SuperAgent使用","date":"2015-05-13T03:12:25.000Z","path":"2015/05/13/SuperAgent使用/","text":"SuperAgent是一个非常方便的客户端请求模块，能方便的发起get、post、put、delete、head请求 简单使用12345request .get('/') .end(function(res)&#123; // 处理数据 &#125;); 可以使用参数传递1request('GET','/search').end(callback); 也可以使用绝对路径12request.get('http://example.com/search') .end(function(res)) delete、head、post、put等HTTP动作都可以使用12345request .head('/favicon.ico') .end(function(res)&#123; // &#125;) delete是默认的保留字所以使用.del()来指定delete动作12345request .del('/user/1') .end(function(res)&#123; // &#125;); 设置头字段只需要调用.set()方法即可12345request .get('/search') .set('API-Key','foobar') .set('Accept','application/json') .end(callback); 也可以传递一个对象，一次修改多个字段1234request .get('/search') .set(&#123; 'API-Key': 'foobar', Accept: 'application/json' &#125;) .end(callback); GET请求使用.query()方法可以传递一个对象完成请求参数1234567reques .get('/search') .query(&#123;query:'Manny'&#125;) .query(&#123;rang:'1.5'&#125;) .end(function(res)&#123; // &#125;); 也可以合并成一个对象123456request .get('/search') .query(&#123;query:'Manny',range:'1.5'&#125;) .end(function(res)&#123; // &#125;); 也可以直接传递字符串123456request .get('/search') .query('query=Manny&amp;range=1.5') .end(function(res)&#123; // &#125;); 或者字符串拼接1234567request .get('/querystring') .query('search=Manny') .query('range=1..5') .end(function(res)&#123; // &#125;); POST/PUT请求 POST Json数据1234request.post('/user') .set('Content-Type','application/json') .send('&#123;\"name\":\"tj\",\"pet\":\"tobi\"&#125;') .end(callback); 默认支持form和json两种格式，不设置Content-Type也是可以的 以application/x-www-form-urlencoded类型发送数据，调用.type()方法传递form参数即可12345request.post('/user') .type('form') .send(&#123; name: 'tj' &#125;) .send(&#123; pet: 'tobi' &#125;) .end(callback) form是form-data和urlencoded的别名 设置Content-Type12345678request.post('/user') .type('application/json')request.post('/user') .type('json')request.post('/user') .type('png') 设置接收类型12345678request.get('/user') .accept('application/json')request.get('/user') .accept('json')request.get('/user') .accept('png') 查询字符串当POST请求并希望传递一些查询字符串时，可以同时使用.query()方法123456request .post('/') .query(&#123; format: 'json' &#125;) .query(&#123; dest: '/login' &#125;) .send(&#123; post: 'data', here: 'wahoo' &#125;) .end(callback); 解析响应内容SuperAgent会解析一些常用的格式，当前支持application/json，application/x-www-form-urlencoded，multipart/form-data JSON/Urlencodedres.body是解析后的内容对象，比如一个请求响应&#39;{“user:{&quot;name&quot;:&quot;tobi&quot;}}&#39;字符串，res.body.user.name将会返回tobi Multipartres.files属性就可以直接获取文件 响应属性返回为response对象 textres.text为未解析的响应内容，一般只在mime类型能够匹配text，json，x-www-form-urlencoding的情况 body当Content-Type定义一个解析器后，自动解析，默认解析application/json和application/x-www-form-urlencoding headerres.header包含解析之后的响应投数据，键值都是node处理成小写字幕形成，比如res.header[&#39;content-lenth&#39;] Content-TypeContent-Type响应头字段的一个特例，服务器提供res.type来访问他，默认res.charset。如Content-Type为text/html;charset=utf-8则res.type为text/html，res.charset为utf-8 Status响应状态标志位123456789101112131415161718192021var type = status / 100 | 0; // status / class res.status = status; res.statusType = type; // basics res.info = 1 == type; res.ok = 2 == type; res.clientError = 4 == type; res.serverError = 5 == type; res.error = 4 == type || 5 == type; // sugar res.accepted = 202 == status; res.noContent = 204 == status || 1223 == status; res.badRequest = 400 == status; res.unauthorized = 401 == status; res.notAcceptable = 406 == status; res.notFound = 404 == status; res.forbidden = 403 == status; 中止请求req.abort()可以中止请求 请求超时req.timeout()来定义超时时间 基础验证 传递URL 1request.get('http://tobi:learnboost[@local](/user/local)').end(callback); 调用.auth()方法 1234request .get('http://local') .auth('tobo', 'learnboost') .end(callback); 重定向可以通过调用.res.redirects(n)来设置个数，默认是5个1234request .get('/some.png') .redirects(2) .end(callback); 管道数据允许使用一个请求流来输送数据,比如请求一个文件作为输出流123456789101112131415var request = require('superagent') , fs = require('fs');var stream = fs.createReadStream('path/to/my.json');var req = request.post('/somewhere');req.type('json');stream.pipe(req);// 保存到文件var request = require('superagent') , fs = require('fs');var stream = fs.createWriteStream('path/to/my.json');var req = request.get('/some.json');req.pipe(stream); 复合请求1234567891011121314var req = request.post('/upload');req.part() .set('Content-Type', 'image/png') .set('Content-Disposition', 'attachment; filename=\"myimage.png\"') .write('some image data') .write('some more image data');req.part() .set('Content-Disposition', 'form-data; name=\"name\"') .set('Content-Type', 'text/plain') .write('tobi');req.end(callback); 附加文件可以通用.attach(name, [path], [filename])和.field(name, value)这两种形式来调用.添加多个附件也比较简单，只需要给附件提供自定义的文件名称,同样的基础名称也要提供.123456request .post('/upload') .attach('avatar', 'path/to/tobi.png', 'user.png') .attach('image', 'path/to/loki.png') .attach('file', 'path/to/jane.png') .end(callback); 字段值跟html的字段很像,你可以调用.field(name,value)方法来设置字段,假设你想上传一个图片的时候带上自己的名称和邮箱，那么你可以像下面写的那样:123456request .post('/upload') .field('user[name]', 'Tobi') .field('user[email]', 'tobi[@learnboost](/user/learnboost).com') .attach('image', 'path/to/tobi.png') .end(callback); 缓冲响应为了强迫缓冲res.text这样的响应内容,可以调用req.buffer()方法,想取消默认的文本缓冲响应像text/plain,text/html这样的，可以调用req.buffer(false)方法当缓冲res.buffered标识提供了，那么就可以在一个回调函数里处理缓冲和没缓冲的响应. 跨域资源共享.withCredentials()方法可以激活发送原始cookie的能力,不过只有在Access-Control-Allow-Origin不是一个通配符(*),并且Access-Control-Allow-Credentials为true的情况下才行.12345678request .get('http://localhost:4001/') .withCredentials() .end(function(res)&#123; assert(200 == res.status); assert('tobi' == res.text); next(); &#125;) 异常处理当发送错误时，superagent首先会检查回调函数的参数数量,当err参数提供的话，参数就是两个,如下:123456789101112131415request .post('/upload') .attach('image', 'path/to/tobi.png') .end(function(err, res)&#123; &#125;); request .post('/upload') .attach('image', 'path/to/tobi.png') .on('error', handle) .end(function(res)&#123; // &#125;); 注意:superagent默认情况下,对响应4xx和5xx的认为不是错误,例如当响应返回一个500或者403的时候,这些状态信息可以通过res.error,res.status和其它的响应属性来查看,但是没有任务的错误对象会传递到回调函数里或者emit一个error事件.正常的error事件只会发生在网络错误,解析错误等. 当产生一个4xx或者5xx的http错误响应,res.error提供了一个错误信息的对象，你可以通过检查这个来做某些事情.12345if (res.error) &#123; alert('oh no ' + res.error.message);&#125; else &#123; alert('got ' + res.status + ' response');&#125;","tags":[{"name":"http","slug":"http","permalink":"http://seniorzhai.github.io/tags/http/"},{"name":"爬虫","slug":"爬虫","permalink":"http://seniorzhai.github.io/tags/爬虫/"},{"name":"cookie","slug":"cookie","permalink":"http://seniorzhai.github.io/tags/cookie/"},{"name":"访问","slug":"访问","permalink":"http://seniorzhai.github.io/tags/访问/"}]},{"title":"RDVTabBarController的简单使用","date":"2015-04-27T13:04:57.000Z","path":"2015/04/27/RDVTabBarController的简单使用/","text":"RDVTabBarController是一款高度定制化的TabBarController，可以方便的对每一个TabItem进行配置。 使用在pod中添加1pod &apos;RDVTabBarController&apos;, &apos;~&gt; 1.1.9&apos; 初始化12345678910111213UIViewController *firstViewController = [[FirstViewController alloc] init];UIViewController *firstNavigationController = [[UINaigationController alloc] initWithRootViewController:firstViewController];UIViewController *secondViewController = [[SecondViewController alloc] init];UIViewController *secondNavigationViewController = [[UINaigationController alloc] initWithRootViewController:sencondViewController];UIViewController *thirdViewController = [[ThirdViewController alloc] init];UIViewController *thirdNavigationViewController = [[UINaigationController alloc] initWithRootViewController:thirdViewController];RDVTabBarController *tabBarController = [[EDVTabBarController alloc] init];[tabBarController setViewControllers:@[firstNavigationController,secondNavigationViewController,thirdNavigationViewController]];self.viewController = tabBarController; 定制化TabItem123UIImage *finishedImage = [UIImage imageNamed:@&quot;selected_background&quot;];UIImage *unfinishedImage = [UIImage imageNamed:@&quot;normal_background&quot;];[[tabBarController tabBar] items];","tags":[]},{"title":"[转]快速定位感兴趣的功能代码","date":"2015-04-27T01:39:51.000Z","path":"2015/04/27/-转-快速定位感兴趣的功能代码/","text":"现在越来越多的开源项目了，令人收藏不暇，有时只是觉得对方的某个 feature 特别喜欢，但很多人可能打开了其代码找了半天找不到关键所在。其实，如果运用了 Android Studio 带给我们的一些查找功能，任何一份新的开源代码摆在我们眼前，我们都可以快速定位到感兴趣的功能代码。转至：http://drakeet.me/quickly-locate-the-function-code 一、快速定位 BlackLight 的「收藏微博」功能代码说明：BlackLight 是一个 Material Design 的微博客户，更多介绍可以看这个帖子：一个 Material Design 的微博客户 。我是前天拿到它的源代码的，我想把它微博信息页面中的收藏微博功能提取出来，做一个快捷收藏的功能……它的代码量不小，你不知道作者给这个页面取名叫什么 Activity，你也不知道你就算找到这个 Activity，再要定位到这个具体地方要多久（这个例子是针对 option menu，原本如果手动定位，也是比较简单的，但大部分没那么容易）。关键点1：对于整个项目源代码进行「find in path」查找这个功能的字符串「收藏微博」四个字，如下：出来的结果是，找到了，并且找到的位置是在 strings.xml 文件中：关键点2：我们可以双击跳转到这个 strings.xml 文件中的「收藏微博」位置，然后把光标放在它的 name 上，右键鼠标（或者快捷键），出现「find usages」，结果就会显示它被使用的地方：哦。。。才知道这个名为「微博信息」页面，作者给它命名的是「SingleActivity」。。。如果不借助这两三下快速查找，你能想到？。。。然后，我们果断跳过去，跳过去到达 SingleActivity 之后就很直接了，这个功能明显是在 onOptionsItemSelected 这个方法内，于是我们很快可以找到：就是它了！总结：关键点其实很简单，入手的时候，先全局搜索（find in path）你要的功能它的名称，一般是定位到 strings.xml，再对这条 Item 的 name 进行查找它的使用（find usages），定位到它被使用的地方，基本就很接近目标了。如果大家还不明确，请看第二个例子…… 快速定位 EhViewer 的 ripple 加载新页面功能：说明：额，这个EhViewer嘛，是一个（hentai）绅士阅读器，我也是昨天晚上朋友说它 MD 做得不错才去看看它的代码的。发现它有一个「点击查看更多」的地方，点击了之后，会以 ripple 的动画效果展开一个新页面显示内容，很棒。于是想一探究竟……入手：仍然是对全局进行搜索，find in path &lt;- “点击查看更多”，和上面一样，很快定位到 strings.xml 文件中的这一行：1&lt;string name=\"click_more\"&gt;点击查看更多&lt;/string&gt; 右键点击这个 click_more，选择 find usages，很快又精准定位到了：看，定位到这个 Activity 是如此简单粗暴~过去看一下，发现目标并不能直接关联这个动画功能的代码，只是显示这样：1mCommentMoreText.setText(R.string.click_more); 而且你会发现你对于这个mCommentMoreText找来找去（使用页面内的搜索，command + f）都没发现它的 setOnClickListener 是在哪，这时也不能放弃，因为我们知道，目标肯定很近了……想了一下，猜想，作者可能是对于这个 mCommentMoreText 的父容器布局进行绑定监听器，于是……关键点：找到 findViewById 位置，跟踪跳转到 xml 布局文件……于是我就页面内搜索（command + f）这个 mCommentMoreText，马上定位到它的findViewById：1mCommentMoreText = (TextView) findViewById(R.id.comment_more_text); 按住 command 点击这个comment_more_text，可以跳到它的 xml 布局文件，发现它的父布局是一个 LinearLayout，并且 id 是 detail_comment，果断对这个 id 进行 find usages，会跳转到它的 Java 代码位置：1mDetailComment = (LinearLayout) findViewById(R.id.detail_comment); 再页面内搜索 mDetailComment，果然得到它绑定了 mDetailComment.setOnTouchListener(this); 那么接下来就非常直接了，顺藤摸瓜，我们马上去 onTouch 看看（虽然是 mDetailMore，可能是另一层父控件），目标 get!：总结：这一回合，我们关键还是在 find in path / find usages 的基础之上，更多的 command + F 页面内查找，一般基本定位后都难逃我们的掌心，方法其实都很简单，一回生二回熟，以后任何开源项目代码的任何功能，都能闭着眼睛，快速定位啦，哈哈哈。。。。","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"定位代码","slug":"定位代码","permalink":"http://seniorzhai.github.io/tags/定位代码/"}]},{"title":"让Pod飞","date":"2015-04-23T14:16:07.000Z","path":"2015/04/23/让Pod飞/","text":"很久没用Pod，现在CocoaPods真是巨卡无比使用pod install --no-repo-update命令会好得多也可以更换一个新的镜像123pod repo remove masterpod repo add master https://gitcafe.com/akuandev/Specs.gitpod repo update 详情见http://akinliu.github.io/2014/05/03/cocoapods-specs-/","tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"http://seniorzhai.github.io/tags/CocoaPods/"}]},{"title":"swift-fallthrough关键字","date":"2015-04-23T14:01:34.000Z","path":"2015/04/23/swift-fallthrough关键字/","text":"fallthrough关键字在switch case中使用，为了使得swift能够保持C语言中switch的语法特性总所周知，在大多数语言中，switch语句块，case要紧跟break，否则case之后的语句会顺序运行123456789101112int i = 1;switch(1)&#123; case 1: i++; case 2: i++; case 3: i++; default: i++;&#125;// i = 5 如果在swift中，默认是不会执行下去的1234567891011121314var i : Int = 1switch 1&#123;case 1: i++case 2: i++case 3: i++default: i++&#125;// i = 2 为了保持这种特性可以使用fallthrough关键字123456789101112131415var i : Int = 1switch 1&#123;case 1: i++ fallthroughcase 2: i++ fallthroughcase 3: i++ fallthroughdefault: i++&#125;","tags":[{"name":"swfit","slug":"swfit","permalink":"http://seniorzhai.github.io/tags/swfit/"},{"name":"switch","slug":"switch","permalink":"http://seniorzhai.github.io/tags/switch/"},{"name":"fallthrough","slug":"fallthrough","permalink":"http://seniorzhai.github.io/tags/fallthrough/"}]},{"title":"ShowTipsView提示说明控件","date":"2015-04-16T12:47:27.000Z","path":"2015/04/16/ShowTipsView提示说明控件/","text":"ShowTipsView是一款用于显示提示说明的控件 引用1compile 'net.fredericosilva:showTipsView:1.0.1' 使用1234567891011121314151617181920212223ShowTipsView showtips = new ShowTipsBuilder(this) .setTarget(btn_test) .setTitle(\"A magnific button\") .setDescription(\"This button do nothing so good\") .setDelay(1000) .build();showtips.show(this);// 自定义属性setTitleColor(int color)setDescriptionColor(int color)setBackgroundColor(int color)setCircleColor(int color)setTarget(View v, int x, int y, int radius)showtips.setCallback(new ShowTipsInterface()&#123; @Override public void gotItClicked() &#123; //Lunch new showtip &#125;&#125;); 示例https://github.com/SeniorZhai/ShowTipsView","tags":[{"name":"提示","slug":"提示","permalink":"http://seniorzhai.github.io/tags/提示/"},{"name":"初始化","slug":"初始化","permalink":"http://seniorzhai.github.io/tags/初始化/"}]},{"title":"给AS一个Meterial-template模板","date":"2015-04-16T08:49:19.000Z","path":"2015/04/16/给AS一个Meterial-template模板/","text":"下载及配置 在https://github.com/kanytu/Android-studio-material-template下载MaterialNavigationDrawerActivity文件夹 把它放到{Android Studio installation dir}\\plugins\\android\\lib\\templates\\activities\\目录下(Mac右键进入显示包内容) 重启Android Studio 下载新建工程就可以看到如下界面","tags":[{"name":"Meterial","slug":"Meterial","permalink":"http://seniorzhai.github.io/tags/Meterial/"}]},{"title":"视差View","date":"2015-04-16T06:38:50.000Z","path":"2015/04/16/视差View/","text":"ParallaxEverywhere是一个可以产生视差的View，可以使文本和图片在滚动的时候产生视差。 必须在有滚动的视图内，才会有作用 在Image中必须设置缩放模式时必须是centerCrop、centerInside、center ImageView里必须有尺寸 导入1compile &apos;com.fmsirvent:parallaxeverywhere:1.0.4&apos; 布局12345678910111213141516171819202122232425262728&lt;FrameLayout android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:layout_margin=\"10dp\" android:layout_weight=\"1\"&gt; &lt;com.fmsirvent.ParallaxEverywhere.PEWImageView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_gravity=\"center\" android:layout_margin=\"10dp\" android:scaleType=\"centerCrop\" android:src=\"@drawable/alicante_explanada\" /&gt; &lt;com.fmsirvent.ParallaxEverywhere.PEWTextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"10dp\" android:gravity=\"bottom|center_horizontal\" android:text=\"@string/alicante_explanada\" android:textColor=\"@android:color/white\" app:block_parallax_x=\"true\" app:parallax_x=\"160dp\" app:parallax_y=\"160dp\" app:reverse=\"reverseY\" /&gt; &lt;/FrameLayout&gt; 属性 reverse = [“none”,”reverseX”,”reverseY”,”reverseBoth”] 反向滚动方向 block_parallax_x and block_parallax_y boolean 大块滚动 interpolation 滚动速率变化 [“linear”, “accelerate_decelerate”, “accelerate”, “anticipate”, “anticipate_overshoot”, “bounce”, “decelerate”, “overshoot”] parallax_x and parallax_y 只存在图像中，设置视差方向 https://github.com/SeniorZhai/Parallax","tags":[]},{"title":"Masonry布局框架","date":"2015-04-15T09:10:59.000Z","path":"2015/04/15/Masonry布局框架/","text":"Masonry是一款轻量级的布局框架，采用优雅的链式语法封装了Apple的自动布局，具有极高的可读性和易用性。 Masonry支持的属性1234567891011@property (nonatomic,strong,readonly) MASConstraint *left;@property (nonatomic,strong,readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;@property (nonatomic, strong, readonly) MASConstraint *leading;@property (nonatomic, strong, readonly) MASConstraint *trailing;@property (nonatomic, strong, readonly) MASConstraint *width;@property (nonatomic, strong, readonly) MASConstraint *height;@property (nonatomic, strong, readonly) MASConstraint *centerX;@property (nonatomic, strong, readonly) MASConstraint *centerY;@property (nonatomic, strong, readonly) MASConstraint *baseline; 对应到NSLayoutAttrubute Masonry NSLayoutAttriubute 说明 left NSLayoutAttributeLeft 左侧 top NSLayoutAttributeTop 上侧 right NSLayoutAttributeRight 右侧 bottom NSLayoutAttributeBottom 下侧 leading NSLayoutAttributeLeading 首部 trailing NSLayoutAttributeTrailing 尾部 width NSLayoutAttributeWith 宽 height NSLayoutAttributeHeight 高 centerX NSLyoutAttributeCenterX 横向中点 centerY NSLyoutAttributteCenterY 纵向中点 baseline NSLayoutAttributeBaseline 文本基准线 居中显示View1234567891011- (void) viewDidLoad&#123; [super viewDidLoad]; sv1.backgroundColor = UIColorFromRGB(0x434A54); UIView *sv = [UIView new]; [self.view addSubView:sv]; [sv mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(sv.superview); // 中点与父View相同，即居中 make.size.mas_equalTo(CGSizeMake(300,300)); &#125;];&#125; 边距1234567891011121314UIView *sv = [UIView new];[self.view addSubview:sv];[sv mas_makeConstraints:^(MAConstraintMaker *make)&#123; make.edges.equalTo(sv.superview).with.insert(UIEdgeInsetsMake(10,10,10,10)); /* make.top.equalTo(sv.superview).with.offset(10); make.left.equalTo(sv.superview).with.offset(10); make.bottom.equalTo(sv.superview).with.offset(-10); make.right.equalTo(sv.superview).with.offset(-10); */ /* make.top.left.bottom.and.right.equalTo(sv.superview).with.insert(UIEdgeInsetsMake(10,10,10,10)); */&#125;]; 等宽并存在间隔1234567891011121314151617181920UIView *sv3 = [UIView new]; UIView *sv4 = [UIView new]; sv3.backgroundColor = UIColorFromRGB(0x48CFAD); sv4.backgroundColor = UIColorFromRGB(0x4FC1E9); [sv2 addSubview:sv3]; [sv2 addSubview:sv4]; [sv3 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv2.mas_centerY); // 中心与superView相同，即居中 make.left.equalTo(sv2.mas_left).with.offset(10); // 左边与superView相同，间隔10 make.right.equalTo(sv4.mas_left).with.offset(-10); // 右边与sv4紧贴，间隔10 make.height.mas_equalTo(@150); // 高度150 make.width.equalTo(sv4); &#125;]; [sv4 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(sv2.mas_centerY); make.left.equalTo(sv3.mas_right).with.offset(10); make.right.equalTo(sv2.mas_right).with.offset(-10); make.height.mas_equalTo(@150); make.width.equalTo(sv3); &#125;]; UIScrollView顺序排列123456789101112131415161718192021222324252627282930313233343536373839404142UIScrollView *scrollView = [UIScrollView new]; scrollView.backgroundColor = UIColorFromRGB(0xFFCE54); [self.view addSubview:scrollView]; [scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.mas_equalTo(sv1.mas_bottom).offset(10); make.bottom.mas_equalTo(self.view.mas_bottom).offset(-10); make.left.mas_equalTo(sv1.mas_left); make.right.mas_equalTo(sv1.mas_right); &#125;]; UIView *container = [UIView new]; [scrollView addSubview:container]; [container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(scrollView); make.width.equalTo(scrollView); &#125;]; UIView *lastView = nil; for (int i = 0; i&lt;10; ++i) &#123; UIView *subView = [UIView new]; subView.backgroundColor = [UIColor colorWithHue:( arc4random() % 256 / 256.0 ) saturation:( arc4random() % 128 / 256.0 ) + 0.5 brightness:( arc4random() % 128 / 256.0 ) + 0.5 alpha:1]; [container addSubview:subView]; [subView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(container); make.height.mas_equalTo(20); if ( lastView ) &#123; make.top.mas_equalTo(lastView.mas_bottom); &#125; else &#123; make.top.mas_equalTo(container.mas_top); &#125; &#125;]; lastView = subView; &#125; [container mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.bottom.equalTo(lastView.mas_bottom); &#125;];","tags":[{"name":"布局","slug":"布局","permalink":"http://seniorzhai.github.io/tags/布局/"},{"name":"Masonry","slug":"Masonry","permalink":"http://seniorzhai.github.io/tags/Masonry/"},{"name":"自动布局","slug":"自动布局","permalink":"http://seniorzhai.github.io/tags/自动布局/"},{"name":"自适应","slug":"自适应","permalink":"http://seniorzhai.github.io/tags/自适应/"}]},{"title":"比较通用的适配器","date":"2015-04-15T06:01:21.000Z","path":"2015/04/15/比较通用的适配器/","text":"完成了基本的ViewHolder和List数据管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public abstract class SimpleBaseAdapter&lt;T&gt; extendsBaseAdapter &#123; protected Context context; protected List&lt;T&gt; data; public SimpleBaseAdapter(Context context,List&lt;T&gt; data) &#123; this.context = context; this.data = data == null ? new Array&lt;T&gt;() : new ArrayList&lt;T&gt;(data); &#125; @Override public int getCount() &#123; return data.size(); &#125; @Override public Object getItem(int postion) &#123; if (postion &gt;= data.size) &#123; return null; &#125; return data.get(postion); &#125; @Override public long getItemId(int postion) &#123; return postion; &#125; // 返回item的layout资源ID public abstract int getItemResoure(); public abstract View getItemView(int postion,View convertView,ViewHolder holder); @Override public View getView(int postion,View convertView,ViewGoup parent) &#123; ViewHolder holder; if (null == convertView) &#123; convertView = View.inflate(context,getItemResource(),null); holder = new ViewHolder(convertView); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; return getItemView(postion,convertView,holder); &#125; public class ViewHolder &#123; private SparseArray&lt;View&gt; views = new SparseArray&lt;View&gt;(); private View convertView; public ViewHolder(View convertView) &#123; this.convertView = convertView; &#125; public &lt;T extends View&gt; T getView(int resId) &#123; View v = views.get(resId); if (null == v) &#123; v = convertView.findViewById(resId); views.put(resId,v); &#125; return (T) v; &#125; &#125; public void addAll(List&lt;T&gt; elem) &#123; data.addAll(elem); notifyDataSetChanged(); &#125; public void remove(T elem) &#123; data.remove(elem); notifyDataSetChanged(); &#125; public void remoce(int index) &#123; data.remove(index); notifyDataSetChanged(); &#125; public vodi replaceAll(List&lt;T&gt; elem) &#123; data.clear(); data.allAll(elem); notifyDataSetChanged(); &#125;&#125; 在实现时主要关注getItemResource和getItemView方法 getItemResource返回layout资源ID getItemView中利用数据加载Item View","tags":[{"name":"BaseAdapter","slug":"BaseAdapter","permalink":"http://seniorzhai.github.io/tags/BaseAdapter/"}]},{"title":"LabelView角标不用愁","date":"2015-04-15T05:47:43.000Z","path":"2015/04/15/LabelView角标不用愁/","text":"LabelView是一款极其方便的角标视图，可以很容易地加载其他View上。 导入123dependencies &#123; compile &apos;com.lid.labelview:lib:0.1.1&apos;&#125; 使用LabelView继承至TextView，可以使用所有TextView的属性1234LabelView label = new LabelView(this);label.setText(\"Text\");label.setBackgroundColor(0xff03a9f4);label.setTargetView(mTv,10,LabelView.Gravity.LEFT_TOP); // 指定在左上角 setTargetView的第二个参数是角标距角的位置 删除使用remove方法即可","tags":[{"name":"角标","slug":"角标","permalink":"http://seniorzhai.github.io/tags/角标/"}]},{"title":"Application.mk文件说明","date":"2015-04-13T13:44:30.000Z","path":"2015/04/13/Application-mk文件说明/","text":"Application.mk描述Android应用程序中需要本地模块 APP_PROJECT_PATH应用程序工程的根目录的绝对路径这是用来复制或安装一个没有任何限制的JNI库 APP_MODULES可选的变量，默认定义为LOCAL_MODULE中 APP_OPTIM可选的变量，用来定义release或debug，在编译应用模块的时候，可以用来改变优先级。release会生成高度优化的二进制代码，debug生成的时为优化的二进制代码，可以检测出很多BUG，可以用于调试 APP_CFLAGS编译器开关集合，可以用于改变一个给定应用程序需要依赖的模块的构建 APP_ABI默认情况下NDK的编译系统根据”armeabi”ABI生成机器代码，可以指定选择不同的ABI生成。如x86，armeabi-v7a，armeabi，all","tags":[{"name":"ndk","slug":"ndk","permalink":"http://seniorzhai.github.io/tags/ndk/"}]},{"title":"Android应用权限判断","date":"2015-04-10T09:05:12.000Z","path":"2015/04/10/Android应用权限判断/","text":"判断应用是否有某个权限12PackageManager pm = getPackageManager();boolean permission = (PackageManager.PERMISSION_GRANTED == pm.checkPermission(\"android.permission.RECORD_AUIO\",\"packageName\"));// permission用于判断是否有该权限 获取某个应用的权限清单12PackageInfo pack = pm.getPackageInfo(\"packageName\",PackageManager.GET_PERMISSIONS);String[] permissionStrings = pack.requestedPermissions; // 获取到应用权限的字符串数组","tags":[{"name":"权限","slug":"权限","permalink":"http://seniorzhai.github.io/tags/权限/"}]},{"title":"Android Xml资源中小Tips","date":"2015-04-10T08:35:37.000Z","path":"2015/04/10/Android-Xml资源中小Tips/","text":"@ 引入自定义资源，格式为@[package:]type/name 最常见的资源引用 1android:text=\"@string/hello\" 引入系统资源，格式为@android:type/name 1android:textColor=\"@android:color/opaque_red\" @*引用系统非public资源@*android:type/name 系统资源纷纷public和非public，生命在\\platforms\\android-8\\data\\res\\values\\public.xml 相比@android:type/name，@*android:type/name能够使用所有Android系统资源，不过Google官方不推介使用 ??[namespace:]type/name这种方式用于引用当前主题中的属性值，这个属性值只能在style资源和XML属性中使用1android:textColor=\"?android:textDisabledColor\" @+@+type/name，+表示在type中添加一条记录通常用于定义资源id1android:id=\"@+id/select\"","tags":[{"name":"style","slug":"style","permalink":"http://seniorzhai.github.io/tags/style/"},{"name":"资源","slug":"资源","permalink":"http://seniorzhai.github.io/tags/资源/"}]},{"title":"jQuery三识","date":"2015-03-31T05:21:31.000Z","path":"2015/03/31/jQuery三识/","text":"遍历DOM祖先通过jQuery能够向上遍历DOM数，以查找元素的祖先 parent() 返回所选元素的直接父类 parents() 返回所选元素的所有祖先元素，知道根元素() parentsUntil() 返回介于两个元素之间的所有祖先元素123$(function()&#123; $(\"span\").prantsUntil(\"div\");&#125;) 后代jQuery能够向下遍历DOM树 children() 返回被选元素的所有子元素 find() 返回被选元素的后代元素，一路向下指导最后一个后代同胞jQuery能够在DOM中遍历元素的同胞元素 siblings() 返回被选元素的所有同胞元素 next() 返回被选元素的下一个同胞元素 nextAll() 返回被选元素的所有跟随的同胞元素 nextUntil() 返回介于两个给定参数之间的所有跟随的同胞元素 prev() 与next方向相反 prevAll() 与nextAll方向相反 prevUntil() 与nextUntil方向相反 jQuery AjaxAJAX = Asynchronous JavaScript and XML简单的说在不重载整个页面的情况下，AJAX通过后台加载数据，并在网页上进行显示 AJAX loadload()方法能够从服务器加载数据，并把返回的数据放入元素元素中1$(selector).load(URL,data,callback); 必选参数URL为希望加载的URL，可选的data参数规定了请求一同发送的查询字符串的键/值对集合，可选的callback是load方法完成后所执行的函数回调函数有不同的参数 responseTxt 结果内容 statusTxt 调用的状态 xhr XMLHttpRequest对象12345678$(\"button\").click(function()&#123; $(\"# div1\").load(\"demo_test.txt\",function(responseTxt,statusTxt,xhr)&#123; if(statusTxt==\"success\") alert(\"External content loaded successfully!\"); if(statusTxt==\"error\") alert(\"Error: \"+xhr.status+\": \"+xhr.statusText); &#125;);&#125;);","tags":[{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"},{"name":"jQerry","slug":"jQerry","permalink":"http://seniorzhai.github.io/tags/jQerry/"},{"name":"前端","slug":"前端","permalink":"http://seniorzhai.github.io/tags/前端/"}]},{"title":"jQuery二识","date":"2015-03-31T05:21:31.000Z","path":"2015/03/31/jQuery二识/","text":"jQuery DOM操作DOM = Document Object Model(文档对象模型)jQuery提供了一系列与DOM相关的方法，这使访问和操作元素和属性变得容易 获取HTML元素获得内容 text() 设置或返回所选元素的文本内容 html() 设置或返回所选元素的内容(包括HTML标记) val() 设置或返回表单字段的值以上的三个都拥有回调函数，由两个参数：被选元素列表中当前元素的下标以及原始值 获取属性 attr() 获取属性值设置属性123$(\"button\").click(function()&#123; $(\"# w3s\").attr(\"href\",\"http://www.baidu.com/\");&#125;); 同事设置多个属性123456$(\"button\").click(function()&#123; $(\"# w3s\").attr(&#123; \"href\":\"http://www.sina.com.cn\", \"title\":\"Sina\" &#125;)&#125;) attr()也通过回调函数，包含两个参数：被选元素列表中当前元素的下标，以及原始值12345$(\"button\").click(function()&#123; $(\"# w3s\").attr(\"href\",function(i,origValue)&#123; return origValue + \"/jquery\"; &#125;);&#125;) 添加元素 append() 在被选元素的结尾插入内容 prepend() 在被选元素的开头插入内容 after() 在被选元素之后插入内容 before() 在被选元素之前插入内容1$(\"p\").addend(\"Some appended text.\") 删除元素 remove() 删除被选元素(以及子元素) empty() 从被选元素中删除子元素remove()方法可以接受一个参数，允许对删除元素进行过滤1$(\"p\").remove(\".italic\"); // 删除class=\"italic\"的所有&lt;p&gt;元素 获取并设置CSS类操作CSS addClass() 向所选元素添加一个或多个类 removeClass() 从被选元素删除一个或多个类 toggleClass() 对被选元素进行添加/删除类的切换操作 css() 设置或返回样式属性 1234567$(\"button\").click(function()&#123; $(\"h1,h2,p\").addClass(\"blue\"); $(\"div\").addClass(\"important\"); // $(\"div\").addClass(\"important blue\"); 添加多个类 $(\"div\").removeClass(\"blue\"); $(\"div\").toggleClass();&#125;) css()方法css(&quot;propertyname&quot;)123$(\"p\").css(\"background-color\");$(\"p\").css(\"background-color\",\"yellow\"); //设置属性$(\"p\").css(&#123;\"background-color\":\"yellow\",\"font-size\":\"200%\"&#125;); // 同时设置多个属性 尺寸 width() 设置或返回元素的宽度(不包含内边距，边框或外框) height() 设置或返回元素的高度(不包含内边距，边框或外框) innerWidth() 设置或返回元素的宽度(包含内边距) innerHeight() 设置或返回元素的高度(包含内边距) outerWidth() 设置或返回元素的宽度(包含内边距和边框) outerHeight() 设置或返回元素的高度(包含内边距和边框)","tags":[{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"},{"name":"jQerry","slug":"jQerry","permalink":"http://seniorzhai.github.io/tags/jQerry/"},{"name":"前端","slug":"前端","permalink":"http://seniorzhai.github.io/tags/前端/"}]},{"title":"掉渣天的图片加载库Fresco","date":"2015-03-31T02:51:28.000Z","path":"2015/03/31/掉渣天的图片加载库Fresco/","text":"开始123dependencies &#123; compile 'com.facebook.fresco:fresco:0.1.0+'&#125; 使用简单的下载网络图片 在Application中初始化1Fresco.initialize(context); 在XML中使用SimpleDraweeView，需要键入命名空间xmlns:fresco=&quot;http://schemas.android.com/apk/res-auto&quot;12345&lt;com.facebook.drawee.view.SimpleDraweeView android:id=\"@+id/my_image_view\" android:layout_width=\"20dp\" android:layout_height=\"20dp\" fresco:placeholderImage=\"@drawable/my_drawable\" /&gt; 加载1draweeView.setImageURL(\"http://site.com/uri\"); URLsFresco不支持相对路径，所有URL必须是绝对路径|类型|Scheme||:—|:—–||远程图片|http://,https://||本地文件|file://||ContentProvider|content://||asset目录下资源|asset://||res目录下资源|res://| 更多请见http://fresco-cn.org/","tags":[{"name":"图片加载","slug":"图片加载","permalink":"http://seniorzhai.github.io/tags/图片加载/"}]},{"title":"jQuery初识","date":"2015-03-30T12:15:28.000Z","path":"2015/03/30/jQuery初识/","text":"JQuery是一个JavaScript函数库，包含以下功能： HTML元素选取 HTML元素操作 CSS操作 HTML事件函数 JavaScript特效和动画 HTML DOM遍历和修改 AJAX UtiltiesjQuery安装1234&lt;head&gt; &lt;script src=\"jquery-1.10.2.min.js\" /&gt; &lt;!-- &lt;script src=\"http://libs.baidu.com/jquery/1.10.2/jquery.min.js\"&gt; --&gt;&lt;/head&gt; 语法jQuery语法是通过选取HTML元素，并对选取的元素执行某些操作 基础语法$(selector).action() 美元符定义jQuery 选取符(selector)查询和查找HTML元素 jQuery的action()执行元素的操作文档就绪事件123$(document).ready(function()&#123; // 为了防止文档在完全加载就绪之前运行jQuery代码&#125;); 简洁的写法可以是这样的：123$(function()&#123; //&#125;); 选择器jQuery选择器用于对HTML元素组或者单个元素进行操作基于元素的id、类、类型、属性、属性值等”查找”HTML元素所有选择器都以美元符开头：$() 基于元素名选取元素 12345$(function()&#123; $(\"button\").click(function()&#123; $(\"p\").hide(); &#125;)&#125;) 基于id选择 12345$(function()&#123; $(\"button\").click(function())&#123; $(\"# test\").hide(); &#125;&#125;) 基于class选择 12345$(function()&#123; $(\"button\").click(function()&#123; $(\".test\").hide(); &#125;);&#125;) 更多实例 语法 描述 $(“*”) 所有元素 $(this) 当前元素 $(“p.intro”) class为intro的&lt;p&gt;元素 $(“p:first”) 第一个&lt;p&gt;元素 $(“ul li:first” &lt;ul&gt;元素的第一个&lt;li&gt;元素 $(“ul li:first-child” 每一个&lt;ul&gt;元素的第一个&lt;li&gt;元素 $(“[href]”) 选取所有带href属性的元素 $(“a[target=’_blank’]”) 所有target属性不等于&quot;_blank&quot;的&lt;a&gt;元素 $(“a[target!=’_blank’]”) 选取所有 target 属性值不等于 &quot;_blank&quot;的 &lt;a&gt;元素 $(“:button”) 选取所有 type=”button” 的&lt;input&gt;元素和&lt;button&gt;元素 $(“tr:even”) 选取偶数位置的&lt;tr&gt;元素 $(“tr:odd”) 选取奇数位置的&lt;tr&gt;元素 jQuery事件 鼠标事件 键盘事件 表单事件 文档/窗口事件 click keypress submit load dblclick keydown change resize mouseenter keyup focus scroll mouseleave blur unload 常用事件 $(document).ready() 文档准备完毕 click() 按钮点击事件 dblclick() 双击元素事件 mouseenter() 当鼠标指针穿过元素时 mouseleave() 当鼠标离开元素时 mousedown() 当鼠标移动到元素上并按下鼠标时 mouseup() 当鼠标移动到元素上并松开鼠标时 hover() 模拟光标悬停事件 focus() 元素获得焦点事件 blur() 元素失去焦点事件 hide()和show()用于元素的隐藏和显示12$(selector).hide(speed,callback) //speed 可以使slow fast或毫秒用于规定隐藏/显示的速度$(selector).show(speed,callback) toggle()用于切换hide()和show()1$(selector).toggle(speed,callback) 淡入淡出效果 fadeIn() fadeOut() fadeToggle() fadeTo()1$(selector).fadeIn(speed,callback); fadeIn为淡入，fadeOut为淡出，fadeToggle()为切换fadeTo允许为给定的不透明度(值为0到1之间)1$(selector).fadeTo(speed,opacity,callback) 滑动效果123$(selector).slideDown(speed,callback) // 用于向下滑动元素$(selector).slideUp(speed,callback)$(selector).slideToggle(speed,callback) 自定义动画1$(selector).animate(&#123;params&#125;,speed,callback); params为定义形成动画的CSS属性123$(\"button\").click(function()&#123; $(\"div\").animate(&#123;left:'250px'&#125;);&#125;); 也可以同时操作多个属性12345678$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', opacity:'0.5', height:'150px', width:'150px' &#125;);&#125;); 使用相对值1234567$(\"button\").click(function()&#123; $(\"div\").animate(&#123; left:'250px', height:'+=150px', width:'+=150px' &#125;);&#125;); 使用预定值12345$(\"button\").click(function()&#123; $(\"div\").animate(&#123; height:'toggle' &#125;);&#125;); 使用队列1234567$(\"button\").click(function()&#123; var div=$(\"div\"); div.animate(&#123;height:'300px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'300px',opacity:'0.8'&#125;,\"slow\"); div.animate(&#123;height:'100px',opacity:'0.4'&#125;,\"slow\"); div.animate(&#123;width:'100px',opacity:'0.8'&#125;,\"slow\");&#125;); 停止动画stop()方法用于停止动画或效果$(selector).stop(stopAll,goToEnd)可选的stopAll指定是否应该清除动画队列，默认是false，即仅停止活动的动画，允许任何排入队列的动画向后执行可选的goToEnd参数指定是否立即完成当前动画，默认是false123$(\"# stop\").click(function()&#123; $(\"# pancel\").stop();&#125;);","tags":[{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"},{"name":"jQerry","slug":"jQerry","permalink":"http://seniorzhai.github.io/tags/jQerry/"},{"name":"前端","slug":"前端","permalink":"http://seniorzhai.github.io/tags/前端/"}]},{"title":"Android开发函数库caffeine","date":"2015-03-26T02:36:10.000Z","path":"2015/03/26/Android开发函数库caffeine/","text":"相信很多Android开发都有自己的函数库，来完成一些常用的操作，比如dpi操作、获取手机信息、文件操作等。caffeine是一个Android常用函数库，封装了大量常用但是冗长的函数。 使用 下载jar gradle compile &#39;com.percolate:caffeine:0.3.3&#39; 常用方法详情请见http://percolate.github.io/caffeine/javadoc/ ActivityUtils launchActivity public static void launchActivity(android.app.Activity context, java.lang.Class&lt;? extends android.app.Activity&gt; activity, boolean closeCurrentActivity, java.util.Map&lt;java.langString,java.lang.String&gt; params) context 为上下文 activity 进入的activity closeCurrentActivity 是否finish掉当前的Activity params 通过Bundle传递的参数 重载的方法有：launchActivity(android.app.Activity, Class, boolean, java.util.Map) getExtraString public static java.lang.String getExtraString(android.app.Activity context,java.lang.String key) 获取通过Bundle传入的参数 getExtraObject public static java.lang.Object getExtraObject(android.app.Activity context,java.lang.String key) 获取传入的对象 turnScreenOn public static void turnScreenOn(android.app.Activity context) 点亮屏幕 MiscUtils dpToPx public static int dpToPx(android.content.Context context,int dp) dp转px getVersionName public static java.lang.String getVersion(android.content.Context context) 获取versionName getVerionCode public static int getVersionCode(android.content.Context context) 获取versionCode getApplicationName public static java.lang.String getApplicationName(android.content.Context context) 获取application的名字 isValidEmail public static final boolean isValidEmail(java.lang.String email) 判断email是否符合格式 isVlidPhoneNumber public static final boolean isValidPhoneNumber(java.lang.String number) 判断是否符合电话号码 isValidURL public static final boolean isValidURL(java.lang.String url) 判断是符合WEB_URL PhoneUtils isRotationEnable public static boolean isRotationEnabled(android.content.Context context) 检查用户是否关闭了自动旋转 isNetworkAvailable public static boolean isNetworkAvailable(android.content.Context context) 判断网络是否可用 isConnectedWifi public static boolean isConnectedWifi(android.content.Context context) 判断是否连接Wifi isConnectedMobile public static boolean isConnectedMobile(android.content.Context context) 判断是否连接手机网络","tags":[{"name":"常用","slug":"常用","permalink":"http://seniorzhai.github.io/tags/常用/"},{"name":"基础","slug":"基础","permalink":"http://seniorzhai.github.io/tags/基础/"},{"name":"函数","slug":"函数","permalink":"http://seniorzhai.github.io/tags/函数/"}]},{"title":"Selector","date":"2015-03-20T08:02:33.000Z","path":"2015/03/20/Selector/","text":"基本状态为常态normal、点击pressed、焦点focused、选中selected1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 默认时的背景图片--&gt; &lt;item android:drawable=\"@drawable/pic1\" /&gt; &lt;!-- 没有焦点时的背景图片--&gt; &lt;item android:state_window_focused=\"false\" android:drawable=\"@drawable/pic1\" /&gt; &lt;!-- 非触摸模式下获得焦点并单击时的背景图片--&gt; &lt;item android:state_focused=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/pic2\" /&gt; &lt;!-- 触摸模式下单击时的背景图片--&gt; &lt;item android:state_focused=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/pic3\" /&gt; &lt;!--选中时的图片背景--&gt; &lt;item android:state_selected=\"true\" android:drawable=\"@drawable/pic4\" /&gt; &lt;!--获得焦点时的图片背景--&gt; &lt;item android:state_focused=\"true\" android:drawable=\"@drawable/pic5\" /&gt;&lt;/selector&gt;","tags":[{"name":"selector","slug":"selector","permalink":"http://seniorzhai.github.io/tags/selector/"}]},{"title":"500 px模糊控件","date":"2015-03-19T06:32:20.000Z","path":"2015/03/19/500-px模糊控件/","text":"500px开源了一款模糊View使用12blurringView.setBlurredView(blurredView); // 设置需要覆盖的ViewblurringView.invalidate(); // 改变时调用","tags":[{"name":"blur","slug":"blur","permalink":"http://seniorzhai.github.io/tags/blur/"},{"name":"模糊","slug":"模糊","permalink":"http://seniorzhai.github.io/tags/模糊/"},{"name":"毛玻璃","slug":"毛玻璃","permalink":"http://seniorzhai.github.io/tags/毛玻璃/"}]},{"title":"AndroidStudio上使用NDK","date":"2015-03-19T05:29:22.000Z","path":"2015/03/19/AndroidStudio上使用NDK/","text":"准备工作 下载NDK 配置环境变量，在~/.bash_profile文件下添加123# 根据自己存放的位置指定export NDK_ROOT=/Users/UserName/Documents/Android/android-ndk-r10export PATH=$NDK_ROOT:$PATH 新建一个项目创建一个MathKit类1234567public class MathKit &#123; public static native int square(int num); static &#123; System.loadLibrary(\"JniDemo\"); &#125;&#125; 在命令行中进入目录，使用javah命令生成.h文件将.h文件存放至jni文件夹下，并新建.cpp文件根据头文件，编写cpp文件1234567# include &lt;com_zoe_ndkdemo_jni_MathKit.h&gt;JNIEXPORT jint JNICALL Java_com_zoe_ndkdemo_jni_MathKit_square (JNIEnv * env, jclass cls, jint num) &#123; return num * num; &#125; 在local.properties文件添加ndk路径1ndk.dir=/Users/UserName/Documents/Android/android-ndk-r10 在app项目中的build.gradle中的defaultConfig中添加123ndk &#123; moduleName &quot;JniDemo&quot;&#125; 之后就可以在代码中调用123456789private TextView textView;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = (TextView) findViewById(R.id.text); textView.setText(\"2*2=\"+ MathKit.square(2));&#125; 示例：https://github.com/SeniorZhai/NdkDemo","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"ndk","slug":"ndk","permalink":"http://seniorzhai.github.io/tags/ndk/"},{"name":"mac","slug":"mac","permalink":"http://seniorzhai.github.io/tags/mac/"}]},{"title":"理解StrongReferce、SoftReference、WeakReference、PhantomReference","date":"2015-03-18T08:22:58.000Z","path":"2015/03/18/理解StrongReferce、SoftReference、WeakReference、PhantomReference/","text":"JDK 1.2版本引入了强、软、弱、虚引用的概念 StrongReference 修饰的对象，JVM宁愿抛出OOM也不回收对象 SoftReference 内存不足时，才会回收对象 WeakReference 无论内容是否足够，垃圾回收扫描到，他就会被回收123456789101112131415@Test public void weakReference() &#123; Object referent = new Object(); WeakReference&lt;Object&gt; weakRerference = new WeakReference&lt;Object&gt;(referent); assertSame(referent, weakRerference.get()); referent = null; System.gc(); /** * 一旦没有指向 referent 的强引用, weak reference 在 GC 后会被自动回收 */ assertNull(weakRerference.get()); &#125; PhantomReference 相对于完全没有引用","tags":[{"name":"引用","slug":"引用","permalink":"http://seniorzhai.github.io/tags/引用/"}]},{"title":"Android Shape的使用","date":"2015-03-17T07:20:02.000Z","path":"2015/03/17/Android-Shape的使用/","text":"shape android:shape[“rectagle”|”oval”|”line”|”ring”] rectagle 矩形 oval椭圆 line水平直线 ring环形 gradient 渐变 android:startColor 起始颜色 android:endColor 结束颜色 android:angle 渐变角度，0从上到下，90从左到右，数值必须为45的倍数，默认为0 android:type 渐变样式 line线性渐变，radial环形渐变，sweep扫描渐变 solid 填充颜色 android:color 填充颜色 stroke 描边 android:width 描边的宽度 android:color 描边的颜色 android:dashWidth 间隔线的宽度 android:dashGap 间隔线的间隔 corners 圆角 android:radius 圆角的半径，值越大越圆 android:topRightRadius 右上角半径 android:bottomLeftRadius 左下角半径 android:topLeftRadius 右上角半径 android:bottomRightRadius 右下角半径","tags":[{"name":"shape","slug":"shape","permalink":"http://seniorzhai.github.io/tags/shape/"}]},{"title":"androidannotations(二)","date":"2015-03-16T13:30:45.000Z","path":"2015/03/16/androidannotations(二)/","text":"androidannotations是一款Android注入框架，可以方便我们编程，减少代码量(变相减少了错误的可能)，让我们可以更多的把精力放在逻辑处理上。 事件监听点击事件12345678910111213141516171819@Click(R.id.myButton)void myClick() &#123; // ...&#125;@Clickvoid anotherButton() &#123; // ...&#125;@Clickvoid yetAnotherButton(View clickedView) &#123; // ...&#125;@Click(&#123;R.id.myButton,R.id.myOtherButton&#125;) void handlesTwoButtons()&#123; // ...&#125; 其他事件 长按 @LongClick 触摸 @Touch","tags":[{"name":"注入","slug":"注入","permalink":"http://seniorzhai.github.io/tags/注入/"}]},{"title":"TimingLogger","date":"2015-03-11T12:44:31.000Z","path":"2015/03/11/TimingLogger/","text":"妈妈再也不用担心我分析用时时间了123456TimingLogger timings = new TimingLogger(TAG,\"methodA\");// ...timings.addSplit(\"work A\");// ...timings.addSplit(\"work B\");timings.dumpToLog(); 当调用dumpToLog方法时会打印Log1234D/TAG ( 3459): methodA: beginD/TAG ( 3459): methodA: 9 ms, work AD/TAG ( 3459): methodA: 1 ms, work BD/TAG ( 3459): methodA: end, 16 ms","tags":[{"name":"Log","slug":"Log","permalink":"http://seniorzhai.github.io/tags/Log/"},{"name":"用时","slug":"用时","permalink":"http://seniorzhai.github.io/tags/用时/"}]},{"title":"Git之Bug分支","date":"2015-03-09T13:15:52.000Z","path":"2015/03/09/Git之Bug分支/","text":"在开发中常常遇到这种情况——你正在指尖飞舞，码代码ing，这个时候QA来了个BUG。这个时候，工作区里还有很多ing的代码，没有提交，你又需要创建分支来解决BUG。这个时候需要git stash命令来拯救你的代码这条命令可以把当前工作现场储存起来，等以后恢复现场后继续工作储存后，打出分支解决问题，完成后，合并分支(git merge)，再删除分支(git branch -d)之后用git stash list查看储存起来的工作现场这个时候可以使用下面两个方法恢复工作现场： git stash apply恢复，git stach drop删除工作现场 git stash pop恢复","tags":[{"name":"Git","slug":"Git","permalink":"http://seniorzhai.github.io/tags/Git/"},{"name":"分支","slug":"分支","permalink":"http://seniorzhai.github.io/tags/分支/"}]},{"title":"MongoDB常用命令","date":"2015-03-05T04:27:33.000Z","path":"2015/03/05/MongoDB常用命令/","text":"启动MongoDB指定数据库路径启动1mongod --dbpath 添加--port也可以指定端口 数据库操作 切换、创建数据库 use yourDB 查询所有数据库 show dbs 删除当前使用数据库 db.dropDatabase() 从指定主机上克隆数据库 db.cloneDatabase(&quot;127.0.0.1&quot;) 从指定的机器复制数据库数据到某个数据库 db.copyDatabase(&quot;mydb&quot;,&quot;temp&quot;,&quot;127.0.0.1&quot;) 修复数据库 db.repairDatabase() 查看当前使用的数据库 db.getName或db 显示当前数据库状态 db.stats() 当前db版本 db.version() 查看当前数据库机器地址 db.getMongo() 集合操作 创建集合 db.createCollection(&#39;collName&#39;,{size:20,capped:5,max:100}) 创建成功会显示{&quot;ok&quot;:1} 得到指定名称的集合 db.getCollection(&quot;account&quot;) 得到当前数据库所有集合 db.getCollectionNames() 得到当前数据库所有集合索引的状态 db.printCollectionStats() 用户相关 添加用户 db.addUser(&quot;name&quot;)和db.addUser(&quot;userName&quot;,&quot;pwd123&quot;,true) 设置密码、是否只读 数据库认证 db.auth(&quot;userName&quot;,&quot;123123&quot;) 显示当前所用用户 show users 删除用户 db.removeUser(&quot;userName&quot;) 集合查询 查询所用记录 db.userInfo.find() 默认每页显示20条记录 查询去掉后的当前集合中的某列的重复数据 db.userInfo.disinct(&quot;name&quot;) 查询(等于) db.userInfo.find({&quot;gae&quot;:22}) 查询age==22的集合 查询(大于) db.userInfo.find({&quot;age&quot;:{$gt:22}}) 小于$lt 大于等于$glt 小于等于$lte 包含 db.userInfo.find({name:/mongo/}) 开头 db.userInfo.find({name:/^mongo/}) 查询指定列name、age db.userInfo.find({},{name:1,age:1}) 查询指定数据 db.userInfo.find({age:{$gt25}},{name:1,age:1}) 排序 db.userInfo.find().sort({age:1}) 降序 db.userInfo.find().sort({age:-1}) 查询前5条数据 db.userInfo.find().limit(5) 查询10条以后的数据 db.userInfo.find().skip(10) 查询5-10条数据 db.userInfo.find().limit(10).skip(5) 与查询 db.userInfo.find({$or:[{age:22},{age:25}]}) 查询第一条数据 db.userInfo.findOne() 查询集合的条数 db.userInfo.find().count() 按某列进行排序 db.userInfo.find({sex:{$exists:true}}).count()","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://seniorzhai.github.io/tags/MongoDB/"}]},{"title":"使用Mongoose","date":"2015-03-05T03:11:52.000Z","path":"2015/03/05/使用Mongoose/","text":"Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。 安装及引用 安装 1npm install mongoose 引用mongoose 1var mongoose = require(\"mongoose\"); 使用mongoose链接数据库 1var db = mongoose(\"mongodb://user:pass@localhost:port/database\"); 示例 12345678var mongoose = require(\"mongoose\");var db = mongoose.connect(\"mongodb://127.0.0.1:27017/test\");db.connection.on(\"error\", function (error) &#123; console.log(\"数据库连接失败：\" + error);&#125;);db.connection.on(\"open\", function () &#123; console.log(\"------数据库连接成功！------\");&#125;); MongoDB基础MongoDB——是一个对象数据库，没有表和行等概念，没有固定的模式和结构，所有的数据以Document的形式存储，多个Document可以组成一个Collection，多个集合组成了数据库。Document(文档)是MongoDB的核心概念，是键值对的有序集合，在JS中表示成对象，他是MongoDB的基本单元，类似于关系型数据库中的行。Collection(集合)则更像是表的概念。 SchemaSchema —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。定义12345678var mongoose = require(\"mongoose\")var TestSchema = new mongoose.Schema(&#123; name : &#123;type:String&#125;, age : &#123;type:Number,default:0&#125;, time : &#123;type:Date,default:Date.now&#125;, emial : &#123;type:String,default:''&#125;&#125;); 基本属性类型有：字符串、日期型、数值型、布尔型(Boolean)、null、数组、内嵌文档等 ModelModel —— 由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类。1234var db = mongoose.connect(\"mongodb://127.0.0.1:27017/test\");// 通过Schema创建Modelvar TestModel = db.model(\"test1\", TestSchema); 数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后在保存数据。 EntityEntity —— 由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性。1234567var TestEntity = new TestModel(&#123; name : \"Lenka\", age : 36, email : \"lenka@qq.com\"&#125;);console.log(TestEntity.name); // Lenkaconsole.log(TestEntity.age); // 36 完整示例123456789101112131415161718192021var mongoose = require(\"mongoose\");var db = mongoose.connect(\"mongodb://127.0.0.1:27017/test\");var TestSchema = new mongoose.Schema(&#123; name : &#123;type:String&#125;, age : &#123;type:Number,default:0&#125;, email : &#123;type:String&#125;, time : &#123;type:Date,default:Date.now&#125;&#125;);var TestModel = db.model(\"test1\",TestSchema);var TestEntity = new TestModel(&#123; name:'helloworld', age:28, emial:'helloworld@qq.com'&#125;);TestEntity.save(function(err,doc)&#123; if(error)&#123; console.log(\"error :\" + error); &#125; else &#123; console.log(doc); &#125;&#125;);","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://seniorzhai.github.io/tags/MongoDB/"},{"name":"Mongoose","slug":"Mongoose","permalink":"http://seniorzhai.github.io/tags/Mongoose/"}]},{"title":"npm镜像","date":"2015-03-05T01:25:33.000Z","path":"2015/03/05/npm镜像/","text":"npm全称Node Package Manager，是node.js的模块依赖管理工具，由于npm的源在国外，所以国内使用起来————你懂的。下面是一部分国内优秀的npm镜像资源 国内NPM镜像 淘宝npm镜像 搜索地址：http://npm.taobao.org registry：http://registry.npm.taobao.org cnpmjs镜像 搜索地址：http://cnpmjs.org registry：http://r.cnpmjs.org 使用 临时使用 1npm --registry https://registry.npm.taobao.org install express 持久是欧诺个 123npm config set registry http://registry.npm.taobao.orgnpm config get registry ## 验证查看npm info express ## 验证 通过cnpm使用(强烈建议使用) 123npm install -g cnpm --registry=https://registry.npm.taobao.org## 使用cnpm install express","tags":[{"name":"node","slug":"node","permalink":"http://seniorzhai.github.io/tags/node/"},{"name":"npm","slug":"npm","permalink":"http://seniorzhai.github.io/tags/npm/"},{"name":"镜像","slug":"镜像","permalink":"http://seniorzhai.github.io/tags/镜像/"}]},{"title":"部署Meteor","date":"2015-03-02T08:47:22.000Z","path":"2015/03/02/部署Meteor/","text":"部署在Meteor1meteor deploy myapp.meteor.com","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"},{"name":"meteor","slug":"meteor","permalink":"http://seniorzhai.github.io/tags/meteor/"},{"name":"web app","slug":"web-app","permalink":"http://seniorzhai.github.io/tags/web-app/"}]},{"title":"androidannotations(一)","date":"2015-02-28T13:30:45.000Z","path":"2015/02/28/androidannotations(一)/","text":"androidannotations是一款Android注入框架，可以方便我们编程，减少代码量(变相减少了错误的可能)，让我们可以更多的把精力放在逻辑处理上。本文API介绍取至https://github.com/excilys/androidannotations/wiki/Cookbook 特征 依赖注入 简单的后台任务模型 事件绑定 REST 配置在AS中，需要在项目的build.gradle中进行加入如下配置（有注释部分）1234567891011121314151617181920212223242526272829303132apply plugin: &apos;com.android.application&apos;apply plugin: &apos;android-apt&apos;buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.0.0&apos; // 使用android-apt classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.4&apos; &#125;&#125;repositories &#123; mavenCentral() mavenLocal()&#125;dependencies &#123; def AAVersion = &apos;3.2&apos; // 设置版本 apt &quot;org.androidannotations:androidannotations:$AAVersion&quot; compile &quot;org.androidannotations:androidannotations-api:$AAVersion&quot;&#125;apt &#123; arguments &#123; androidManifestFile variant.outputs[0].processResources.manifestFile resourcePackageName &apos;com.myproject.name&apos; // 指定包名 &#125;&#125; 使用 基本使用示例1234567891011121314151617181920212223242526272829@EActivity(R.layout.translate) // 设置布局文件public class TranslateActivity extends Activity &#123; @ViewById // 注入 等同于 findViewById(R.id.textInput) EditText textInput; @ViewById(R.id.myTextView) TextView result; @AnimationRes // 获取 anroid.R.anim.fade_in Animation fadeIn; @Click // 设置R.id.doTranslate的监听 void doTranslate() &#123; translateInBackground(textInput.getText().toString()); &#125; @Background // 后台线程 void translateInBackground(String textToTranslate) &#123; String translatedText = callGoogleTranslate(textToTranslate); showResult(translatedText); &#125; @UiThread // UI线程 void showResult(String translatedText) &#123; result.setText(translatedText); result.startAnimation(fadeIn); &#125;&#125; Activity @EActivity注入Activity1234@EActivity(R.layout.main)public class MyActivity extends Activity &#123; &#125; 也可以不注入12345678@EActivitypublic class MyListActivity extends ListActivity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); &#125;&#125; 注：使用Androidannotations注入的Activity在AndroidManifest.xml中配置时，名字后需要加上_，如MainActivity则为.MainActivity_ Fragment @EFragment1234@EFragmentpublic class MyFragment extends Fragment &#123; &#125; 在布局中需要使用MyFragment_表示123456789101112&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"horizontal\" &gt; &lt;fragment android:id=\"@+id/myFragment\" android:name=\"com.company.MyFragment_\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" /&gt;&lt;/LinearLayout&gt; 在程序中使用1MyFragment fragment = new MyFragment_(); 也可以注入布局1234@EFragment(R.layout.my_custom_layout)public class MyFragment extends ListFragment &#123; // R.layout.my_custom_layout will be injected&#125; 获取Fragment时1234567891011121314@EActivity(R.layout.fragments)public class MyFragmentActivity extends FragmentActivity &#123; @FragmentById MyFragment myFragment; @FragmentById(R.id.myFragment) MyFragment myFragment2; @FragmentByTag MyFragment myFragmentTag; @FragmentByTag(\"myFragmentTag\") MyFragment myFragmentTag2;&#125; 自定义控件12345678910@EViewpublic class CustomButton extends Button &#123; @App MyApplication application; @StringRes public CustomButton(Context context,AttributeSet attrs) &#123; super.(context,attrs); &#125;&#125; 在布局中使用时12345&lt;!-- ... --&gt;&lt;com.myapp.view.CustomButton_ android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; 自定义ViewGroupslayout12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;ImageView android:id=\"@+id/image\" android:layout_alignParentRight=\"true\" android:layout_alignBottom=\"@+id/title\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/check\" /&gt; &lt;TextView android:id=\"@+id/title\" android:layout_toLeftOf=\"@+id/image\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:textColor=\"@android:color/white\" android:textSize=\"12pt\" /&gt; &lt;TextView android:id=\"@+id/subtitle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@+id/title\" android:textColor=\"# FFdedede\" android:textSize=\"10pt\" /&gt;&lt;/merge&gt; Java代码1234567891011121314@EViewGroup(R.layout.title_with_subtitle)public class TitleWithSubtitle extends RelativeLayout &#123; @ViewById protected TextView title,subtitle; public TitleWithSubtitle(Context context,AttributeSet attrs) &#123; super(context,attrs); &#125; public void setTexts(String titleText,String subTitleText) &#123; title.setText(titleText); subtitle.setText(subTitleText); &#125;&#125; 使用12345&lt;com.myapp.viewgroup.TitleWithSubtitle_ android:id=\"@+id/firstTitle\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; Service12345678910111213141516171819202122232425262728@EServicepublic class MyService extends IntentService &#123; @SystemService NotificationManager notificationManager; @Bean MyEnhancedDatastore datastore; @RestService MyRestClient = myRestClient; @OrmLiteDao(helper = DatabaseHelper.class,model = User.class) UserDao userDao; public MyService() &#123; super(MyService.class.getSimpleName); &#125; @Override proteced void onHandleIntent(Intent intent)&#123; showTast(); &#125; @UiThread void showToast() &#123; Toast.makeText(getApplicationContext(),\"Hi~\",Toast.LENGTH_LONG).show(); &#125;&#125; 对于IntentService还可以设置一些操作1234@ServiceActionvoid mySimpleAction(String param) &#123; //...&#125; 通过MyIntentService_.intent(getApplication()).myAction(&quot;test&quot;).start()使用 获取资源12345678910111213141516171819202122232425// String@StringRes(R.string.hello)String myHelloString;@StringResString hello;// Color@ColorRes(R.color.backgroundColor)int someColor;@ColorResint backgoundColor;// animation@AnimationRes(R.anim.fadein)Animation fadein;@AnimationResAnimation fadein;// DimensionRes@DimensionRes(R.dimen.fontsize)float fontSizeDimension;@DimensionResfloat fontsize;// 换算成PX@DimensionPixelOffsetRes(R.sting.fontsize)int fontSizeDimension;@DimensionPixelOffsetResint fontsize; 其他 @BooleanRes @ColorStateListRes @DrawableRes @IntArrayRes @IntegerRes @LayoutRes @MovieRes @TextRes @TextArrayRes @StringArrayRes Intent1234567891011121314151617@EActivity public class MyActivity extends Activity &#123; @Extra(\"myStringExtra\") // 也可以胜利 String myMessage; @Extra(\"myDateExtra\") Date myDate = new Date(); @Override protected void onNewIntent(Intent intent) &#123; // 再次注入时 &#125; @AfterExtras public void doSomethingAfterExtrasInjection() &#123; // &#125;&#125;","tags":[{"name":"注入","slug":"注入","permalink":"http://seniorzhai.github.io/tags/注入/"}]},{"title":"Android开发贴士","date":"2015-02-28T02:26:01.000Z","path":"2015/02/28/Android开发贴士/","text":"转至http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/Activity.startActivities())——对于从app流的中部启动会非常好。 TextUtils.isEmpty())——一个普遍适用的简单工具类。 Html.fromHtml())——格式化Html的快速方法，本人认为它也不是非常快，所以我不是经常用它（我说不经常用它是为了重点突出这句话：请多手动构建Spannable来替换Html.fromHtml），但是它对渲染从web上获取的文字还是很不错的。 TextView.setError()——在验证用户输入的时候用户体验很不错。 Build.VERSION_CODES——它不仅仅描述了版本号，还总结了各Android版本的不同特性。 Log.getStackTraceString())——方便的日志工具。 LayoutInflater.from()——简化一系列冗长的getSystemService()调用的简单工具。 ViewConfiguration.getScaledTouchSlop()——使用ViewConfiguration中提供的值以保证所有触摸的交互都是统一的。 PhoneNumberUtils.convertKeypadLettersToDigits——使得处理电话号码更方便，很多人都只提供字母，而不是数字。 Context.getCacheDir()——使用系统提供的缓存目录进行数据缓存，操作非常简单不过很多人不知道怎么使用。 ArgbEvaluators——处理颜色的渐变。就像Chris Banes说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。 ContextThemeWrapper——方便在运行过程中更改主题。 Space——轻量级的视图组件，可以跳过绘制的过程，对于需要占位符的任何场景来说都是很棒的。 ValueAnimator.reverse()——可以顺畅地取消动画效果，很赞。 DateUtils.formatDateTime()——提供区域格式化时间/日期字符串的一站式服务。 AlarmManager.setInexactRepeating)——通过闹铃分组的方式来节省电量，即使你只调用一个alarm实例，它仍然比较好用（可以确保在使用完毕时自动调用AlarmManager.cancel()。 Formatter.formatFileSize())——一个区域化的文件大小格式化工具。 ActionBar.hide()) /.show())——可以在actionBar显示或者隐藏的时候进行动画展示。可以在切换到全屏的时候更优雅。 Linkify.addLinks())——可以控制在Text上添加链接。 StaticLayout——在自定义View中渲染文字的时候很实用。 Activity.onBackPressed())——方便控制返回按钮，在需要自定义返回键的操作时候，可以用到。 GestureDetector——可以监听动作事件和相关的监听器事件（点击，滚动，滑动等）。比自己实现系统的一些动作事件更简单。 DrawFilter——可以让你操作Canvas，即使没有调用draw方法。例如，可以在创建自定义View的时候设置一个DrawFilter，给父View里面的所有View设置反别名。 ActivityManager.getMemoryClass())——可以让你清楚知道设备还剩多少内存。在计算怎么设置缓存大小的时候就很有用。 SystemClock.sleep())——这个方法在保证一定时间的sleep时很方便，通常我用来进行debug和模拟网络延时。 ViewStub——它是一个初始化不做任何事情的View，但是之后可以载入一个布局文件。在慢加载View中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。 DisplayMetrics.density——通过这个方法可以获取屏幕的密度，很多时候需要去掉系统自动缩放精度的功能，但是有时候在控制的时候也很有用（尤其是在自定义View的时候）。 Pair.create())——方便构建类和构造器的方法。 UrlQuerySanitizer——使用这个工具可以方便对URL进行检查。 Fragment.setArguments——因为在构建Fragment的时候不能加参数，所以这是个很好的东西，可以在创建Fragment之前设置参数（即使在configuration改变的时候仍然会导致销毁/重建）。 DialogFragment.setShowsDialog()——这是一个很巧妙的方式，DialogFragment可以作为正常的Fragment显示！这里可以让Fragment承担双重任务。我通常在创建Fragment的时候把onCreateView()和onCreateDialog()都加上，就可以创建一个具有双重目的的Fragment。 FragmentManager.enableDebugLogging()——在需要观察Fragment状态的时候会有帮助。 LocalBroadcastManager——这个会比全局的broadcast更加安全，简单，快速。像otto这样的Event buses机制对你的应用场景更加有用。 PhoneNumberUtils.formatNumber()——顾名思义，这是对数字进行格式化操作的时候用的。 Region.op()——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。 Application.registerActivityLifecycleCallbacks——虽然缺少官方文档解释，不过我想它就是注册Activity的生命周期的一些回调方法（顾名思义），就是一个方便的工具。 versionNameSuffix——这个gradle设置可以让你在基于不同构建类型的manifest中修改版本名这个属性，例如，如果需要在在debug版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是debug版还是release版。 CursorJoiner——如果你是只使用一个数据库的话，使用SQL中的join就可以了，但是如果收到的数据是来自两个独立的ContentProvider，那么CursorJoiner就很实用了。 Genymotion——一个非常快的Android模拟器，本人一直在用。 -nodpi——在没有特别定义的情况下，很多修饰符（-mdpi，-hdpi，-xdpi等等）都会默认自动缩放assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。 BroadcastRecevier.setDebugUnregister()——又一个方便的调试工具。 Activity.recreate()——强制让Activity重建。 PackageManager.checkSignatures()——如果同时安装了两个app的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的app。 Activity.isChangingConfigurations()——如果在Activity中configuration会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。 SearchRecentSuggestionsProvider——可以创建最近提示效果的provider，是一个简单快速的方法。 ViewTreeObserver——这是一个很棒的工具。可以进入到VIew里面，并监控View结构的各种状态，通常我都用来做View的测量操作（自定义视图中经常用到）。 org.gradle.daemon=true——这句话可以帮助减少Gradle构建的时间，仅在命令行编译的时候用到，因为Android Studio已经这样使用了。 DatabaseUtils——一个包含各种数据库操作的使用工具。 android:weightSum (LinearLayout)——如果想使用layout weights，但是却不想填充整个LinearLayout的话，就可以用weightSum来定义总的weight大小。 android:duplicateParentState (View)——此方法可以使得子View可以复制父View的状态。比如如果一个ViewGroup是可点击的，那么可以用这个方法在它被点击的时候让它的子View都改变状态。 android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么ViewGroup的子View在绘制的时候会超出它的范围，在做动画的时候需要用到。 android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在ScrollView中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。 android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在Drawable具有多种状态的时候，可以定义它展示前的淡入淡出效果。 android:scaleType (ImageView)——定义在ImageView中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。 ——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个ViewGroup，对于自定义ViewGroup的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。 AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。 ViewDragHelper ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，DrawerLayout就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的优秀文章。 PopupWindow——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。 Actionbar.getThemrContext())——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。 ThumbnailUtils——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。译者注：该API从V8才开始支持。 Context.getExternalFilesDir())————申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。译者注：该API从V8才开始支持。 SparseArray——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。 PackageManager.setComponentEnabledSetting())——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。 SQLiteDatabase.yieldIfContendedSafely())——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。 Environment.getExternalStoragePublicDirectory())——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。 View.generateViewId())——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。 ActivityManager.clearApplicationUserData())—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。 Context.createConfigurationContext()) ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。 ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。 AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如 GRAVITY_DEATH_STAR_I）。不过，都不像这个这样，这个确实有用。译者注：该API从V11才开始支持。 ViewParent.requestDisallowInterceptTouchEvent() ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，这个演讲会令你惊叹不已。）","tags":[{"name":"Tips","slug":"Tips","permalink":"http://seniorzhai.github.io/tags/Tips/"}]},{"title":"AndroidStudio图标插件","date":"2015-02-28T01:34:56.000Z","path":"2015/02/28/AndroidStudio图标插件/","text":"Android Material Design Icon Generator Plugin是一款帮助我们设置Material风格图标的插件 使用 安装 下载MaterialDesignIconGeneratorPlugin.jar 在AS中选择Preference &gt; Plugins &gt; Install plugin from disk...安装既可 也可以通过Preference &gt; Plugins &gt; Browse repositories在线安装","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"Material","slug":"Material","permalink":"http://seniorzhai.github.io/tags/Material/"},{"name":"icon","slug":"icon","permalink":"http://seniorzhai.github.io/tags/icon/"}]},{"title":"NanoTasks","date":"2015-02-27T03:25:57.000Z","path":"2015/02/27/NanoTasks/","text":"NanoTasks是一款轻量级的Android异步任务工具类，是AsyncTask的替代品。 导入依赖1compile 'com.fabiendevos:nanotasks:1.0.0' 使用123456789101112131415Tasks.executeInBackground(context, new BackgroundWork&lt;Data&gt;() &#123; @Override public Data doInBackground() throws Exception &#123; return fetchData(); // 费时操作 &#125;&#125;, new Completion&lt;Data&gt;() &#123; @Override public void onSuccess(Context context, Data result) &#123; display(result); // 成功：显示结果 &#125; @Override public void onError(Context context, Exception e) &#123; showError(e); // 失败：处理错误 &#125;&#125;);","tags":[{"name":"异步","slug":"异步","permalink":"http://seniorzhai.github.io/tags/异步/"},{"name":"Async","slug":"Async","permalink":"http://seniorzhai.github.io/tags/Async/"}]},{"title":"Meteor初识","date":"2015-02-25T08:36:35.000Z","path":"2015/02/25/Meteor初识/","text":"Meteor是一个强大的Web APP框架，基础框架是Node.JS+MongoDB 基础下载安装1curl https://install.meteor.com | /bin/sh 创建项目1meteor create try-meteor 启动项目12cd try-meteormeteor 配置开发移动端安装移动端SDK第一次需要安装SDK12meteor install-sdk androidmeteor install-sdk ios Anroid on Mac需要以下环境 JDK HAXM Android SDK meteor install-sdk android配置项目12meteor add-platform androidmeteor add-platform ios 模拟器运行12meteor run androidmeteor run ios 设备上运行12meteor run android-devicemeteor run ios-device Demo创建项目1meteor create MeteorDemo 试运行12cd MeteorDemometeor 在浏览器中进入localhost:3000 值得一提的是Meteor是热启动的，只要启动后，任何修改都是立即显示 PSWeb技术栈 LAMP L Linux A Apache M MySQL P PHP MEAN M MongoDB E Express.js A Angular.js N Node.js","tags":[{"name":"app","slug":"app","permalink":"http://seniorzhai.github.io/tags/app/"},{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"},{"name":"meteor","slug":"meteor","permalink":"http://seniorzhai.github.io/tags/meteor/"},{"name":"web","slug":"web","permalink":"http://seniorzhai.github.io/tags/web/"}]},{"title":"JS中对象的处理","date":"2015-02-25T05:58:47.000Z","path":"2015/02/25/JS中对象的处理/","text":"单个对象123456var obj = &#123; name: 'Zoe', describe: function() &#123; return 'Person named ' + this.name; &#125;&#125;; 使用时1234obj.name; // Zoeobj.name = 'Zhai'; // 赋值obj.age = 22; // 自动创建obj.describe(); // Person named Zhai; in操作符可以用来检测一个属性是否存在12'age' in obj; // true'foo' in obj; // false，不存在的属性为undefined值 delete操作符可以用来删除一个属性12delete obj.age;obj.age; //undefined 构造函数除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：如果通过new操作符调用，他们会变为构造函数，对象的工厂。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如：123456789// 设置实例数据function Point(x, y) &#123; this.x = x; this.y = y;&#125;// 方法Point.prototype.dist = function () &#123; return Math.sqrt(this.x*this.x + this.y*this.y);&#125;;","tags":[{"name":"对象","slug":"对象","permalink":"http://seniorzhai.github.io/tags/对象/"},{"name":"继承","slug":"继承","permalink":"http://seniorzhai.github.io/tags/继承/"}]},{"title":"typeof和instanceof","date":"2015-02-25T05:51:49.000Z","path":"2015/02/25/typeof和instanceof/","text":"typeof和instanceof都可以用来将值分类，typeof主要用于原始值，instanceof主要用于对象。 typeof使用方法1typeof &lt;value&gt; typeof返回描述value’数据类型’的字符串 undefined未定义 boolean布尔值 string字符串 number数组 object对象或者null function函数1234typeof true // 'boolean'typeof 'abc' // 'string'typeof &#123;&#125; // 'object'typeof [] // 'object' 详情对应下表|操作数|结果||:—|:—||undefined|’undefined’||null|’object’||Boolean value|’boolean’||Number value|’number’||String value|’string’||Function|’function’||All other value|’object’| instanceof判断变量是否属于某个类型123456value instanceof &lt;Constr&gt;var b = new Bar();b instanceof Bar; // true&#123;&#125; instanceof Object; // true[] instanceof Array; // true[] instanceof Object; // true","tags":[{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"}]},{"title":"SelectorChapek插件","date":"2015-02-13T06:08:18.000Z","path":"2015/02/13/SelectorChapek插件/","text":"SelectorChapek是一款帮助我们快速完成Selector的AndroidStudio插件 安装 选择Preferences→Plugins→Browse repositories搜索SelectorChapek安装 下载并在Preferences→Plugins→Install plugin from disk选择安装 使用 在资源文件夹上右击，如drawable-xhdpi 选择Generate Android Selectors selectors文件会自动生成在drawable文件夹下 命名规则为了插件的正常运行，资源文件需要正确的命名，该插件支持.png和.9.png文件的识别 文件后缀 状态 _normal (default_state) _pressed state_pressed _focused state_focused _disabled state_enabled(false) _checked state_checked _selected state_selected _hovered state_hovered _checkable state_checkable _activated state_acticated _windowfocused state_window_focused","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"}]},{"title":"Handler详解","date":"2015-02-13T01:51:49.000Z","path":"2015/02/13/Handler详解/","text":"Handler是一个Android开发中常用的类，主要用于接收子线程发送的数据，并用此数据配合主线程更新UI，也可以传递消息。总所周知，Android中非UI线程操作UI时就会Crash，从而保存UI线程的稳定 用法123456handler.post(new Runnable() &#123; @Override public void run()&#123; textView.setText(\"更新UI！！！\"); &#125;&#125;);","tags":[{"name":"Handler","slug":"Handler","permalink":"http://seniorzhai.github.io/tags/Handler/"}]},{"title":"AndroidStudio调用so文件","date":"2015-02-13T01:51:49.000Z","path":"2015/02/13/AndroidStudio调用so文件/","text":"将*.so文件拷贝到app\\libs\\armeabi文件夹下 修改build.gradle文件，在buildTypes下添加 12345sourceSets &#123; main &#123; jniLibs.srcDirs = [&apos;libs&apos;] &#125; &#125; 在调用处 123456public native String stringFromJNI(); //jni 函数名 public native String getFFmpegVersionFromJNI(); //jni函数名 static &#123; System.loadLibrary(\"ffmpeg\"); //加载.so文件 System.loadLibrary(\"ffmpeg-jni\"); //加载.so文件 &#125; 另一个方法*.so文件导入android到app/src/main/jniLibs文件夹下","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"},{"name":"so","slug":"so","permalink":"http://seniorzhai.github.io/tags/so/"}]},{"title":"使用supervisor热启动","date":"2015-02-11T09:41:44.000Z","path":"2015/02/11/使用supervisor热启动/","text":"安装1sudo npm install -g supervisor 全局安装supervisor，mac上需要权限 应用安装完成后，即可使用命令启动应用1supervisor app.js 在WebStorm中使用按如上设置，Node parameters中设置/usr/local/lib/node_modules/supervisor/lib/cli-wrapper.js --exec /usr/local/bin/node --no-restart-on exit","tags":[{"name":"热启动","slug":"热启动","permalink":"http://seniorzhai.github.io/tags/热启动/"},{"name":"supervisor","slug":"supervisor","permalink":"http://seniorzhai.github.io/tags/supervisor/"}]},{"title":"JS操作JSON","date":"2015-02-09T08:38:55.000Z","path":"2015/02/09/JS操作JSON/","text":"JSON本身是JavaScript原生格式，这意味着JS操作JSON起来比其他语言都要优雅。JSON的结构一般分为对象和数组对象以{和}包括，例如{&#39;a&#39;:&#39;a&#39;,&#39;b&#39;:1234,c:&#39;2008-08-08&#39;}数组以[和]包括，例如[{&#39;a&#39;:&#39;a&#39;,&#39;b&#39;:1234,c:&#39;2008-08-08&#39;},{&#39;a&#39;:&#39;a&#39;,&#39;b&#39;:1234,c:&#39;2008-08-08&#39;}] 字符串转对象123var obj = eval('(' + str + ')'); // 无论转多少次都是JSON对象var obj = str.parseJSON(); // 会抛出异常var obj = JSON.parse(str); 对象转字符串12var str = obj.toJSONString();var str = JSON.stringify(obj);","tags":[{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"},{"name":"json","slug":"json","permalink":"http://seniorzhai.github.io/tags/json/"}]},{"title":"Express-Session","date":"2015-02-09T06:10:28.000Z","path":"2015/02/09/Express-Session/","text":"Session代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以使时断时续的。express-session在Express中用于管理Seesion 12345678910111213141516var session = require('express-session'); // 导入session模块app.use(session(&#123; secret:settings.cookieSecrect, // 防止篡改cookie key:settings.db, // cookie的名字 cookie:&#123;maxAge: 1000 * 60 * 60 * 24 *30&#125;, // 30天 store: new MongoStore(&#123; // MongoStore实例用来把会话信息存储到数据库中 db:settings.db, host:settings.host, port:settings.port &#125;)&#125;));app.get('/',function(req,res) &#123; req.session.xx // 获取session中的引用&#125;)","tags":[{"name":"session","slug":"session","permalink":"http://seniorzhai.github.io/tags/session/"}]},{"title":"链接mongodb","date":"2015-02-09T03:15:26.000Z","path":"2015/02/09/链接mongodb/","text":"链接数据库12345678910var MongoClient = require('mongodb').MongoClient, assert = require('assert'); // 断言var url = 'mongodb://localhost:27017/myproject'MongoClient.connect(url,function(err,db))&#123; assert.equal(null,err); // 如果err == null 继续执行 console.log('Connected correctly to server'); db.close();&#125; 插入文档12345678910var insertDocument = function(db,callback) &#123; var collection = db.collection('document'); collection.insert([&#123;a:1&#125;,&#123;a:2&#125;,&#123;a:3&#125;],function(err,result)&#123; assert.equal(err, null); assert.equal(3, result.result.n); assert.equal(3, result.ops.length); console.log(\"Inserted 3 documents into the document collection\"); callback(result); &#125;);&#125; 可以在连接时增加1234567891011121314var MongoClient = require('mongodb').MongoClient , assert = require('assert');// Connection URLvar url = 'mongodb://localhost:27017/myproject';// Use connect method to connect to the ServerMongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); console.log(\"Connected correctly to server\"); insertDocuments(db, function() &#123; db.close(); &#125;);&#125;); 修改文档123456789101112var updateDocument = function(db, callback) &#123; // Get the documents collection var collection = db.collection('documents'); // Update document where a is 2, set b equal to 1 collection.update(&#123; a : 2 &#125; , &#123; $set: &#123; b : 1 &#125; &#125;, function(err, result) &#123; assert.equal(err, null); assert.equal(1, result.result.n); console.log(\"Updated the document with the field a equal to 2\"); callback(result); &#125;); &#125; 也可以在连接时回调12345678910111213141516var MongoClient = require('mongodb').MongoClient , assert = require('assert');// Connection URLvar url = 'mongodb://localhost:27017/myproject';// Use connect method to connect to the ServerMongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); console.log(\"Connected correctly to server\"); insertDocuments(db, function() &#123; updateDocument(db, function() &#123; db.close(); &#125;); &#125;);&#125;); 删除1234567891011var removeDocument = function(db, callback) &#123; // Get the documents collection var collection = db.collection('documents'); // Insert some documents collection.remove(&#123; a : 3 &#125;, function(err, result) &#123; assert.equal(err, null); assert.equal(1, result.result.n); console.log(\"Removed the document with the field a equal to 3\"); callback(result); &#125;); &#125; 1234567891011121314151617var MongoClient = require('mongodb').MongoClient , assert = require('assert');// Connection URLvar url = 'mongodb://localhost:27017/myproject';// Use connect method to connect to the ServerMongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); console.log(\"Connected correctly to server\"); insertDocuments(db, function() &#123; updateDocument(db, function() &#123; removeDocument(db, function() &#123; db.close(); &#125;); &#125;); &#125;);&#125;); 查询123456789101112var findDocuments = function(db, callback) &#123; // Get the documents collection var collection = db.collection('documents'); // Find some documents collection.find(&#123;&#125;).toArray(function(err, docs) &#123; assert.equal(err, null); assert.equal(2, docs.length); console.log(\"Found the following records\"); console.dir(docs) callback(docs); &#125;); &#125; 1234567891011121314151617181920var MongoClient = require('mongodb').MongoClient , assert = require('assert');// Connection URLvar url = 'mongodb://localhost:27017/myproject';// Use connect method to connect to the ServerMongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); console.log(\"Connected correctly to server\"); insertDocuments(db, function() &#123; updateDocument(db, function() &#123; removeDocument(db, function() &#123; findDocuments(db, function() &#123; db.close(); &#125;); &#125;); &#125;); &#125;);&#125;);","tags":[{"name":"数据库","slug":"数据库","permalink":"http://seniorzhai.github.io/tags/数据库/"},{"name":"mongo","slug":"mongo","permalink":"http://seniorzhai.github.io/tags/mongo/"}]},{"title":"Android代码-UI","date":"2015-02-08T01:08:32.000Z","path":"2015/02/08/Android代码-UI/","text":"Android代码 获取手机分辨率 1234DisplayMetrics dm = new DisplayMetrics();this.getWindowManager().getDefaultDisplay().getMetrics(dm);int width = dm.widthPixels;int height = dm.heightPixels; dp转px 1234public static int dip2px(Context context,float dpValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (dpValue *scale + 0.5f);&#125; px转dp 1234public static int px2dip(Context context,float pxValue) &#123; final float scale = context.getResources().getDisplayMetrics().density; return (int) (pxValue / scale + 0.5f) - 15;&#125; 不需要Context得到density的方法 1Resources.getSystem().getDisplatMetrics().density;","tags":[{"name":"UI","slug":"UI","permalink":"http://seniorzhai.github.io/tags/UI/"},{"name":"分配率","slug":"分配率","permalink":"http://seniorzhai.github.io/tags/分配率/"}]},{"title":"AndroidStudio快捷键汇总","date":"2015-02-05T08:46:29.000Z","path":"2015/02/05/AndroidStudio快捷键汇总/","text":"最近开始全面转向Android Studio开发了，经常要去查快捷键，索性汇总下，自己方便查找 IDE 按键 说明 F1 帮助 Alt(Option)+F1 查找文件所在目录位置 Alt(Option)+1 快速打开或隐藏工程面板 Ctrl(Command)+Alt(Option)+ 打开设置对话框 Alt(Option)+Home 跳转到导航栏 Esc 光标返回编辑框 Shift+Esc 光标返回编辑框,关闭无用的窗口 Shift+Click 关闭标签页 F12 把焦点从编辑器移到最近使用的工具窗口 Ctrl(Command)+Alt(Option)+Y 同步 Ctrl(Command)+Alt(Option)+S 打开设置对话框 Alt(Option)+Shift+Inert 开启/关闭列选择模式 Ctrl(Command)+Alt(Option)+Shift+S 打开当前项目/模块属性 Alt(Option)+Shift+C 查看文件的变更历史 Ctrl(Command)+Shift+F10 运行 Ctrl(Command)+Shift+F9 debug运行 Ctrl(Command)+Alt(Option)+F12 资源管理器打开文件夹 编辑 按键 说明 Ctrl(Command)+C 复制当前行或选中的内容 Ctrl(Command)+D 粘贴当前行或选中的内容 Ctrl(Command)+X 剪切当前行或选中的内容 Ctrl(Command)+Y 删除行 Ctrl(Command)+Z 倒退 Ctrl(Command)+Shift+Z 向前 Alt(Option)+Enter 自动修正 Ctrl(Command)+Alt(Option)+L 格式化代码 Ctrl(Command)+Alt(Option)+I 将选中的代码进行自动缩进编排 Ctrl(Command)+Alt(Option)+O 优化导入的类和包 Alt(Option)+Insert 得到一些Intention Action，可以生成构造器、Getter、Setter、将 == 改为 equals() 等 Ctrl(Command)+Shift+V 选最近使用的剪贴板内容并插入 Ctrl(Command)+Alt(Option)+Shift+V 简单粘贴 Ctrl(Command)+Shift+Insert 选最近使用的剪贴板内容并插入（同Ctrl(Command)+Shift+V） Ctrl(Command)+Enter 在当前行的上面插入新行，并移动光标到新行（此功能光标在行首时有效） Shift+Enter 在当前行的下面插入新行，并移动光标到新行 Ctrl(Command)+J 自动代码 Ctrl(Command)+Alt(Option)+T 把选中的代码放在 try{} 、if{} 、 else{} 里 Shift+Alt(Option)+Insert 竖编辑模式 Ctrl(Command)+ / 注释 // Ctrl(Command)+Shift+ / 注释 /…/ Ctrl(Command)+Shift+J 合并成一行 F2/Shift+F2 跳转到下/上一个错误语句处 Ctrl(Command)+Shift+Back 跳转到上次编辑的地方 Ctrl(Command)+Alt(Option)+Space 类名自动完成 Shift+Alt(Option)+Up/Down 内容向上/下移动 Ctrl(Command)+Shift+Up/Down 语句向上/下移动 Ctrl(Command)+Shift+U 大小写切换 Tab 代码标签输入完成后，按 Tab，生成代码 Ctrl(Command)+Backspace 按单词删除 Ctrl(Command)+Shift+Enter 语句完成 Ctrl(Command)+Alt(Option)+J 用动态模板环绕 文件 按键 说明 Ctrl(Command)+F12 显示当前文件的结构 Ctrl(Command)+H 显示类继承结构图 Ctrl(Command)+Q 显示注释文档 Ctrl(Command)+P 方法参数提示 Ctrl(Command)+U 打开当前类的父类或者实现的接口 Alt(Option)+Left/Right 切换代码视图 Ctrl(Command)+Alt(Option)+Left/Right 返回上次编辑的位置 Alt(Option)+Up/Down 在方法间快速移动定位 Ctrl(Command)+B 快速打开光标处的类或方法 Ctrl(Command)+W 选中代码，连续按会有其他效果 Ctrl(Command)+Shift+W 取消选择光标所在词 Ctrl(Command)+ - / + 折叠/展开代码 Ctrl(Command)+Shift+ - / + 折叠/展开全部代码 Ctrl(Command)+Shift+. 折叠/展开当前花括号中的代码 Ctrl(Command)+ ] / [ 跳转到代码块结束/开始处 F2 或 Shift+F2 高亮错误或警告快速定位 Ctrl(Command)+Shift+C 复制路径 Ctrl(Command)+Alt(Option)+Shift+C 复制引用，必须选择类名 Alt(Option)+Up/Down 在方法间快速移动定位 Shift+F1 要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl(Command)+G 定位行 查找 按键 说明 Ctrl(Command)+F 在当前窗口查找文本 Ctrl(Command)+Shift+F 在指定环境下查找文本 F3 向下查找关键字出现位置 Shift+F3 向上一个关键字出现位置 Ctrl(Command)+R 在当前窗口替换文本 Ctrl(Command)+Shift+R 在指定窗口替换文本 Ctrl(Command)+N 查找类 Ctrl(Command)+Shift+N 查找文件 Ctrl(Command)+Shift+Alt(Option)+N 查找项目中的方法或变量 Ctrl(Command)+B 查找变量的来源 Ctrl(Command)+Alt(Option)+B 快速打开光标处的类或方法 Ctrl(Command)+Shift+B 跳转到类或方法实现处 Ctrl(Command)+E 最近打开的文件 Alt(Option)+F3 快速查找，效果和Ctrl(Command)+F相同 F4 跳转至定义变量的位置 Alt(Option)+F7 查询当前元素在工程中的引用 Ctrl(Command)+F7 查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl(Command)+Alt(Option)+F7 选中查询当前元素在工程中的引用 Ctrl(Command)+Shift+F7 高亮显示匹配的字符，按 Esc 高亮消失 Ctrl(Command)+Alt(Option)+F7 查找某个方法的所有调用地方 Ctrl(Command)+Shift+Alt(Option)+N 查找类中的方法或变量 Ctrl(Command)+Shift+O 弹出显示查找内容 Ctrl(Command)+Alt(Option)+Up/Down 快速跳转搜索结果 Ctrl(Command)+Shift+S 高级搜索、搜索结构 重构 按键 说明 F5 复制 F6 移动 Alt(Option)+Delete 安全删除 Ctrl(Command)+U 转到父类 Ctrl(Command)+O 重写父类的方法 Ctrl(Command)+I 实现方法 Ctrl(Command)+Alt(Option)+N 内联 Ctrl(Command)+Alt(Option)+Shift+T 弹出重构菜单 Shift+F6 重构-重命名 Ctrl(Command)+Alt(Option)+M 提取代码组成方法 Ctrl(Command)+Alt(Option)+C 将变量更改为常量 Ctrl(Command)+Alt(Option)+V 定义变量引用当前对象或者方法的返回值 Ctrl(Command)+Alt(Option)+F 将局部变量更改为类的成员变量 Ctrl(Command)+Alt(Option)+P 将变量更改为方法的参数 调试 按键 说明 F8 跳到下一步 Shift+F8 跳出函数、跳到下一个断点 Alt(Option)+Shift+F8 强制跳出函数 F7 进入代码 Shift+F7 智能进入代码 Alt(Option)+Shift+F7 强制进入代码 Alt(Option)+F9 运行至光标处 Ctrl(Command)+Alt(Option)+F9 强制运行至光标处 Ctrl(Command)+F2 停止运行 Alt(Option)+F8 计算变量值 VCS|按键|说明||Alt(Option)+ ~||VCS 操作菜单||Ctrl(Command)+K|提交更改||Ctrl(Command)+T|更新项目||Ctrl(Command)+Alt(Option)+Shift+D|显示变化|","tags":[{"name":"keymap","slug":"keymap","permalink":"http://seniorzhai.github.io/tags/keymap/"},{"name":"快捷键","slug":"快捷键","permalink":"http://seniorzhai.github.io/tags/快捷键/"}]},{"title":"Android事件","date":"2015-02-04T08:47:29.000Z","path":"2015/02/04/Android事件/","text":"EventBus是一个非常流行的开源库，用于Android事件发布/订阅，通过解耦发布者和订阅者简化Android事件传递。事件传递可以用于Android四大组件也可以作用于异步线程和主线程的通讯。相比Handler、BroadCastReceiver、Interface回调，EventBus的优点代码更简洁，使用简单将事件发布和订阅充分解耦。 概念 事件(Event)：分为一般事件和Sticky事件，相对于一般事件，Sticky事件在事件发布后，再有订阅者开始订阅该类事件，依然能收到该类型事件最后一次Sticky事件。 订阅者(Subscriber)：订阅某种事件类型的对象，当有发布者发布这类事件后，EvenrBus会执行订阅者的onEvent函数，订阅者通过register接口订阅某个事件，unregister退订。订阅者存在优先级，优先级高的订阅者可以取消事件的分发，默认所有订阅者的优先级都是0. 发布者(Publisher)：发布某事件的对象，通过post接口发布事件 使用1234567891011121314151617181920212223242526272829303132333435363738public class Activity1 extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity1); EventBus.getDefault().register(this); //注册对象 new Thread(new Runnable() &#123; int i= 1; @Override public void run() &#123; while(true)&#123; try &#123; Thread.sleep(2000); EventBus.getDefault().post(new EventA(\"正在运行第\"+i+\"次\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; @Verride protected void onDestroy() &#123; // 注销 EventBus.getDefault().unregister(this); super.onDestroy(); &#125; public void onEventMainThread(EventA eventA)&#123; TextView tv = (TextView) findViewById(R.id.tv); tv.setText(eventA.text); &#125;&#125;public class EventA &#123; String text = \"asd\"; public EventA(String text)&#123; this.text = text; &#125;&#125; ThreadMode onEventMainThread表示这个方法会在UI线程中运行 onEventPostThread表示这个方法会在当前发布事件的线程执行 onEventBackgroundThread如果在非UI线程发布的事件，直接执行和发布的线程在同一个线程，如果UI线程发布则加入到一个后台线程队列中 onEventAsync代表方法直接在独立的线程中去执行","tags":[{"name":"EventBus","slug":"EventBus","permalink":"http://seniorzhai.github.io/tags/EventBus/"}]},{"title":"使用Gradle发布项目到JCenter仓库","date":"2015-02-04T08:47:29.000Z","path":"2015/02/04/使用Gradle发布项目到JCenter仓库/","text":"JCenter是Android Studio中repositories的默认节点。 申请Bintray账号需要在Bintray注册一个账号 生成项目的JavaDoc和source JARsJCenter需要我上传远程仓库以上两个文件，这一步需要android-maven-plugin插件，所以在项目中的build.gragle(项目最外层)构建依赖1234567891011121314buildscript&#123; repositories &#123; jcenter(); &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:1.0.0&apos; classpath &apos;com.github.dcendents:android-maven-plugin:1.2&apos; &#125; allprojects &#123; repositories &#123; jcenter() &#125; &#125;&#125; 然后在需要发布的那个module的build.gradle里配置修改12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788apply plugin: &apos;com.android.library&apos;apply plugin: &apos;com.github.dcendents.android-maven&apos;apply plugin: &apos;com.jfrog.bintray&apos;version = &quot;1.0.0&quot;android&#123; compileSdkVersion 21 buildToolsVersion &quot;21.1.2&quot; resourcePrefix &quot;resourcePrefix&quot; // 这个随便填 defaultConfig &#123; minSdkVersion 9 targetSdkVersion 21 versionCode 1 versionName version &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;),&apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: &apos;libs&apos;,include: [&apos;*.jar&apos;]) compile &apos;com.nineoldandroid:library:2.4.0+&apos;&#125;def siteUrl = &apos;https://github.com/XXX/XXX&apos; // 项目的主页def gitUrl = &apos;https://github.com/XXX/XXX.git&apos; // git仓库URLinstall &#123; repositories.mavenInstaller &#123; pom &#123; project &#123; packaging &apos;arr&apos; name &apos;Project&apos; // 项目名 url siteUrl licenses &#123; // 协议 license &#123; name &apos;The Apache Software License, Version 2.0&apos; url &apos;http://www.apache.org/licenses/LICENSE-2.0.txt&apos; &#125; &#125; developers &#123; developer &#123; // 基本信息 id &apos;seniorzhai&apos; name &apos;zhaitao&apos; email &apos;developer.zhaitao@gmail.com&apos; &#125; &#125; scm &#123; connection gitUrl developerConnection gitUrl url siteUrl &#125; &#125; &#125; &#125;&#125;task sourcesJar(type: Jar) &#123; from android.sourceSets.main.java.srcDirs classifier = &apos;sources&apos;&#125;task javadoc(type: Javadoc) &#123; source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClassPath().join(File.pathSeparator))&#125;task javadocJar(type: Jar,dependsOn: javadoc) &#123; classifier = &apos;javadoc&apos; from javadoc.desinationDir&#125;artifacts &#123; archiver javadocJar archiver sourcesJar&#125;Properties properties = new Properties()properties.load(project.rootProject.file(&apos;local.properties&apos;),newDataInputStream())bintray &#123; user = properties.getProperty(&quot;bintray.user&quot;) key = properties.getProperty(&quot;bintray.apikey&quot;) configurations = [&apos;archives&apos;] pkg &#123; repo = &apos;maven&apos; name = &quot;ProjectName&quot; websiteUrl = siteUrl vcsUrl = gitUrl licenses = [&quot;Apache-2.0&quot;] publish = true &#125;&#125; 上述的local.properties文件在项目的根目录，用于配置bintray账号信息，这个文件需要gitignore防止泄露账号信息12bitray.user=your_user_namebitray.apokey=yor_apikey Rebuild一下项目，module里的build文件夹会生成相应文件，项目生成到本地仓库，Android Studio默认在Android\\sdk\\extras\\android\\m2repository文件夹中执行gradlew install 上传到Bintray上传需要gradle-bintray-plugin的支持在build.gradle里构建12345dependencies &#123; ... classpath &apos;com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0&apos; ...&#125; 再Rebuild下，然后执行gradlew bintrayUpload上传完成后就可再Bintray上找到Repo，最后申请Repo添加到JCenter，在https://bintray.com/bintray/jcenter输入项目的名字点击匹配到的项目，然后写一写Comments再send即可，等管理员审批即可。成功后，在其他项目中调用添加denpendcies即可","tags":[{"name":"AS","slug":"AS","permalink":"http://seniorzhai.github.io/tags/AS/"},{"name":"JCenter","slug":"JCenter","permalink":"http://seniorzhai.github.io/tags/JCenter/"},{"name":"Gradle","slug":"Gradle","permalink":"http://seniorzhai.github.io/tags/Gradle/"}]},{"title":"[转]8种移动APP导航设计模式大对比","date":"2015-02-04T02:16:48.000Z","path":"2015/02/04/-转-8种移动APP导航设计模式大对比/","text":"当我们确定了移动APP的设计需求和APP产品设计流程之后，开始着手设计APP界面UI或是APP原型图啦。这个时候我们都要面临的第一个问题就是如何将信息以最优的方式组合起来？本文转自：人人都是产品经理也许我们对比和了解了其他一些常用的APP导航设计模式。而且良好的APP导航设计模式决策对整个app的核心体验起到关键作用。之前跟大家分享过6个超实用的APP导航设计方案和3种常见的APP导航设计方案优劣势分析有一些优秀的app基于这些模式做了一些创新的优化方案，本文总结了目前通用且流行的模式，并讨论了这些模式适用的场景，希望帮助交互设计师更快的作出较合理的信息组织决策。先来看看8种移动APP导航设计模式对比图吧！ 第一种：app标签导航标签导航位于页面底部，通常包含5个标签是比较合适的数量。这种导航是非常常见的，如果你的应用需要用户频繁的在不同分页切换，可以采用这种导航。它的缺点是会占用一定高度的空间。如微信最新版的APP界面设计图。 第2种：APP舵式导航目前流行一种标签导航的变体，个人把它称为“舵式导航”，因为它的样式很像轮船上用来指挥的船舵，两侧是其他操作按钮。当页面有处于同一层级的几大部分内容，同时又需要一个非常重要且频繁操作的入口，就可以采用这种APP导航模式。如下图葡萄社APP。 第三种：APP抽屉式导航模式抽屉导航是讲菜单隐藏在当前页面后，点击入口即可像拉抽屉一样拉出菜单，这种导航的优点是节省页面展示空间，让用户将更多的注意力聚焦到当前页面。比较适 合于不那么需要频繁切换内容的应用，例如对设置、关于等内容的隐藏。这种导航设计需要注意的是一定要提供菜单画出的过渡动画。 自从path应用以来，这种抽屉式导航菜单非常受到大家的喜爱，25学堂之前也重点介绍了9种最佳移动APP侧边栏设计方案。 第四种：APP宫格导航（比如九宫格）这种宫格导航是将主要入口全部聚合在页面，让用户做出选择。这样的组织方式无法让用户在第一时间看到内容，选择压力较大，采用这种导航的应用已经越来越少，往往用在二级页作为内容列表的一种图形化形式呈现，或是作为一系列工具入口的聚合。 第五种：APP混合组合导航当用户需要聚焦内容，同时又需要一些快捷入口能够连接到某些页面时，就可以采用组合导航。组合导航上方用宫格的形式展现快捷入口，与标签导航不同的是，这 些宫格入口之间不需要是平级的关系，也不必包含整个层级的内容，你可以将它理解为一种图形化的文字链。这种导航比较灵活，能适应架构的快速调整。 第六种：列表式APP导航列表式APP导航是我们在APP设计种必不可少的一个信息承载模式。当然作为一个APP的导航也是非常方便的。 不过目前来看，列表导航通常用于二级页，由于它与宫格导航一样，不会默认展示任何实质内容，所以通常app不会在首页使用它。这种导航结构清晰，易于理解，冷静高效，能够帮助用户快速的定位去到对应的页面。列表项目可以通过间距、标题等进行分组。 第七种：tab导航用于二级页，本质和标签导航相同，当应用层级较多的情况下，可以采用tab导航，典型场景是用于改变的当前的视图，或对当前页面内容进行分类查看。 第八种就是：大图轮播导航或是 大图上面的导航设计当你的应用信息足够扁平，可以尝试轮播导航，如果应用得当，能够给人耳目一新的体验。这种导航能够最大程度的保证应用的页面简洁性，操作也是最方便的。但是缺点是不能够快速的定位对应的分页内容。","tags":[{"name":"导航","slug":"导航","permalink":"http://seniorzhai.github.io/tags/导航/"}]},{"title":"LitePal的使用","date":"2015-02-02T03:20:19.000Z","path":"2015/02/02/LitePal的使用/","text":"LitePal是一款开源的Android数据库框架，采用了ORM对象关系映射的模式，将常用的数据库功能进行了封装。 基本用法 引入jar包 可以在这里下载LitePal的最新版本 也可以在github上下载LitePal的源码，使用Library的方式导入Eclipse中 配置litepal.xml 在assets目录下建立litepal.xml文件 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;litepal&gt; &lt;dbname value=\"demo\"&gt;&lt;/dbname&gt; &lt;version value=\"1\"&gt;&lt;/version&gt; &lt;list&gt; &lt;/list&gt;&lt;/litepal&gt; dbname用于设定数据库的名字，version用于设定数据库版本号，list用于设定所有的映射模型 配置LitePalApplication 在AndroidManifest.xml中配置一个LitePalApplication 12345678&lt;manifest&gt; &lt;application name=\".LitePalApplication\" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 如果使用了自定义的Application继承LitePalApplication即可 建表根据对象关系映射模式的概念，每一张表应该对应一个模型，比如对应的News模型12345678public class News&#123; private int id; // 可以不写，LitePalace会自定生成 private String title; private String content; private Date publishDate; private int commentCount; // getter、setter&#125; 映射的数据类型一共有8种:int、short、long、float、double、boolean、String和Date使用LitePal只有声明private的字段才会被映射到数据表中，如果不想映射的话，修饰符设置为public、protected、default就可以了建立后再配置到映射表中，编辑asset目录下的litepal.xml的文件，在&lt;list&gt;标签下加入News模型类的声明12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;litepal&gt; &lt;dbname value=\"demo\"&gt;&lt;/dbname&gt; &lt;version value=\"1\"&gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class=\"com.example.databasetest.model.News\"&gt;&lt;/mapping&gt; &lt;/list&gt;&lt;/litepal&gt; 获取SQLiteDatabase的实例1SQLiteDatabase db = Connector.getDatabase(); 升级表增加新的表或者改变表结构，只需要需要对应model的属性，在litepal.xml中进行配置，并对version进行加1处理 中级用法建立表关联 一对一关系比如相应News每一条新闻都有一段introduction简介可以在introduction中设置一个news_id的外键列，存放具体新闻的id 多对一关系比如一个News对应多个Comment评论在Comment中设置new_id列，存放具体New的ID，多个comment就对应了同一个New 多对多比如News可以有很多Category种类，Category对应很多News可以新建一个中间表来存放news和category的关系category_news表设置news_id和category_id两列，分别是news表的外键和category表的外键 使用LitePal建立关联表新建Introduction和Category两个类123456789101112public class Introduction &#123; private int id; private String guidie; private String digest; // getter、setter&#125;public class Category &#123; private int id; private int name; // getter、setter&#125; 在News中添加Introduction的引用12345public class News &#123; ... private Introduction introdution; ...&#125; 因为Comment和News是多对一的关系1234567891011// news对应多个commentpublic class News &#123; ... private List&lt;Comment&gt; commentList = new ArrayList&lt;Comment&gt;();&#125;// comment 对应一个newspublic class Comment &#123; ... private News news; ...&#125; 对于news和category1234567891011public class News &#123; ... private List&lt;Category&gt; categoryList = new ArrayList&lt;Category&gt;(); ...&#125;public class Category &#123; ... private List&lt;News&gt; newsList = new ArrayList&lt;News&gt;(); ...&#125; 存储要进行CRUD操作所有实体类都需要继承自DataSupport类之后实体类就可以进行CRUD操作了12345News news = new News();news.setTitle(\"标题\");news.setContent(\"内容\");news.setPubllishDate(new Date);news.save(); // 返回布尔值，是否存储成功 也可以使用saveThrows()方法，抛异常来捕捉存储失败的异常其中LitePal已经默默地帮我们设置了idComment和News是多对一的关系123456789101112131415161718Comment comment1 = new Comment(); comment1.setContent(\"好评！\"); comment1.setPublishDate(new Date()); comment1.save(); Comment comment2 = new Comment(); comment2.setContent(\"赞一个\"); comment2.setPublishDate(new Date()); comment2.save(); News news = new News(); news.getCommentList().add(comment1); news.getCommentList().add(comment2); news.setTitle(\"第二条新闻标题\"); news.setContent(\"第二条新闻内容\"); news.setPublishDate(new Date()); news.setCommentCount(news.getCommentList().size()); news.save(); 这样多对一的关系就被建立，而且Comment中的news_id已经被默默赋值如果有一个List&lt;News&gt; newsList，可以使用DataSupport.saveAll(newsList)来存储集合数据 修改数据比如把news表中id为2的记录的标题修改123ContentValues = new ContentValues();values.put('title',\"title修改\");DataSupport.update(News.class,values,2); 修改多条数据123ContentValues values = new ContentValues(); values.put(\"title\", \"今日iPhone6 Plus发布\"); DataSupport.updateAll(News.class, values, \"title = ?\", \"今日iPhone6发布\"); 使用约束条件可以限定特定的数据，?为占位符，用后面的String数据代入比如：123ContentValues values = new ContentValues(); values.put(\"title\", \"今日iPhone6 Plus发布\"); DataSupport.updateAll(News.class, values, \"title = ? and commentcount &gt; ?\", \"今日iPhone6发布\", \"0\"); 如果全部修改可以不使用约束123ContentValues values = new ContentValues(); values.put(\"title\", \"今日iPhone6 Plus发布\"); DataSupport.updateAll(News.class, values); 使用ContentValues对象并不是那么友好，也可以直接使用实体类1234567News updateNews = new News();updateNews.setTtitle(\"新标题\");updateNews.update(2);//...News updateNews = new News(); updateNews.setTitle(\"今日iPhone6发布\"); updateNews.updateAll(\"title = ? and commentcount &gt; ?\", \"今日iPhone6发布\", \"0\"); 如果要修改某列数据为默认值，使用setToDefault()方法 删除123DataSupport.delete(News.class,2); // 删除news表中id为2的记录，news_id为2的记录为外键的数据也会删除，返回值为被输出的记录数DataSupport.deleteAll(News.class,\"title = ? and commentcount = ? \",\"title\",\"0\"); // 批量删除DataSupport.deleteAll(News.class); // 删除所有 查询1234567News news = DataSupport.find(News.class,1); // 查询id为1的记录News first = DataSupport.findFirst(News.class); // 查询第一条数据News last = DataSupport.findLast(News.class); // 查询最后一条数据List&lt;News&gt; newsList = DataSupport.findAll(News.class,1,3,5,7); // 查询id为1,3,5,7的数据long[]ids = new long[]&#123;1,3,5,7&#125;;List&lt;News&gt; newsList2 = DataSupport.findAll(News.class,ids);List&lt;News&gt; newsList3 = DataSupport.findAll(News.class); // 所有数据 连缀查询根据指定查询条件查询12345678910111213List&lt;News&gt; newsList = DataSupport.where(\"commentcount &gt; ?\",\"0\").find(News.class);List&lt;News&gt; newsList = DataSupport.select(\"title\", \"content\") .where(\"commentcount &gt; ?\", \"0\").find(News.class); // 只要title和content两列数据List&lt;News&gt; newsList = DataSupport.select(\"title\", \"content\") .where(\"commentcount &gt; ?\", \"0\") .order(\"publishdate desc\").find(News.class); // asc正序排序、desc倒序排序List&lt;News&gt; newsList = DataSupport.select(\"title\", \"content\") .where(\"commentcount &gt; ?\", \"0\") .order(\"publishdate desc\").limit(10).find(News.class); // 只查询10条数据List&lt;News&gt; newsList = DataSupport.select(\"title\", \"content\") .where(\"commentcount &gt; ?\", \"0\") .order(\"publishdate desc\").limit(10).offset(10) .find(News.class); // 查询11-20 激进查询上述的查询无法查询关联表的数据，LitePal默认的模式就是懒查询，如果要一次性将关联表中的数据也一起查询出来，LitePal也支持激进查询的方式。12News news = DataSupport.find(News.class,1,true); // true参数表示使用激进查询，关联的数据也会一起查出来List&lt;Comment&gt; commentList = news.getCommentList(); 使用懒加载也可以查询出关联数据，比如在News类中增加代码123456public class News extends DataSupport &#123; ... public List&lt;Comment&gt; getComments() &#123; return DataSupport.where(news_id=?),String.valueOf(id)).find(Comment.class); &#125;&#125; 原生查询LitaPal也可以使用原生的查询(SQL语句)1Cursor cursor = DataSupport.findBySQL(\"select * from news where commentcount&gt;?\",\"0\"); 聚合函数LitePal中提供了count()、sum()、average()、max()、min()这五种聚合函数 count() count()主要用于统计行数 123456789 int result = DataSupport.count(News.class); int result = DataSupport.where(\"commnetcount = ?\",\"0\").count(News.class); ``` - sum() sum()用于对结果进行求和 ```java // 第一个参数表示表，第二个参数是列名，第三个参数用于指定结果的类型 int result = DataSupport.sum(News.class,\"commentcount\",int.class); // 表示所有的评论数 average() average()用于统计平均数 1double result = DataSupport.average(News.class,\"commentcount\"); max() 求出列中最大的数值 1int result = DataSupport.max(News.class,\"commentcount\",int.class); min() 求出列中最小的数值 1int result = DataSupport.min(News.class,\"commentcount\",int.class);","tags":[{"name":"数据库","slug":"数据库","permalink":"http://seniorzhai.github.io/tags/数据库/"},{"name":"sqlite","slug":"sqlite","permalink":"http://seniorzhai.github.io/tags/sqlite/"}]},{"title":"[转]发现优秀APP的一些途径","date":"2015-02-02T01:29:14.000Z","path":"2015/02/02/-转-发现优秀APP的一些途径/","text":"再好的应用，也需要有人去发现他，我只是有那么一些途径，让我更快的找到它们而已。有网页，有微博，也有微信公众号，希望我的这些推荐可以让你更好的发现那些优秀、精美的应用。转至http://www.jianshu.com/p/64a99d2c932f AppZappAppZapp 是一款 iOS/Android 端限免应用推荐平台，旨在洞悉 App Store / Google Play的 限免/降价/新出应用，并第一时间推送消息至用户设备上。并且你还可以根据属性筛选应用，查看获赞数最高的应用，自定义筛选属性查看。AppZapp 有PC 网页版，和移动端，可以让你更好的找到应用。http://www.appzapp.net/en/app/ AppShopperAppShopper是一家iOS应用追踪网站，可提供反应App Store动态的滚动清单，功能包括搜寻新应用，查看应用升级以及价格变动。提供 iOS 客户端http://appshopper.com/ 最美应用国内比较不错的获取优秀 app 的地方，致力于发掘功能之美、视觉之美、交互之美、用户体验之美。（提供 ios 客户端）http://zuimeia.com/ 少数派主要推荐精品手机应用，同时提供智能手机使用教程，应用评测，应用资讯等。是我本人经常泡的地方。http://sspai.com/ Pinapps（微信公众号）Alibaba国际站无线设计团队负责人 @5Key 折腾的公众号，在这里你可以看到一些非常棒的应用，一些非常酷、非常小众的应用。http://pinapps.in/ ApplePlus（微信公众号、微博）一名 95 后极端应用狂，不定期推荐一些他认为优秀、实用的 APP，意图颠覆你的手机屏幕。微信号：Apple-Plus微博：http://weibo.com/p/1005053344700084 AppSo新酷应用（微信公众号、微博）爱范儿旗下的应用推荐媒体 AppSolution，微信公众号和微博都有。微信号：AppSolution微博：http://weibo.com/u/3329934602 爱屁屁专注于移动 APPS（应用/游戏）个性化评测，木有客户端，只有网页。http://www.appnz.com/ 享应（iOS 客户端）发现最新鲜、有趣甚至搞怪的优质应用，活跃的机友社区，方便交流。http://www.isharein.com/ APP 每日推送App每日推送是国内 iPhone/iPad 游戏应用推荐平台，每日推送适合国人的限时免费应用，同时也会推荐免费应用中的精品给大家。以上为官方介绍…http://appdp.com/ 小众软件分享免费、小巧、实用、有趣、绿色的软件，可以说是国内非常有名的一个 Blog，确实可以发现一部分优秀的 App。http://www.appinn.com/ 数字尾巴数字尾巴旗下有「应用控」这么一个平台，也会分享一些不错的应用。另外，如果你的手机上安装了数字尾巴的 APP，其实应用栏目下面你也可以找到一些不错的APP。http://app.dgtle.com/ 好奇心日报其实，很多朋友都不知道「好奇心日报」下有个栏目叫「今日应用」，也会推荐一些非常棒的 APP，并且好奇心日报本身就是一款非常不错的应用。http://qdaily.com/display/articles/tag/params/tag_id/1288/page/1 Product HuntProduct Hunt 是一个发现新酷产品的平台，每日最佳新产品的排行榜。在这里，你也可以发现一些国外的新酷应用，有 iOS 客户端http://www.producthunt.com/ Next类似 Profuct Hunt ，Next 是 36Kr 旗下产品，在这里你可以找到国内外的新产品，发现那些不一样的应用，还可以和国内的创业团队、独立开发者直面交流。http://next.36kr.com MindStore在 Mindstore，你不仅可以发现国内外新酷的产品、应用，你还可以和一些非常棒的产品负责人 and 创始人讨论一些话题。Mindstore 定期会在线上邀请一些产品的负责人来和大家聊聊。http://mindStore.io 简书简书可以说是卧虎藏龙，里面有不少朋友会推荐优秀 app，包括笔者也经常会到简书去写一些我认为不错的应用分享给大家。http://jianshu.com 其他其实微博上还有很多朋友也在分享一下不错的东西，比如@李大锤同学的微博（少数派/最美应用撰稿人），另外例如@app狗 @app菌等也会分享一些 APP 合集，但是如果你知道了上面列举了15个获取优秀应用的途径，我想已经足够你找到那些隐藏在众多应用中的「优秀 APP 了」","tags":[{"name":"App","slug":"App","permalink":"http://seniorzhai.github.io/tags/App/"}]},{"title":"Android手机连接不上Mac的解决办法","date":"2015-01-27T05:40:54.000Z","path":"2015/01/27/Android手机连接不上Mac的解决办法/","text":"将Android手机的调试模式打开 按住选择Mac的option键，选择Apple图标选项的系统信息 找到USB，查看手机的厂商ID，比如我的MX Pro是0x2a45 在终端中输入并执行echo 0x2a45 &gt;&gt; ~/.android/adb_usb.ini 重启ADB服务（adb restart或者重启Eclipse、AndroidStudio）","tags":[]},{"title":"iOS开源库","date":"2015-01-26T13:04:15.000Z","path":"2015/01/26/iOS开源库/","text":"转帖至http://www.douban.com/note/276160185/youtube下载神器：https://github.com/rg3/youtube-dlvim插件：https://github.com/Valloric/YouCompleteMevim插件配置：https://github.com/spf13/spf13-vim—————-Mac完整项目———-电台：https://github.com/myoula/sostart—————-iOS完整项目—————- 豆瓣相册 https://github.com/TonnyTao/DoubanAlbum voa在线英语 https://github.com/cubewang/NewsReader3.电竞第一视角 https://github.com/cubewang/GameDaily 开源中国的iOS客户端 https://github.com/oschina/iphone-app 很优雅的一些组件 https://github.com/sobri909/MGBox2 ios控件学习：https://github.com/iimgal/StudyiOS?source=c reader ：https://github.com/vfr/Reader git客户端： https://github.com/dennisreimann/ioctocat speakEnglish：https://github.com/cubewang/SpeakEnglish 新闻阅读 ：https://github.com/samuelclay/NewsBlur last.fm：https://github.com/c99koder/lastfm-iphone LBS游戏：https://github.com/Kjuly/iPokeMon ThatInbox 是iOS平台上一个免费开源的Email 客户端：https://github.com/Ink/ThatInbox ThatCloud是一个免费开源的iOS app. 允许你访问、查看以及使用你在网上存储的内容. 可以很好地帮你完成工作：https://github.com/Ink/ThatCloud ThatPhoto是使用了Ink Mobile Framework框架来连接到其他iOS 应用程序. 你可以用它来编辑和管理照片：https://github.com/Ink/ThatPhoto ThatPDF一个开源的. 用来阅读、签名和注解PDF 文档的工具：https://github.com/Ink/ThatPDF xmpp聊天系统：https://github.com/chrisballinger/Off-the-Record-iOS 对口袋NCE有用的app：https://github.com/imtiger/HappyEnglish 一个像Instagram那样的图片分享社区App：https://github.com/ParsePlatform/Anypic 黑客阅读:https://github.com/mmackh/Hacker-News-for-iOS 画图软件：https://github.com/sprang/Brushes APN软件：https://github.com/lexrus/APN.iOS Sol的天气app：https://github.com/comyarzaheri/Sol 货币转换：https://github.com/nicklockwood/Concurrency 来电归属地查询的软件（不能上架）：https://github.com/Quotation/WhoCall Mogo iOS 客户端：https://github.com/jurre/Mogo-iOS https://github.com/AshFurrow/C-41 使用XMPP协议的IM开源软件：https://github.com/chrisballinger/ChatSecure-iOS WWDC：https://github.com/indragiek/WWDC-2014 移动支付公司 Square 将去年收购的照片应用 Viewfinder 开源了. 包含服务端、iOS 和 Android 应用代码：https://github.com/viewfinderco/viewfinder 圣经小助手 ：https://github.com/nixzhu/Bible-Assistant 已阅 ：https://github.com/ming1016/RSSRead 美国白宫APP：https://github.com/WhiteHouse/wh-app-ios Ruby for China： https://github.com/ruby-china/ruby-china-for-ios breadwallet iOS bitcoin wallet ：https://github.com/voisine/breadwallet 品趣：https://github.com/novel-design/novel-design 懒人笔记：https://github.com/liaojinxing/Voice2Note Doppio :https://github.com/chroman/Doppio parse开源了：https://github.com/ParsePlatform/f8DeveloperConferenceApp The Oakland Post iOS App（http://www.oaklandpostonline.com) https://github.com/aclissold/The-Oakland-Post GreatReader PDF阅读：https://github.com/semweb/GreatReader Signal for iOS：https://github.com/WhisperSystems/Signal-iOS Hacker News Client：https://github.com/bonzoq/hniosreader—————-开源项目的协议————–网易新闻的开源协议： http://m.163.com/special/newsclient/ios_libraries.html—————-组件—————-自定义tabbar（1）的： https://github.com/i300/TweetBotTabBar自定义tabbar（2）和上拉刷新：http://www.cocoachina.com/bbs/read.php?tid=62061&amp;keyword=tabbar自定义tabbar（3）：https://github.com/jinthagerman/JBTabBarController类似instagram的tabbar：https://github.com/boctor/idev-recipes/tree/master/CustomTabBarNotificationcoretext：https://github.com/Cocoanetics/DTCoreText图片延时加载：网络请求：https://github.com/pokeb/asi-http-requesthttps://github.com/AFNetworking/AFNetworkingJson解析:https://github.com/johnezang/JSONKit图片异步加载：https://github.com/rs/SDWebImage?source=c瀑布流1）：https://github.com/aceisScope/WaterflowView瀑布流2）http://code4app.com/ios/%E7%80%91%E5%B8%83%E6%95%88%E6%9E%9C-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/4fdfecd96803fa117f000000瀑布流3）：https://github.com/chiahsien/CHTCollectionViewWaterfallLayout瀑布流4）：http://www.cocoachina.com/bbs/read.php?tid=94851&amp;keyword=%C6%D9%B2%BC%C1%F7瀑布流5）：https://github.com/ptshih/PSCollectionView瀑布流6）： 搜索：瀑布流瀑布流7）：https://github.com/steipete/PSTCollectionView做图书的一个框架：https://github.com/Simbul/baker项目内文档：https://github.com/tomaz/appledoc?source=c抽屉导航：https://github.com/Inferis/ViewDeckiOS的url router :https://github.com/gaosboy/urlmanagerhttps://github.com/usepropeller/routable-ioshttps://github.com/jverkoey/sockit照片墙：https://github.com/gmoledina/GMGridViewcollectionview:https://github.com/steipete/PSTCollectionView自动更新类：https://github.com/lexrus/LTUpdate官网蝴蝶的OpenGL应用：开机密码锁：https://github.com/aporat/KKPasscodeLock视频播放器：https://github.com/blizzard-op/VideoPlayerKit音频播放完整客户端：https://github.com/kstenerud/ObjectAL-for-iPhone豆瓣音频播放：https://github.com/douban/DOUAudioStreamer掉渣天的音频播放流：https://github.com/alexbw/novocaineAudioEngine：https://github.com/TheAmazingAudioEngine/TheAmazingAudioEngine滑动的自定义的SegmentedControl控件：https://github.com/samvermette/SVSegmentedControl自定义的segmented：https://github.com/HeshamMegid/HMSegmentedControl类似swipelist的左右滑动的cell：https://github.com/alikaragoz/MCSwipeTableViewCell扩展1：https://github.com/soffes/sstoolkit扩展2：（存用户密码）：https://github.com/soffes/sskeychainscrollview自动滚动：https://github.com/shanegao/SGFocusImageFramescrollview左右滑动，渐隐渐出：https://github.com/park0ur/Path-Intro-iPhonescrollview滑动条变细：https://github.com/r-plus/ScrollThindicator弹窗层：https://github.com/martinjuhasz/MJPopupViewControllertableview下拉图片放大：https://github.com/hunk/TwProfile选取iPod库播放音乐：https://github.com/gangverk/GVMusicPlayerControllerUIView动画：https://github.com/neror/ftutils类似clear的超强动画cell：https://github.com/mystcolor/JTGestureBasedTableViewDemo网易新闻背景图浮动：https://github.com/kenshin03/Home-For-iOS仿网易，新浪的push效果，带有阴影： http://code4app.com/ios/%E8%A7%86%E5%9B%BE%E5%88%87%E6%8D%A2%E5%A4%A7%E5%B0%8F%E6%B8%90%E5%8F%98%E6%95%88%E6%9E%9C/5124399a6803fae82c000000 https://github.com/vinqon/MultiLayerNavigation https://github.com/chisj/EuPopDemo实现原理：http://mobile1.riaos.com/?p=2025414新浪微博和朋友圈的图片浏览方式：1）https://github.com/Seitk/FB-Gallery2）https://github.com/jimneylee/SinaMBlogNimbuscoretext 运用：https://github.com/akosma/CoreTextWrapperN多自定义组件：https://github.com/boctor/idev-recipes可以换图片的pageControl：https://github.com/Spaceman-Labs/SMPageControl瀑布流：https://github.com/ptshih/PSCollectionViewiOS7的扁平UI：https://github.com/Grouper/FlatUIKit产品引导view：https://github.com/123nobody/WZGuideViewController类似safari的页面浏览：https://github.com/100grams/HGPageScrollView正则匹配UIView ：https://github.com/KayK/RegexHighlightView加密措施：https://github.com/dev5tec/FBEncryptorhttps://github.com/mayurbirari/AES256AndBase64自增长的键盘：https://github.com/HansPinckaers/GrowingTextView自定义的map Annotation :https://github.com/grgcombs/MultiRowCalloutAnnotationView超屌的3d画面：https://github.com/nicklockwood/iCarousel上拉刷新 ： https://github.com/dbsGen/SlimeRefresh翻页效果：https://github.com/brow/leaves类似maps的半截翻页：https://github.com/FairfaxMobile/FDCurlViewControl弹窗：https://github.com/martinjuhasz/MJPopupViewController对话框：https://github.com/jessesquires/MessagesTableViewControllerpagecurl的翻页效果：http://www.cocoachina.com/bbs/read.php?tid=11856&amp;keyword=%B5%D8%CD%BC二维码：http://www.cocoachina.com/applenews/devnews/2013/0104/5462.html自定义的annotation https://github.com/applidium/ADClusterMapView 类似国家地理的翻页：https://github.com/michaelhenry/MHNatGeoViewControllerTransitioniOS开发私有库：https://github.com/kennytm/iphone-private-frameworksviewController的切换（从右边进来）：https://github.com/steipete/PSStackedView安全存储用户名，密码等：https://github.com/granoff/LockboxFormSheet的神器：https://github.com/m1entus/MZFormSheetControlleriOS中model类的写法：https://github.com/github/Mantle相关介绍：https://github.com/blog/1299-mantle-a-model-framework-for-objective-cmodel类解析：https://github.com/nicklockwood/BaseModelbasemodel解析：https://github.com/andrep/RMModelObject蓝牙：https://github.com/xuanhuangyiqi/Anti-Lostmodel类比较好的库 https://github.com/icanzilb/JSONModel https://github.com/github/Mantle原生App的远程调试工具包：将缓存存在磁盘：https://github.com/rs/SDURLCachepath的欢迎页实现方式：https://github.com/icepat/ICETutorialpath的左下角菜单栏的同类实现方法：https://github.com/mattgemmell/MGTileMenucoredata的封装库：https://github.com/magicalpanda/MagicalRecordcoredata的 sql使用方式：https://github.com/marcoarment/FCModelzip文件解压缩：https://github.com/soffes/ssziparchive完美的图片category：https://github.com/Nyx0uf/NYXImagesKit纵向的scrollview循环利用：https://github.com/andreyvit/SoloComponents-iOSUINavigationController的push可能导致错误的效果的补充：https://github.com/Plasma/BufferedNavigationControllerUIKit的分类：https://github.com/enormego/cocoa-helpers左右滚动的scrollview（类似网易读图）：https://github.com/kejinlu/PagedFlowViewwebview控制器：https://github.com/samvermette/SVWebViewController滑动帧动画：https://github.com/IFTTT/JazzHandsiOS6的水滴下拉刷新：https://github.com/Sephiroth87/ODRefreshControl微信下拉显示logo：https://github.com/gluttony/RevealLogo支付宝的锁屏界面：https://github.com/kejinlu/KKGestureLockViewstatus bar的离线loading效果：http://www.cocoachina.com/bbs/read.php?tid=99947&amp;keyword=%CD%F8%D2%D7模仿百度地图向下推的层：https://github.com/mariohahn/MHDismissModalViewFileManager:https://github.com/nicklockwood/StandardPaths下拉头图放大：https://github.com/cyndibaby905/TwitterCover 访网易的左右滑动的view：http://code4app.com/ios/%E4%BB%BF%E7%BD%91%E6%98%93%E6%96%B0%E9%97%BB%E7%9A%84%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%E5%B8%83%E5%B1%80/5255fbd96803fa8660000000 左右横向滑动：https://github.com/MugunthKumar/MKHorizMenuDemotableview模仿path的时间表：https://github.com/kentnguyen/KNPathTableViewController弹出层：https://github.com/50pixels/FPPopover二维码登录：https://tiqr.org/弹出层：https://github.com/UrbanApps/UAModalPanelFacebook paper中的图片左右移动实现：https://github.com/chroman/CRMotionView横向滚动的tab https://github.com/pppoe/LightMenuBar https://github.com/MugunthKumar/MKHorizMenuDemo左右滑动的cell，有删除等功能：https://github.com/CEWendel/SWTableViewCell/不同速度的scrollview，用于做启动介绍页：https://github.com/5sw/SWParallaxScrollViewmattt写的解析html和xml的：https://github.com/mattt/Ono通过服务器动态修改客户端逻辑：https://github.com/mmin18/WaxPatchroutes，可以让按钮直接向点html的链接一样：https://github.com/joeldev/JLRoutes像新浪微博一样的图片浏览viewcontroller：https://github.com/jaredsinclair/JTSImageViewController像微信一样的search bar ：https://github.com/fabiankr/TableViewSearchBar图片浏览：https://github.com/EddyBorja/EBPhotoPages左滑动或右滑动cell：https://github.com/modocache/MDCSwipeToChoose类似iOS相册删除照片的动画效果：https://github.com/Ciechan/BCGenieEffect扁平化的uibutton：https://github.com/barbosa/GBFlatButton给app评分的组件1：https://github.com/nicklockwood/iRate给app评分的组件2：https://github.com/arashpayan/appiraterNSFileManager的封装：https://github.com/fabiocaccamo/FCFileManagerpaper的点击展开效果：https://github.com/hebertialmeida/HAPaperViewController柱状图：https://github.com/honcheng/iOSPlot点击titleview弹出下拉的menu：https://github.com/romaonthego/REMenu自定义开场图：https://github.com/ealeksandrov/EAIntroView让navbar跟着scrollview一起滚动：https://github.com/andreamazz/AMScrollingNavbar跟相册相关的：https://github.com/B-Sides/ELCImagePickerController更高效的显示地图上的大头针：https://github.com/choefele/CCHMapClusterControllerstreaming的音频播放：https://github.com/douban/DOUAudioStreamerXMPP的使用：https://github.com/adow/DollarssiOS7 mailbox的statusbar运用：https://github.com/simonholroyd/StatusBarTest国家地理的页面切换动画：https://github.com/michaelhenry/MHNatGeoViewControllerTransition引导页1：https://github.com/MatthewYork/MYBlurIntroductionView引导页2：https://github.com/MatthewYork/iPhone-IntroductionTutorial引导页3：https://github.com/ealeksandrov/EAIntroViewiOS7的电话button: https://github.com/mrcrow/MRoundedButton类似paper的导航抖动：https://github.com/andreamazz/AMWaveTransition下拉填充满字体：https://github.com/d-ronnqvist/blogpost-codesample-PullToRefreshgif播放 ：https://github.com/Flipboard/FLAnimatedImage视图切换：https://github.com/zoonooz/ZFDragableModalTransition类似游戏的菜单按钮，点击伸缩：https://github.com/sendoa/QBKOverlayMenuView模仿twitter的首页左右切换：https://github.com/duowan/TwitterPaggingViewer下载器：https://github.com/thibaultCha/TCBlobDownload网易新闻的离线下载bar:https://github.com/jaydee3/JDStatusBarNotification图片剪切和拆剪：https://github.com/kishikawakatsumi/PEPhotoCropEditor过度效果的status bar :https://github.com/nrj/AlphaGradientStatusBarFacebook’s paper的弹出层：https://github.com/UrbanApps/UAModalPanelObjective-C 和JavaScript 交互：https://github.com/marcuswestin/WebViewJavascriptBridgeCollectionView in UITableViewCell：https://github.com/AshFurrow/AFTabledCollectionViewpopview https://github.com/jmascia/KLCPopup https://github.com/andreamazz/AMPopTipUICollectionView replacement of UITableView （添加上section）：https://github.com/jamztang/CSStickyHeaderFlowLayoutstorekit： https://github.com/mattt/CargoBay替换Apple的Reachability判断网络：https://github.com/tonymillion/Reachability搜索控件search：https://github.com/dzenbot/DZNPhotoPickerController========================== UICollectionView相关===============https://github.com/bryceredd/RFQuiltLayout==========================helper相关===============https://github.com/andrewroycarter/UIView-Helpers==========================auto layout相关=======https://github.com/cloudkite/Masonryhttps://github.com/smileyborg/UIView-AutoLayouthttps://github.com/iMartinKiss/KeepLayoutpinterst的下拉刷新填充满的效果：https://github.com/uzysjung/UzysCircularProgressPullToRefresh==========================block相关=======================================https://github.com/jivadevoe/UIAlertView-Blockshttps://github.com/pandamonia/BlocksKit==========================iOS7相关=======================================iOS7颜色类：https://github.com/claaslange/iOS7ColorsiOS7：动态毛玻璃效果：https://github.com/alexdrone/ios-realtimebluriOS7 blur侧边栏：https://github.com/rnystrom/RNFrostedSidebariOS7 blur image：https://github.com/lukabernardi/LBBlurredImageiOS7 blur 效果：https://github.com/nicklockwood/FXBlurViewiOS7的uialertview:https://github.com/alexanderjarvis/PXAlertView边打字边出现标题：https://github.com/jverdi/JVFloatLabeledTextField扁平化的segment：https://github.com/pepibumur/PPiFlatSegmentedControliOS7视图切换炫酷效果：https://github.com/ColinEberhardt/VCTransitionsLibraryiOS7教学代码：https://github.com/ShinobiControls/iOS7-day-by-dayiOS7风格的抽屉导航：https://github.com/monospacecollective/MSDynamicsDrawerViewController颜色渐变的加载：https://github.com/nrj/GradientProgressViewiOS7demo：https://github.com/shu223/iOS7-SampleriOS正则分类：https://github.com/bendytree/Objective-C-RegEx-CategoriesiOS7侧边栏：https://github.com/romaonthego/RESideMenuiOS7侧边栏（覆在view上）https://github.com/romaonthego/REFrostedViewControlleriOS7库：https://github.com/youknowone/UI7Kit（可以让iOS5也有iOS7的样子）===========================测试框架=====http://www.cocoachina.com/applenews/devnews/2013/1025/7242.htmlhttps://github.com/kif-framework/KIFmattt大神的发布程序：https://github.com/nomad/shenzhen","tags":[{"name":"开源库","slug":"开源库","permalink":"http://seniorzhai.github.io/tags/开源库/"}]},{"title":"Github项目整理","date":"2015-01-24T05:24:17.000Z","path":"2015/01/24/Github项目整理/","text":"很多不错的项目在github start以后就石沉大海，没有很好的收集，即使使用astral收集，查找起来还是多有不便，遂开此篇保存一些集锦类的项目 Android开源项目分类汇总https://github.com/Trinea/android-open-project Swift项目精选https://github.com/ipader/SwiftGuide/blob/master/Featured.md Android开源交流QQ群分享汇总https://github.com/aosp-exchange-group/share Android 优秀开源项目实现原理解析https://github.com/android-cn/android-open-project-analysis iOS 学习资料整理https://github.com/Aufree/trip-to-iOS 中文 iOS/Mac 开发博客列表https://github.com/tangqiaoboy/iOSBlogCN","tags":[{"name":"github","slug":"github","permalink":"http://seniorzhai.github.io/tags/github/"}]},{"title":"schedule实现定时任务","date":"2015-01-22T08:56:37.000Z","path":"2015/01/22/schedule实现定时任务/","text":"node-schedule可是实现强大的定时任务功能安装无需赘述npm install node-schedule 使用步骤 设定时间 设定任务确定日期的任务12345678var schedule = require('node-schedule');var date = new Date(2015,1,22,16,30,0);var job = schedule.scheduleJob(date,function()&#123; console.log(\"执行任务！！！\");&#125;);// 取消任务job.cancel(); 确定分钟123456var rule = new schedule.RecurrenceRule();rule.minute = 42;var job = schedule.scheduleJob(rule,function()&#123; console.log('执行任务!!!');&#125;) 星期中某特定日期1234567var rule = new schedule.RecurrenceRule();rule.dayOfWeek = [0,new shcedule.Range(4,6)]; // 周四到周日rule.hour = 17;rule.minute = 0;var j = schedule.scheduleJob(rule,function()&#123; console.log('执行任务');&#125;); 每秒 可试用在分钟、小时上12345678910var times = []; for(var i=1; i&lt;60; i++)&#123; times.push(i); &#125;rule.second = times;var c=0;var j = schedule.scheduleJob(rule, function()&#123; c++; console.log(c);&#125;);","tags":[{"name":"定时任务","slug":"定时任务","permalink":"http://seniorzhai.github.io/tags/定时任务/"}]},{"title":"屏蔽emoji表情输入","date":"2015-01-22T03:33:09.000Z","path":"2015/01/22/屏蔽emoji表情输入/","text":"很多时候我们的输入不需要emoji表情，TextFilld输入时先判断不反回给编辑框，即可拦截1234567- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString*)string&#123; DLog(@&quot;[[UITextInputMode currentInputMode]primaryLanguage] is %@&quot;,); if ([[[UITextInputMode currentInputMode]primaryLanguage] isEqualToString:@&quot;emoji&quot;]) &#123; return NO; &#125; return YES;&#125;","tags":[{"name":"emoji","slug":"emoji","permalink":"http://seniorzhai.github.io/tags/emoji/"}]},{"title":"Express学习笔记-快速开始","date":"2015-01-20T03:45:05.000Z","path":"2015/01/20/Express学习笔记-快速开始/","text":"express是Node.js上最流行的Web开发框架，使用它可以快速的开发一个 Web 应用。 安装Express在命令行工具中下载Express1$ npm install -g express-generator 新建工程12$ express -e blog ## 新建工程 使用ejs模板引擎$ cd blog &amp;&amp; npm install ## 安装依赖 启动项目1DEBUG=blog node ./bin/www 工程结构1234567- app.js # 启动文件- bin/ # 存储工程信息及模块依赖- node_modules/ # 存放package.json中安装的模块，添加依赖的模块并安装后，存放在这个文件夹下- package.json # 存放image、css、js等文件- public # 存放路由文件- routes # 存放视图文件- views # 存放可执行文件 分析app.js1234567891011121314151617181920212223242526272829303132333435var app = express(); // 生成express实例app.set('views',path.join(__dirname,'views')); // 设置views文件夹为存放视图文件的目录，__dirname为全局变量，存放当前正在执行的脚本所在的目录app.set('view engine','ejs'); // 设置模板引擎为ejs// app.use(favicon(__dirname + '/public/favicon.ico')); // 设置favicon图标app.use(logger('dev')); // 加载日志中间件app.use(bodyParser.json()); // 加载解析JSON的中间件app.use(bodyParser.urlencoded(&#123;extended:false&#125;)); // 加载urlencoded请求的中间件app.use(cookieParser()); // 加载解析cookie的中间件app.use(express.static(path.join(__dirname,'public'))); // 设置public文件夹为静态文件的目录app.use('/',routes);app.use('/users',users); // 路由控制器app.use(function(req,res,next)&#123; // 捕获404错误 var err = new Error('Not Found'); err.status = 404; next(err);&#125;); if (app.get('env') === 'development') &#123; // 开发环境中，将错误信息直接渲染error模板并显示到浏览器 app.use(function(err,req,res,next)&#123; res.status(err.status || 500); res.render('error',&#123; message:err.message, error:err &#125;) &#125;)&#125;app.use(function(err,req,res,next)&#123; // 生产环境下，将错误信息选人成Error模板显示 res.status(err,status||500); res.render('err',&#123; message:err.message, error:&#123;&#125; &#125;);&#125;);module.exports = app; // 导出app实例供其他模块调用 bin/www文件123456789# ! /usr/bin/env node // 表明是node可执行文件var debug = require('debug')('blog') // 引入debug模块打印调试日志var app = require('../app'); // 引入app实例app.set('port',process.env.PORT || 3000); // 设置端口号var server = app.listen(app.get('port'),function()&#123; // 启动工程并监听3000端口 debug('Express server listening on port ' + server.address().port);&#125;); routes/index.js12345678var express = require('express');var router = express.Router();router.get('/',function(req,res)&#123; res.render('index',&#123;title:'Express'&#125;); // 渲染&#125;)module.exports = router; views/index.ejs1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 渲染模板时，传入的title值为Express字符串，模板引擎会将所有&lt;%= title %&gt;替换为express 路由控制在routes/index.js中123router.get('/',function(req,res)&#123; res.render('index',&#123;title:'Express'&#125;);&#125;); index.js问价就是用于管理app的路由，简单的路由分配为了实现路由的统一管理，可以把所有路由控制器和实现路由功能的函数都放在index.js里 在app.js中修改 123456789// 删除app.use('/', routes); app.use('/users', users);var routes = reuire('./routes/index');// ...// 去除所有路由控制的代码routes(app);app.listen(app.get('port'), function() &#123; console.log('Express server listening on port ' + app.get('port'));&#125;); 修改index.js 12345module.exports = function(app) &#123; app.get('/',function(req,res)&#123; res.render('index',&#123;title:'Express'&#125;); &#125;);&#125;; 路由规则express封装了多种http请求方式，主要使用get和post两种，即app.get()和app.post()这两个函数第一个参数都为请求的路径，第二个参数为处理请求的回调函数，回调函数的两个参数分别是req和res，表示请求信息和响应信息路径请求及对应的获取路径有以下几种形式 req.query处理GET请求，获取GET请求参数123456// GET /search?q=tobi+ferretreq.query.q // \"tobi ferret\"// GET /shoes?oder=desc&amp;shoe[color]=blue&amp;shoe[type]=conversereq.query.order // descreq.query.shoe.color // bluereq.query.shoe.type // converse req.body获取post请求，获取post请求123// POST user[name]=tobi&amp;user[email]=tobi@learnboost.comreq.body.user.name // tobireq.body.user.email // tobi@learnboost.com req.params处理/:xxx形式的get或post请求，获取请求参数1234// GET /user/tjreq.params.name // tj// GET /file/javascripts/jquery.jsreq.params[0] // javascripts/jquery.js req.param(name)处理get和post请求，但查找的优先级由高到低为req.parms-&gt;req.body-&gt;req.query123456// GET ?name=tobireq.param('name') // tobi// POST name=tobireq.param('name') // tobi// GET /user/tobi for /user/:namereq.param('name') // tobi 添加路由规则修改index.js，在app.get(‘/‘)函数后添加一条路由规则1app.get('/new',function(req,re))","tags":[{"name":"Express学习笔记","slug":"Express学习笔记","permalink":"http://seniorzhai.github.io/tags/Express学习笔记/"}]},{"title":"Express基础使用","date":"2015-01-19T12:24:01.000Z","path":"2015/01/19/Express基础使用/","text":"创建应用1234567var express = require('express');var app = express();app.get('/',function(req,res)&#123; res.send('hello world');&#125;)app.listen(3000); app设置值设置 app.set(name,value) 1app.set('title','My Site'); app.get(name) 1app.get('title'); // 'My Site' 选项设置 app.enable(name) // 设置某项为true app.disable(name) // 设置某项为false，禁用 app.enabled(name) // 检查某项是否为true app.disabled(name) // 检查某项是否为false 环境配置app.configure([env],callback)1234567891011121314// 所有环境app.configure(function()&#123; app.set('title', 'My Application');&#125;)// 开发环境app.configure('development', function()&#123; app.set('db uri', 'localhost/dev');&#125;)// 只用于生产环境app.configure('production', function()&#123; app.set('db uri', 'n.n.n.n/prod');&#125;) 更高效且直接的代码如下(历史遗留问题)：123456789101112// 所有环境app.set(&apos;title&apos;, &apos;My Application&apos;);// 只用于开发环境if (&apos;development&apos; == app.get(&apos;env&apos;)) &#123; app.set(&apos;db uri&apos;, &apos;localhost/dev&apos;);&#125;// 只用于生产环境if (&apos;production&apos; == app.get(&apos;env&apos;)) &#123; app.set(&apos;db uri&apos;, &apos;n.n.n.n/prod&apos;);&#125; 使用中间件app.use([path],function) path默认为”/“12345678910111213var express = require('express')var app = express()// 简单的loggerapp.use(function(req,res,next)&#123; console.log(\"%s %s\",req.method,req,url) next();&#125;)app.use(function(req,res,next)&#123; res.send('Hello World!')&#125;);app.listen(3000); setting使用内建的方式改变Express行为的设置 env 运行时环境，默认为 process.env.NODE_ENV 或者 “development” trust proxy 激活反向代理，默认未激活状态 jsonp callback name 修改默认?callback=的jsonp回调的名字 json replacer JSON replacer 替换时的回调, 默认为null json spaces JSON 响应的空格数量，开发环境下是2 , 生产环境是0 case sensitive routing 路由的大小写敏感, 默认是关闭状态， “/Foo” 和”/foo” 是一样的 strict routing 路由的严格格式, 默认情况下 “/foo” 和 “/foo/“ 是被同样对待的 view cache 模板缓存，在生产环境中是默认开启的 view engine 模板引擎 views 模板的目录, 默认是”process.cwd() + ./views” Requestreq.params命名过的参数会以键值对的形式存放，默认是{}12// GET /user/zoe 路由设置为/user/:namereq.params.name //zoe","tags":[{"name":"express","slug":"express","permalink":"http://seniorzhai.github.io/tags/express/"}]},{"title":"配置WebStorm支持node.js和Express","date":"2015-01-19T02:09:09.000Z","path":"2015/01/19/配置WebStorm支持node-js和Express/","text":"打开设置选择Node.js and NPM，选择node命令行路径(已安装会自动检测)，再选择下载或导入node的源码 之后可以在下面的Packages中管理模块，可以选择安装各个模块，包括express 之后在Libraies中选择Node.js的支撑 运行Express项目由于Express 4.0采用了scripts的启动方式，所以node app.js不能启动应用采用npm start可以启动应用在WebStorm上可以这么设置","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"},{"name":"WebStorm","slug":"WebStorm","permalink":"http://seniorzhai.github.io/tags/WebStorm/"},{"name":"Express","slug":"Express","permalink":"http://seniorzhai.github.io/tags/Express/"}]},{"title":"node核心模块（一）","date":"2015-01-17T05:33:12.000Z","path":"2015/01/17/node核心模块（一）/","text":"全局对象Node.js中的全局对象是global，所有全局变量都是global的属性 processprocess是一个全局变量，用于描述当前Node.js进程状态，提供了一个与操作系统的简单接口 process.argv是命令行参数的数组 process.studout 标准输出流 process.stdin 标准输入流，初始化时它使被暂停的，必须恢复读取数据，并手动编写流的时间响应函数 1234process.stdin.resume()process.stdin.on('data',function(data)&#123; process.stdout.write('read from console: ' + data.toString());&#125;); process.nextTick(callback) 为事件循环设置一项任务，Node.js会在下次时间循环响应时调用callback 12345678function doSomething(args,callback) &#123; somthingComplicated(args); callback();&#125;doSomething(function onEnd()&#123; compute();&#125;); 假设上面的代码中somthingComplicated()和compute()函数都是较为耗时的函数，上面的代码会先执行somthingComplicated()立即执行compute()12345678function doSometing(args,callback) &#123; somthingComplicated(args); process.nextTick(callback);&#125;doSomething(fucntion onEnd()&#123; compute();&#125;) consoleconsole用于控制台的标准输出 console.log() 向标准输出流打印字符串以及换行符，也可以接受C语言printf()命令的格式输出 console.error() 向标准错误流输出 console.trace() 向标准错误流输出当前的调用栈 常用工具utilutil是Node.js核心模块，提供了常用函数的集合，用于弥补核心JavaScript的功能过于精简的不足 util.inherits实现对象原型继承的函数 1234567891011121314151617181920212223var util = require('util');function Base() &#123; this.name = 'base'; this.base = 1991; this.sayHello = function() &#123; console.log('Hello' + this.name); &#125; this.prototype.showName = function() &#123; console.log(this.name); &#125;&#125;;function Sub() &#123; this.name = 'sub';&#125;util.inherits(Sub,Base);var obj = new Sub()obj.showNameconsole.log(obj) 注；Sub仅仅继承了Base在原型中定义的函数，内部创造的base和sayHeloo都没有被继承 util.inspectutil.inspect(object,[showHidden],[depth],[colors])是将任意对象转换成字符串的方法可选参数showHideen控制是否输出更多隐藏信息depth表示最大递归层数，默认递归2层，指定为null表示不限层数完整递归color控制是否用ANSI颜色编码输出 事件驱动eventsevents是Node.js最终要的模块，原因是Node.js本身的架构就是事件式的 事件发射器events模块只提供一个对象events.EventEmitter。EventEmitter对事件发射和事件监听功能进行了封装，每个事件由事件名和若干个参数组成，事件名是一个字符串。对于每个事件，EventEmitter支持若干个事件监听器，当事件发送时注册的事件监听器被依次调用，事件参数作为回调函数参数传递 1234567891011121314var events = require('events');var emitter = new events.EventEmitter();// 注册`someEvent`事件监听emitter.on('someEvent',function(arg1,arg2)&#123; console.log('listner1',arg1,arg2);&#125;)emitter.on('someEvent',function(arg1,arg2)&#123; console.log('listner2',arg1,arg2);&#125;)// 发送事件emitter.emit('someEvent','zoe',1991); EventEmitter.on(event,listener) 为指定事件注册一个监听器 EventEmitter.emit(event,[arg1],[arg2],[…]) 发射event时间，可传递若干参数 EventEmitter.once(event,listener) 为指定时间注册一个单次监听器，即监听器最多只会触发一次，触发后立即解除监听 EventEmitter.removeListener(event,listener) 移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器 EventEmitter.removeAllListener([event]) 移除所有时间的所有监听器，如果指定event则移除指定时间的所有监听器error事件EventEmitter定义了一个特殊的时间error，在遇到异常时会发射error，如果没有响应的监听器，Node.js会把它当做异常，退出程序打印调用栈。12345var events = require('events');var emitter = new events.EventEmitter();emitter.emitter('error'); 继承EventEmitter很多时候，我们不会直接使用EventEmitter，而是在对象中继承它，包括fs，net，http在内的基于事件响应的核心模块都是EventEmitter的子类 文件系统fsfs模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等文件系统操作，fs还提供了异步和同步两个版本 fs.readFilefs.readFile(filename,[encoding],[callback(err,data)])是最简单的读取文件的函数，它接受一个必选参数filename表示要读取的文件名，第二个参数encoding表示文件的字符编码，callback是回调函数，err表示是否有错误，data是文件内容，如果没有指定encoding，data会是Buffer形式表示的二进制数据123456789var fs = require('fs')fs.readFile('error.js','utf-8',function(err,data)&#123; if(err)&#123; console.log(err) &#125; else &#123; console.log(data) &#125;&#125;) fs.readFileSyncfs.readFileSync是fs.readFile同步版本，读取到的数据会以返回值的形式返回，需要使用try和catch捕捉处理异常 fs.openfs.open(path,flags,[mode],[callback(err,fd)])，path为文件路径，flags可以使以下值 r 以读取模式打开文件 r+ 以读写模式打开文件 w 以写入模式打开文件，如果文件不存在则创建 w+ 以读写模式打开文件，如果文件不存在则创建 a 以追加模式打开文件，如果不存在则创建 a+ 以读取追加模式打开文件，如果不存在则创建mode参数用于创建文件制定权限，默认是0666，回调函数将会传递一个文件描述符fdfs.readfs.read(fd,buffer,offset,length,postion,[callback(err,bytesRead,buffer)])从制定的文件描述符fd中读取数据并写入buffer指向的缓冲区对象，offset是buffer的写入偏移量，length是要从文件中读取的字节数，position是文件读取的起始位置，如果position的值为null，则会从当前文件指针的位置读取，回调函数传递bytesRead和buffer分别表示读取的字节数和缓冲区对象12","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://seniorzhai.github.io/tags/HTTP/"}]},{"title":"node核心模块（二）","date":"2015-01-17T05:33:12.000Z","path":"2015/01/17/node核心模块（二）/","text":"Node.js标准库提供了http模块，其中封装了一个高效的HTTP服务器和简易的HTTP客户端。http.Server是一个基于事件的HTTP服务器，核心由C++部分实现，接口由JavaScripte封装，兼顾了高性能和简易性http.request则是一个HTTP客户端工具，用于HTTP服务器发起请求 HTTP服务器http.Server是http模块中的HTTP服务器对象123456var http = require('http')http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html'&#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end(\"&lt;p&gt;Hello World&lt;/p&gt;\");&#125;).listen(3000); http.Server的事件 request 客户端请求到来时该事件被触发，提供两个参数req和res，分别是http.ServerRequest和http.ServerResponse的实例，表示请求和响应信息 connection 当TCP链接建立时，该事件被触发，提供了一个参数socket，为net.Socket的实例 close 当服务器关闭时，该事件被触发此外还有checkContinue、upgrade、clientError事件，通常不需要关心最常用到的时request，为此http提供了http.createServer([requestListener])，功能是创建HTTP服务器并将requestListener作为request事件的监听函数123456789var http = require('http')var server = new http.Server();server.on('request',function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/html'&#125;); res.write('&lt;h1&gt;Node.js&lt;/h1&gt;'); res.end(\"&lt;p&gt;Hello World&lt;/p&gt;\");&#125;);server.listen(3000); http.ServerRequesthttp.ServerRequest是HTTP请求的信息，是后端开发者最关注的内容，一般由http.Server的request事件发送，作为参数，通常简称req或requestHTTP请求一般分为两部分:请求头(RequestHeader)和请求体(RequestBody)，http.ServerRequest提供了3个事件用于控制请求体的传输 data 当请求体数据到来时，事件触发，该事件提供了一个参数chunk，表示接收到的数据，如果该事件没有被监听，那么请求体会被抛弃 end 当请求体传输完成时，该事件被触发，此后将不会再有数据到来 close 用户请求结束时，该事件被触发 ServerRequest的属性|名称|含义||:–|:—||complete|客户端请求是否已经发送完成||httpVersion|HTTP协议版本，通常是1.0或1.1||method|HTTP请求方法，如GET、POST、PUT、DELETE等||url|原始的请求路径||headers|HTTP请求头||trailers|HTTP请求尾(不常见)||connection|当前HTTP链接套接字，为net.Socket的实例||socket|connection属性的别名||client|client属性的别名| 获取GET请求1234567var http = require('http')var url = require('url')var util = require('util')http.createServer(function(req,res)&#123; res.writeHead(200,&#123;'Content-Type':\"text/plain\"&#125;); res.end(util.inspect(url.parse(req.url,true)));&#125;).listen(3000); 获取POST请求12","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://seniorzhai.github.io/tags/HTTP/"}]},{"title":"node.js包","date":"2015-01-16T12:39:34.000Z","path":"2015/01/16/node-js包/","text":"复杂的模块往往由多个子模块组成，为了便于管理和使用，多个子模块组成的大模块称为包，并将所有子模块放在同一个目录里文件结构一般如下1234- cat/ head.js body.js main.js main.js作为入口模块12345678910var head = require('./head')var body = require('./body')export.create = function(name) &#123; return &#123; name:name, head:head.create(), body:body.create() &#125;&#125; 当模块名为index.js加载模块时可以使用模块所在目录的路径替代模块文件路径以下两句话是等价的12var cat = require('/home/user/lib/cat');var cat = require('/home/user/lib/cat/index'); package.json可以自定义入口模块的文件名和存放位置 一般的工程目录就会如下123456789-bin/ # 命令行相关代码 node-echo+ doc/ # 文档- lib/ # 存放API相关代码 echo.js- node_modules/ # 存放第三方包 + argv/package.json # 元数据文件README.md # 说明文件","tags":[{"name":"package","slug":"package","permalink":"http://seniorzhai.github.io/tags/package/"},{"name":"包","slug":"包","permalink":"http://seniorzhai.github.io/tags/包/"}]},{"title":"node.js模块","date":"2015-01-16T12:32:34.000Z","path":"2015/01/16/node-js模块/","text":"模块的基本单位就是单个JS文件 requirerequire函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回模块导出对象 1var foo1 = require('./foo') exportsexports对象是当前模块的导出对象，用于导出模块共有方法和属性 123exports.hello = function() &#123; console.log('Hello World!');&#125; module通过module对象可以访问到当前模块的一些相关信息，但更多时候用于替换当前模块的导出对象 123module.exports = function() &#123; console.log('Hello World!');&#125;; 模块仅在第一次被使用的时候执行初始化","tags":[{"name":"模块","slug":"模块","permalink":"http://seniorzhai.github.io/tags/模块/"},{"name":"module","slug":"module","permalink":"http://seniorzhai.github.io/tags/module/"}]},{"title":"JavaScript基础","date":"2015-01-16T10:23:20.000Z","path":"2015/01/16/JavaScript基础/","text":"JavaScript基础变量变量可以存放值(x=1)和表达式(y=x+1)变量名字母、数字、少量字符($、_)组成，必须使用字母、字符(但是不建议这么做)开头，变量名对大小写敏感 声明JavaScript使用var声明变量，声明后，默认是没有值(undefined) JavaScript支持重新声明，之前赋的值不会丢失数据类型 字符串，使用单引号或双引号包括 数字，可以使小数可以使用指数 布尔，true和false 数组， var cars = new Array() var cars = new Array(“Audi”,”BMW”,”Volvo”) var cars = [“Adudi”,”BMW”] 对象 var person = {name:”Bill”,age:1} person.name person.age var person = new Object() person.name = “Bill” Undefined 没有值 Null 通过设置null来清空数据在JavaScript一切都是对象，如字符串 txt = “text” txt.length // 4 txt.indexOf() txt.replace() txt.search()","tags":[{"name":"基础","slug":"基础","permalink":"http://seniorzhai.github.io/tags/基础/"},{"name":"js","slug":"js","permalink":"http://seniorzhai.github.io/tags/js/"},{"name":"javascript","slug":"javascript","permalink":"http://seniorzhai.github.io/tags/javascript/"}]},{"title":"常用.gitignore","date":"2015-01-14T12:54:19.000Z","path":"2015/01/14/常用-gitignore/","text":"使用git时，通常我们需要使用.gitignore文件来设定，隐藏那些文件，防止被git跟踪https://github.com/github/gitignore项目收集了大量的常用.gitignore文件，方便我们的使用 Android: 1234567891011121314151617181920# Built application files*.apk*.ap_# Files for the Dalvik VM*.dex# Java class files*.class# Generated filesbin/gen/# Gradle files.gradle/build//*/build/# Local configuration file (sdk path, etc)local.properties# Proguard folder generated by Eclipseproguard/# Log Files*.log Objective-C 12345678910111213141516171819202122232425# Xcode# build/*.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdata*.xccheckout*.moved-asideDerivedData*.hmap*.ipa*.xcuserstate# CocoaPods# # We recommend against adding the Pods directory to your .gitignore. However# you should judge for yourself, the pros and cons are mentioned at:# http://guides.cocoapods.org/using/using-cocoapods.html# should-i-ignore-the-pods-directory-in-source-control# # Pods/","tags":[{"name":"git","slug":"git","permalink":"http://seniorzhai.github.io/tags/git/"},{"name":"隐藏","slug":"隐藏","permalink":"http://seniorzhai.github.io/tags/隐藏/"}]},{"title":"8年来iPhone的变化","date":"2015-01-12T05:38:31.000Z","path":"2015/01/12/8年来iPhone的变化/","text":"","tags":[{"name":"iPhone","slug":"iPhone","permalink":"http://seniorzhai.github.io/tags/iPhone/"}]},{"title":"在Android上使用NoSQL数据库","date":"2015-01-08T02:06:02.000Z","path":"2015/01/08/在Android上使用NoSQL数据库/","text":"NoSQL泛指非关系数据库，随着web2.0网站的兴起迅速发展。相对于SQLite数据库，NoSQL无意更加快速、更加轻量级、存取数据方便，不需要设计多张表。 SnappyDBSnappyDB是众多NoSQL数据库的一员，Android上非常流行的NoSQL数据库，可以保存任何基本数据类型和序列化(Serializable)的数据及其数组SnappyDB在保存和读取序列对象的时候，使用的是Kryo库，也Java内置序列化更快。更大的优势是，你并不要为数据去显式的去实现Serializable接口。这就意味着你以前的代码完全不要做任何改动。 创建数据库DB snappydb = DBFactory.open(context); // 默认名的数据库 DB snappydb = DBFactory.open(context,&quot;books&quot;); // 指定名字的数据库 SnappyDB使用内部存储空间，路径为:/data/data/com.snappydb/files/mydatabase也可以使用参数指定存储位置1234DB snappyDB = new SnappyDB.Builder(context) .directory(Environment.getExternalStrongeDirectory().getAbsolutePath()) .name(\"books\") .build(); 关闭数据库snappydb.close(); 销毁数据库snappydb.destroy(); 插入基本数据 short snappyDB.putShort(&quot;myshort&quot;,(short)32768); int snappyDB.putInt(&quot;myint&quot;,Integer.MAX_VALUE); long snappyDB.putLong(&quot;mylong&quot;,Long.MAX_VALUE); double snappyDB.putDouble(&quot;my_double&quot;,Double.MAX_VALUE); float snappyDB.putFloat(&quot;my_float&quot;,10.30f); boolean snappyDB.putBoolean(&quot;my_bollean&quot;,true); String snappyDB.put(&quot;my_string&quot;,&quot;string&quot;); 读取基本数据 short short myshort = snappyDB.getShort(&quot;myshort&quot;); int int myInt = snappyDB.getInt(&quot;myint&quot;); long long myLong = snappyDB.getLong(&quot;mylong&quot;); double double myDouble = snappyDB.getDouble(&quot;my_double&quot;); float float myFloat = snappyDB.getFloat(&quot;my_float&quot;); boolean boolean myBool = snappyDB.getBoolean(&quot;my_bollean&quot;); String String myString = snappyDB.get(&quot;my_string&quot;); 插入序列化对象AtomicInteger objAtomicInt = new AtomicInteger (42); snappyDB.put(&quot;atomic integer&quot;, objAtomicInt); 读取序列化对象AtomicInteger myObject = snappyDB.get(&quot;atomic integer&quot;, AtomicInteger.class); 插入对象MyPojo pojo = new MyPojo (); snappyDB.put(&quot;my_pojo&quot;, pojo); 读取对象MyPojo myObject = snappyDB.getObject(&quot;non_serializable&quot;, MyPojo.class); 插入数组Number[] array = {new AtomicInteger (42), new BigDecimal(&quot;10E8&quot;), Double.valueOf(Math.PI)}; snappyDB.put(&quot;array&quot;, array); 读取数组Number [] numbers = snappyDB.getObjectArray(&quot;array&quot;, Number.class); 。。。待续","tags":[{"name":"数据库","slug":"数据库","permalink":"http://seniorzhai.github.io/tags/数据库/"},{"name":"NoSQL","slug":"NoSQL","permalink":"http://seniorzhai.github.io/tags/NoSQL/"},{"name":"轻量级","slug":"轻量级","permalink":"http://seniorzhai.github.io/tags/轻量级/"}]},{"title":"偷懒的findViewById","date":"2015-01-07T09:36:29.000Z","path":"2015/01/07/偷懒的findViewById/","text":"123456// 在Activity的基类中定义protected &lt;T extends View&gt; T $ (int id) &#123; return (T) findViewById(id);&#125; // 使用很简单bn = $(R.id.bn1);","tags":[{"name":"findViewById","slug":"findViewById","permalink":"http://seniorzhai.github.io/tags/findViewById/"}]},{"title":"ToolBar的使用","date":"2015-01-07T01:54:45.000Z","path":"2015/01/07/ToolBar的使用/","text":"ToolBar属于ActionBar的升级版，扩展了ActionBar，使得我们可以像使用独立的控件一样使用ToolBar。 风格(Style)1234&lt;style name=\"AppTheme.Base\" parent=\"Theme.AppCompat\"&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"android:windowNoTitle\"&gt;true&lt;/item&gt;&lt;/style&gt; 界面(Layout)12345&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" android:minHeight=\"?attr/actionBarSize\" /&gt; colorPrimaryColor Toolbar的颜色 在layout文件中设置background属性 colorPrimaryDark 状态栏背景色 textColorPrimary 标题和更多菜单中文字的颜色 colorAccent 可勾选控件被选择的颜色 colorControlNormal 各控件预设的颜色 windowBackground App的背景色 navigationBarColor 导航栏的背景色(API Level需要大于) 注：以上在style中设置 配合DrawerLayout使用12345setSupportActionBar(mToolbar);mDrawerLayout = (DrawerLayout) findViewId(R.id.drawer);mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, mToolbar, R.string.drawer_open, R.string.drawer_close);mDrawerLayout.setDrawerListener(mDrawerToggle); 示例 布局 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:background=\"# 2196F3\" style=\"@style/ToolBarStyle\" android:minHeight=\"?attr/actionBarSize\" /&gt; &lt;android.support.v4.widget.DrawerLayout android:id=\"@+id/drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"200dp\" android:background=\"@android:color/white\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" &gt;&lt;/LinearLayout&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/LinearLayout&gt; style 123456789101112131415161718192021222324252627282930313233343536&lt;resources xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;style name=\"AppBaseTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- toolbar（actionbar）颜色 --&gt; &lt;item name=\"colorPrimary\"&gt;# 4876FF&lt;/item&gt; &lt;!-- 状态栏颜色 --&gt; &lt;item name=\"colorPrimaryDark\"&gt;# 3A5FCD&lt;/item&gt; &lt;!-- 窗口的背景颜色 --&gt; &lt;item name=\"android:windowBackground\"&gt;@color/backgroud&lt;/item&gt; &lt;!-- 标题颜色 --&gt; &lt;item name=\"android:textColorPrimary\"&gt;# FFFFFF&lt;/item&gt; &lt;!-- 箭头 --&gt; &lt;item name=\"drawerArrowStyle\"&gt;@style/AppTheme.DrawerArrowToggle&lt;/item&gt; &lt;!-- 菜单按钮 --&gt; &lt;item name=\"actionOverflowButtonStyle\"&gt;@style/AppTheme.overflow&lt;/item&gt; &lt;/style&gt; &lt;style name=\"AppTheme\" parent=\"@style/AppBaseTheme\"/&gt; &lt;!-- 箭头颜色 --&gt; &lt;style name=\"AppTheme.DrawerArrowToggle\" parent=\"Base.Widget.AppCompat.DrawerArrowToggle\"&gt; &lt;item name=\"color\"&gt;@android:color/white&lt;/item&gt; &lt;/style&gt; &lt;!-- 替换菜单文件 --&gt; &lt;style name=\"AppTheme.overflow\" parent=\"Widget.AppCompat.ActionButton.Overflow\"&gt; &lt;item name=\"android:src\"&gt;@drawable/android&lt;/item&gt; &lt;/style&gt; &lt;!-- popup style --&gt; &lt;style name=\"ToolBarStyle\" parent=\"\"&gt; &lt;item name=\"popupTheme\"&gt;@style/ThemeOverlay.AppCompat.Light&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends ActionBarActivity implements DrawerLayout.DrawerListener &#123; private DrawerLayout drawerLayout; private Toolbar toolbar; private ActionBarDrawerToggle toggle; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = $(R.id.toolbar); drawerLayout = (DrawerLayout) findViewById(R.id.drawerlayout); toolbar.setTitle(\"Title\"); setSupportActionBar(toolbar); toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.app_name, R.string.action_settings); toggle.syncState(); drawerLayout.setDrawerListener(toggle); &#125; protected &lt;T extends View&gt; T $(int id) &#123; return (T) findViewById(id); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); if (id == R.id.action_settings) &#123; Toast.makeText(this, \"setting\", Toast.LENGTH_SHORT).show(); return true; &#125; return super.onOptionsItemSelected(item); &#125; @Override protected void onPostCreate(Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); toggle.syncState(); &#125; @Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); toggle.onConfigurationChanged(newConfig); &#125; // 滑动时回调 @Override public void onDrawerSlide(View view, float v) &#123; &#125; // 打开时回调 @Override public void onDrawerOpened(View view) &#123; &#125; // 关闭时回调 @Override public void onDrawerClosed(View view) &#123; &#125; // 改变状态时回调 @Override public void onDrawerStateChanged(int i) &#123; &#125;&#125;","tags":[{"name":"ToolBar","slug":"ToolBar","permalink":"http://seniorzhai.github.io/tags/ToolBar/"}]},{"title":"常见的开源协议","date":"2015-01-06T09:51:53.000Z","path":"2015/01/06/常见的开源协议/","text":"BSD 再发布的产品包含源代码，源代码中必须带有原来代码的BSD协议 如果发布的只是二进制库或者软件，在文档和版权声明中包含原有代码中的BSD协议 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对 商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。 AL2.0Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似： 需要给代码的用户一份Apache Licence 如果你修改了代码，需要在被修改的文件中说明。 在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。 GPL我们很熟悉的Linux就是采用了GPL。GPL协议和BSD， Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代 码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商 业软件公司开发的免费软件了。GPL协议的主要内容是只要在一个软件中使用（”使用”指类库引用，修改后的代码或者衍生代码）GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题， 还可以享受免费的优势。由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。 LGPLLGPL 是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用（link）方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并 发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因 此LGPL协议的开源 代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 MITMIT是和BSD一样宽范的许可协议，作者只想保留版权，而无任何其它的限制。也就是说，你必须在你的发行版里包含原许可协议的声明，无论你是以二进制发布的还是以源代码发布的。MIT协议又称麻省理工学院许可证，最初由麻省理工学院开发。被授权人权利： 被授权人有权利使用、复制、修改、合并、出版发行、散布、再授权及贩售软件及软件的副本。 被授权人可根据程式的需要修改授权条款为适当的内容。被授权人义务：在软件和软件的所有副本中都必须包含版权声明和许可声明。 被授权人义务：在软件和软件的所有副本中都必须包含版权声明和许可声明。","tags":[]},{"title":"RecyclerView的使用","date":"2015-01-06T06:42:31.000Z","path":"2015/01/06/RecyclerView的使用/","text":"RecylerView作为ListView，RecylerView标准化了ViewHolder，不同于ListView中复用convertView是复用的，在RecyclerView把ViewHolder作为缓存的单位。RecylerView作为一个容器，能够有效的重用和滚动 - 它为item的定位提供了LayoutManager - 为item提供了一个缺省的animations，方便设置动画 使用使用RecyclerView需要指定adapter和layoutmanager，且Adapter必须继承RecyclerView.Adapter","tags":[]},{"title":"CardView的使用","date":"2015-01-06T05:38:32.000Z","path":"2015/01/06/CardView的使用/","text":"CardView继承至FrameLayout类，可以在一个卡片布局中一致性的显示内容，卡片可以包含圆角和阴影。CardView是一个Layout，可以布局其他View。CardView常用属性： card_view:cardElevation 阴影的大小 card_view:cardMaxElevation 阴影最大高度 card_view:cardBackgroundColor 卡片的背景色 card_view:cardCornerRadius 卡片的圆角大小 card_view:contentPadding 卡片内容于边距的间隔 card_view:contentPaddingBottom card_view:contentPaddingTop card_view:contentPaddingLeft card_view:contentPaddingRight card_view:contentPaddingStart card_view:contentPaddingEnd card_view:cardUseCompatPadding 设置内边距，V21+的版本和之前的版本仍旧具有一样的计算方式 card_view:cardPreventConrerOverlap 在V20和之前的版本中添加内边距，这个属性为了防止内容和边角的重叠 12345678910 &lt;android.support.v7.widget.CardView xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"200dp\" android:layout_height=\"wrap_content\" card_view:cardBackgroundColor=\"# 303069\" card_view:cardCornerRadius=\"10dp\" card_view:cardPreventCornerOverlap=\"true\" card_view:cardUseCompatPadding=\"true\" card_view:contentPadding=\"10dp\"&gt; ...&lt;/android.support.v7.widget.CardView&gt; 注：在gradle的dependencies中添加compile &#39;com.android.support:cardview-v7:21.+&#39; 示例","tags":[{"name":"CardView","slug":"CardView","permalink":"http://seniorzhai.github.io/tags/CardView/"}]},{"title":"Palette取色","date":"2015-01-06T02:35:47.000Z","path":"2015/01/06/Palette取色/","text":"Palette可以从图像中提取突出的颜色，可以利用它把色值赋给ActionBar或者其他空间，可以让界面整个色调统一12345Bitmap bm = BitmapFactory.decodeResouce(getResources(),item.image);Palette palette = Palette.generate(bm);if(palette.getLightVibrantColor() != null) &#123; getSupportActionBar().setBackgroundDrawable(new ColorDrawable(palette.getLightVibrantColor().getRgb())); &#125; Palette可以取出以下突出的颜色 Vibrant （有活力） Vibrant dark（有活力 暗色） Vibrant light（有活力 亮色） Muted （柔和） Muted dark（柔和 暗色） Muted light（柔和 亮色） Gradle中的dependencies中添加compile &#39;com.android.support:palette-v7:21.0.+&#39;示例","tags":[{"name":"Api","slug":"Api","permalink":"http://seniorzhai.github.io/tags/Api/"},{"name":"取色","slug":"取色","permalink":"http://seniorzhai.github.io/tags/取色/"}]},{"title":"Android模拟事件","date":"2015-01-05T05:50:31.000Z","path":"2015/01/05/Android模拟事件/","text":"使用Shell命令Android中自带一个input工具，使用方法如下 模拟按键操作123adb shell # 进入系统input keyevent KEYCODE_BACK # 模拟返回键input keyevent keyevent 3 # 模拟返回键 常见的按键可以在http://developer.android.com/reference/android/view/KeyEvent.html查看 对获得焦点的输入框，输入文本1input text hello # 输入hello文本 输入的文本不能带空格，也不能是中文 模拟点击屏幕事件1input tap 100 200 # 在屏幕坐标(100,200)处点击 注：坐标是从左上角开始计算的 还可以模拟长按、滑动等 命令 input [] […] source 指定输入设备 trackball 轨迹球 joystick 操控杆 touchnavigation mouse keyboard gamepad touchpad dpad stylus touchscreen command 指定动作 text (默认设备touchscreen) keyevent [–longpress] … (默认设备keyboard) tap (默认设备touchscreen) swipe [duration(ms)] (默认设备touchscreen) press (默认设备trackball) roll (默认设备trackball) tmode 使用InstrumentationInstrumentation是Android用来测试的工具，可以监测系统与应用程序之间的交互，可以使用他发送按键或者触屏事件 发送按键 12Instrumentation mInst = new Instrumentation();mInst.sendKeyDownUpSync(KeyEvent.KEYCODE_CAMERA); // 同步发送一个按下和弹起事件 触屏事件 12345Instrumentation mInst = new Instrumentation(); mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0);mInst.sendPointerSync(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, x, y, 0); 发送文本 1sendPointerSync(\"text\"); 注：以上代码都需要权限的支持，需要在AndroidManifast.xml中添加 ，但还有一些复杂的问题，可以参考这里 使用内部API在Android系统中，有些内部的API提供注入事件的方法。因为是内部API，在不同版本上可能变化比较大。使用如果想在普通App中使用，可能需要通过反射机制来调用。 在Android API 16之前，WindownManager有相应的方法提供注入事件的方法，如下：123456IBinder wmbinder = ServiceManager.getService(\"window\"); IWindowManager wm = IWindowManager.Stub.asInterface(wmbinder); //pointer wm.injectPointerEvent(myMotionEvent, false); //key wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_A), false); wm.injectKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_A), false); //trackball wm.injectTrackballEvent(myMotionEvent, false); 在API 15之后，引入了InputManager，把上面的哪些injectXXXEvent()方法从WindowManager中移除了。使用方法类似：1234567891011121314IBinder imBinder = ServiceManager.getService(\"input\"); IInputManager im = IInputManager.Stub.asInterface(imBinder);//inject key eventfinal KeyEvent keyEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM |KeyEvent.FLAG_KEEP_TOUCH_MODE | KeyEvent.FLAG_SOFT_KEYBOARD, source);event.setSource(InputDevice.SOURCE_ANY) im.injectInputEvent(keyEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);//inject pointer eventmotionEvent.setSource(InputDevice.SOURCE_TOUCHSCREEN); im.injectInputEvent(motionEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH); 从API 16开始，InputManager就成了一个公开的类了，可以通过如下方法获得InputManager实例：1InputManager im = (InputManager) getSystemService(Context.INPUT_SERVICE); 注意，使用injectEvent()需要申明android:name=&quot;android.permission.INJECT_EVENTS&quot;权限。 使用Nativ/JNI调用察看Android设备的/dev/input/目录下的设备：1234567shell@user:/dev/input $ ll crw-rw---- root input 13, 64 2013-08-11 18:00 event0 crw-rw---- root input 13, 65 2013-08-11 18:00 event1 crw-rw---- root input 13, 66 2013-08-11 18:00 event2 crw-rw---- root input 13, 67 2013-08-11 18:00 event3 crw-rw---- root input 13, 68 2013-08-11 18:00 event4 crw-rw---- root input 13, 69 2013-08-11 18:00 event5 可以看到有一些输入设备节点，同时也提供了一些shell工具来操作这些设备，例如上面第1节中提到的input命令，另外还有getevent和sendevent工具分别来监听和发送事件。这些方法，都可以通过JNI的方式调用。这里需要注意的时间eventX设备都是input的用户组，要直接使用，需要root设备。 特别的是，这里有一个开源项目android-event-injector，使用JNI方法注入事件。当然设备需要root。","tags":[{"name":"模拟","slug":"模拟","permalink":"http://seniorzhai.github.io/tags/模拟/"},{"name":"事件","slug":"事件","permalink":"http://seniorzhai.github.io/tags/事件/"},{"name":"测试","slug":"测试","permalink":"http://seniorzhai.github.io/tags/测试/"}]},{"title":"Fragment生命周期详解","date":"2015-01-05T02:25:15.000Z","path":"2015/01/05/Fragment生命周期详解/","text":"onAttach() 关联Activity时调用 onCreate() 创建Fragment时调用，在这里必须初始化Fragment的基础组件 onCreateView() Fragment要绘制自己的界面时调用，这个方法必须返回Fragment的layout，也可以返回null(表示没有界面) onActivityCreated() 当Activity对象完成自己的onCreate方法时调用 onStart() Fragment的UI可见时调用 onResume() Fragment的UI可交互时调用 onPause() Fragment 可见但不可交互时调用 onStop() Fragment 完全不可见时调用 onDestroyView() Fragment 移除视图时调用 onDestroy() 清理View资源时调用 onDetach() 失去Activity关联时调用 切换到Fragment(第一次) onAttach onCreate onCreateView onActivityCreated onStart onResume 屏幕熄灭 onPause onSaveInstanceState onStop 屏幕解锁 onStart onResume 切换到其他Fragment onPause onStop onDestroyView 切换回本身 onCreateView onActivityCreated onStart onResume 回到桌面 onPause onSaveInstanceState onStop 回到应用 onStart onResume 退出应用 onPause onStop onDestroyView onDestroy onDetach","tags":[{"name":"生命周期","slug":"生命周期","permalink":"http://seniorzhai.github.io/tags/生命周期/"},{"name":"Fragment","slug":"Fragment","permalink":"http://seniorzhai.github.io/tags/Fragment/"}]},{"title":"[转]Storyboard中的UIScrollView使用自动布局，使其能够滚动","date":"2015-01-05T01:36:16.000Z","path":"2015/01/05/-转-Storyboard中的UIScrollView使用自动布局，使其能够滚动/","text":"在使用storyboard和xib时，我们经常要用到ScrollView，还有自动布局AutoLayout，但是ScrollView和AutoLayout 结合使用，相对来说有点复杂。根据实践，我说一下我的理解，在故事板或xib中，ScrollView是根据其下面的一个View的大小来确定ContentSize的大小。看一下效果 创建一个项目，拖拽一个ScrollView到故事板中，如下图 选中ScrollView，添加约束 拖拽一个View到ScrollView上， 然后添加上下左右四周约束 添加完之后， 可能会报一个错， 如下图， 这个暂时别去管 我们先确定一下， 我们是需要水平方向的滚动还是竖直方向的滚动，或者水平方向和竖直方向都需要滚动 a.水平方向和竖直方向都需要滚动的话， 不用添加 b.水平方向滚动需要添加下面一个约束 c.竖直方向需要添加下面一个约束 我们以水平方向滚动为例，我们需要确定我们想要的宽度， 添加一个固定的宽度的约束 选中View， 更新一下Frame 如果是想要动态设置ScrollView的宽度，也就是设置View的宽度约束的值， 我们将其拉成属性， 然后修改其值 如果是确定的宽度， 可以在- (void)updateViewConstraints这个方法中修改，也可以在别处修改 现在运行，就可以水平滚动了。 竖直方向的滚动和水平方向滚动的设置差不多。 我们来添加两个View， 先拖拽一个View（我设为灰色）到视图上， 然后添加约束， 如下图 再拖拽一个View， 背景颜色设为红色，设置好之后， 将frame设置到我们需要的， 我这边将X设置到600 我们给第二个View添加约束，如下图 我们还需要设置一个约束， 就是第二个View距离SuperView的距离，就是第二个View的Leading约束 然后将这个约束Leading拉成属性，在- (void)updateViewConstraints设置他的值如下图这样子就OK了。自动布局需要自己去多多实践， 有很多细节需要注意的。这个例子的demo地址:http://download.csdn.net/detail/h1101723183/8253159竖直方向的Demo下载地址:http://download.csdn.net/detail/h1101723183/8266503 出自http://blog.csdn.net/h1101723183/article/details/41895479","tags":[{"name":"UIScrollView","slug":"UIScrollView","permalink":"http://seniorzhai.github.io/tags/UIScrollView/"}]},{"title":"SizeClass","date":"2014-12-31T07:14:53.000Z","path":"2014/12/31/SizeClass/","text":"对于一个使用Size Class的xib文件，布局上宽度和高度都有三种情况：紧凑(Compact)、任意(Any)、正常(Regular)。14在设置Size Class的时候页面会有提示，比如宽为Compact高为Any的情况，提示为3.5-inch、4-inch、4.7-inch的竖屏状态 对于iPad 对于iPhone 对于iPhone6 Plus横屏状态 使用选择在wAny、hAny下，设置约束(Constraint)这样会在全部尺寸在建立一个统一的约束示例：创建一个距离各边距10的View(状态栏是20，所以距离顶部30)实现的效果为 iPhone4 iPhone5 iPhone6 iPhone6 Plus iPad 不同尺寸不同约束如果需要针对不同尺寸编辑不同的约束，可以用两种方法 在顶部选择Size Class然后编辑约束 选中约束，在属性检查器中选择 对于有的约束在某的尺寸不需要，可以指定尺寸，取消选择Installed卸载也可以切换响应尺寸，删除约束 不同尺寸不同View根据不同尺寸显示跟上述一致 不同尺寸不同字体","tags":[{"name":"SizeClass","slug":"SizeClass","permalink":"http://seniorzhai.github.io/tags/SizeClass/"},{"name":"多屏幕","slug":"多屏幕","permalink":"http://seniorzhai.github.io/tags/多屏幕/"},{"name":"适配","slug":"适配","permalink":"http://seniorzhai.github.io/tags/适配/"}]},{"title":"XML转义字符","date":"2014-12-29T08:18:02.000Z","path":"2014/12/29/XML转义字符/","text":"&amp; &amp;amp &lt; &amp;lt &gt; &amp;gt &quot; &amp;quot &#39; &amp;apos","tags":[{"name":"转义","slug":"转义","permalink":"http://seniorzhai.github.io/tags/转义/"}]},{"title":"使用PageTranformer","date":"2014-12-29T03:14:01.000Z","path":"2014/12/29/使用PageTranformer/","text":"ViewPager自带一个setPageTransformer用于设置切换动画，该方法在Api 11，因为其动画使用的是属性动画，所以可以使用nineoldandroids来支持动画效果Google官方提供了两个PageTransformer示例 DepthPageTransformer1234567891011121314151617181920212223public class DepthPagerTransformer implements ViewPager.PageTransformer &#123; private static final float MIN_SCALE = 0.75f public void transformPage(View view,float position) &#123; int pageWidth = view.getWidth(); if(position &lt; -1) &#123; view.setAlpha(0); &#125; else if(position &lt;= 0) &#123; view.Alpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); &#125; else if(position &lt;= 1) &#123; view.setAlpha(1 - position); view.setTranslationX(pageWidth * -position); float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); &#125; else &#123; view.setAlpha(0); &#125; &#125;&#125; ZoomOutPageTransformer1234567891011121314151617181920212223242526272829303132333435public class ZoomOutPageTransformer implements ViewPager.PageTransformer&#123; private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; public void transformPage(View view,float position) &#123; int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) &#123; view.setAlpha(0); &#125; else if (position &lt;= 1) &#123; // 从a页向b页滑动时，a页从0.0-&gt;-1，b页从1-&gt;0 float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) &#123; view.setTranslationX(horzMargin - vertMargin / 2); &#125; else &#123; view.setTranslationX(-horzMargin + vertMargin / 2); &#125; view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); &#125; else &#123; view.setAlpha(0); &#125; &#125;&#125;","tags":[{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"},{"name":"PagerTranformer","slug":"PagerTranformer","permalink":"http://seniorzhai.github.io/tags/PagerTranformer/"}]},{"title":"资源文件详解","date":"2014-12-25T02:30:27.000Z","path":"2014/12/25/资源文件详解/","text":"animator 存放property animations文件 anim 存放帧动画、属性动画xml文件，property animations可以存放在anim里，但是animator的目录下的xml较高的优先级 color 颜色xml drawable 图片，格式包括Bitmap files(.png，9.png，.jpg，.gif)或者XML(State lists)状态列表的XML Bitmap files .png格式 Nine-Patches(re-sizable bitmaps).9.png格式图片 State lists状态列表的XML Shapes shape的XML Animation drawables动画XML Other drawables其他图片 layout 布局文件 menu 菜单 raw 资源 values arrays.xml 数组资源 colors.xml 颜色 dimens.xml 尺寸文件 string.xml 字符串 style.xml 风格文件 xml xml文件命名规则 MCC and MNC 通信方式 Language and region(地区和语言) en fr en-rUS fr-rFR fr-rCA res/ layout/ layout-ar/ (阿拉伯方式，从右到左) layout-ldrtl (从右到左，但根据语言限定有更高的优先级) sw(smallest width，最小宽度) sw320dp sw600dp sw720dp Available Width(可用宽度，这里会根据屏幕的选择而改变) w720dp w1024dp Available Height(可用高度) h720dp h1024dp Screen Size small normal large xlarge Screen Aspect WQVGA,WVGA,FWVGA QVGA,HVGA,VGA UI mode(根据系统区分，汽车或者可穿戴设备) car desk television appliance watch Night Mode(夜晚模式) night notnight Screen pixel density(dpi屏幕密度) ldpi 120dpi mdpi 160dpi hdpi 240dpi xhdpi 320dpi xxhdpi 480dpi xxxhdpi 640dpi nodpi 不放大 tvdpi 介于mdpi和hdpi之间 TouchScreen Type notouch 没有触摸屏 finger 有触摸屏 Keyboard availability 键盘可用性 keysexposed 有键盘 keyshidden 有可隐藏的硬件键盘 keyssoft 没有键盘 Primary text input method 主要的输入方式 nokeys 没有物理键盘 qwerty 有一个物理键盘，无论用户是否可见 12key 有一个12个键的键盘，无论用户是否可见 Navigation key availability 系统导航栏是否可用 navexposed 用户可以使用系统导航栏 navhidden 不可以使用 Platform Version (API level) 平台版本,不能的API版本使用不同的布局.例如5.0以上的系统可以使用卡片等主题. v3 v4 v7","tags":[{"name":"资源文件","slug":"资源文件","permalink":"http://seniorzhai.github.io/tags/资源文件/"}]},{"title":"Context详解","date":"2014-12-23T02:31:24.000Z","path":"2014/12/23/Context详解/","text":"Context可能是Android中最常用的元素之一，但也是最容易用错的。Context对象常见的功能，有传递引用、加载资源、启动Activity、获取系统服务、获取内部文件路径以及创建View，但是Context的功能远不止这些。 Context的类型Android应用中不同的组件Context对象会有细微的差别 Application Android应用进程中的打你，在Activity和Service中，可以通过getApplication()函数获得，或者任何继承于context对象中，都可以通过getApplicationContext()方法获得。不管在哪里通过何种方法，在同一个进程中，获得的都是同一个实例 Activity/Service 继承于ContextWrapper，实现了context同样的API，但是这些代理这些方法调用到内部隐藏的context实例。任何时候当系统创建一个新的Activity或者Service实例的时候，也创建一个新的ContextImp实例来处理所有繁重的工作，每个Activity和Service以及对应的基础Context，对于每个实例都是唯一的 BroadcastReciver 它本身不是Context，也没有Context在它里面，但是每当一个新的广播到达的时候，框架都会传递一个Context对象到onReceive()，这个context是一个ReceiveRestrictedContext实例，它主要的两个函数被禁用了registerReceiver()和binSerbice()。每个Receiver处理一个广播，传递进来的context都是一个新的实例 ContentProvider 它本身也不是一个Context，但是可以通过getContext()函数获取Context对象。如果ContextProvider是同一个应用进程，getContext()将返回Application单例。如果是不同进程的时候，它将返回一个新的实例代表这个Provider所运行的包 保存引用一个对象或者类内部保存一个Context引用，而它的生命周期却远超过其保存引用对象的生命周期，例如创建一个自定义的单例，它需要context来加载资源或者获取ContentPrivide，从而保存一个指向当前Activity或者Service的引用 错误的示例123456789101112131415161718public class CustomManager &#123; private static CustomManger sInstance; public static CustomManager getInstance(Context context)&#123; if (sInstance == null)&#123; sInstance = new CustomManager(context); &#125; return sInstance; &#125; private Context mContext; private CustomManager(Context context) &#123; mContext = context; &#125; //...&#125; 那么问题来了————我们不知道这个Context哪里来的，并且如果保存一个最终指向的是Activity或者Service的引用是并不安全的，那么因为单例在类的内部维持一个静态的引用，这意味着我们的对象以及所有其他引用的对象将永远不能被垃圾回收。如果Context是一个Activity，那么大量的View以及其他对象不能释放，从而造成内存泄露。 解决这个问题的方法也很简单，单例永远只保留Application context:12345678910111213141516public class CustomManager &#123; private static CustomManager sInstance; public static CustomManager getInstance(Context context) &#123; if(sInstance == null) &#123; sInstance = new CustomManager(context.getApplicationContext()); &#125; return sInstance; &#125; private Context mContext; priavte CustomManger(Context context) &#123; mContext = context; &#125;&#125; 因为Application Context本身就是一个单例，所以我们的单例不会带来任何的内存泄露。另外一个解决方案在后台线程或者一个等待的Handler中保存Context的引用 不同的Context来源于不同地方的context功能有略微的不同 功能 Application Activity Service ContentProvider BroadcastReceiver 显示Dialog NO YES NO NO NO 启动Activity NO1 YES NO1 NO1 NO1 Layout Inflation NO2 YES NO2 NO2 NO2 启动Service YES YES YES YES YES 绑定Service YES YES YES YES NO 发送BroadcastReceive YES YES YES YES NO3 加载Resource YES YES YES YES YES YES YES 注： 1. NO&lt;sub&gt;1&lt;/sub&gt;Application可以开启一个Activity，但是会创建一个新的task，形成一个不标准的回退栈（back stack） 2. NO&lt;sub&gt;2&lt;/sub&gt;可以使用，但是会才用系统默认的Theme，而不是自定义的Theme 3. NO&lt;sub&gt;3&lt;/sub&gt;在Android 4.2以上，如果Receiver是null的话（这是用来获取一个sticky broadcast的当前值），这是操作是允许的 UI一般情况下，所有UI相关的任务都应该交给Activity处理Application context创建Dialog或者开启Activity，系统会抛出一个异常，不允许这么做但是大多数时候创建Layout inflation是允许被创建的，且不报错，但是主题会是系统默认的。这是因为Activity是唯一绑定在manifast文件中定义主题的Context。其他的Context实例都将使用系统默认的主题来inflater你的View。","tags":[{"name":"Context","slug":"Context","permalink":"http://seniorzhai.github.io/tags/Context/"}]},{"title":"让AndroidSDK飞","date":"2014-12-22T01:00:49.000Z","path":"2014/12/22/让AndroidSDK飞/","text":"方法一打开这个网站http://www.androiddevtools.cn/，网站上基本上有你需要的SDK或者其他全部工具（如果没有请fork一下吧，把你知道添加进去！），具体安装下载请仔细阅读相关说明，正确配置即可。由于资源基本上都在百度云盘，下载速度必然刚刚的。 方法二在Android Studio中打开SDK Manager如下：在mac上可以直接使用快捷键cmd + ,来打开SDK Manager Setting，Windows下可以在SDK Manager中在菜单栏找到Tools -&gt; Options也能找到下面这个设置界面设置HTTP Proxy Server: 设置HTTP Proxy Port: 80并且可以强制使用http代替https 方法三VPN，花钱买自由！","tags":[{"name":"SDK","slug":"SDK","permalink":"http://seniorzhai.github.io/tags/SDK/"}]},{"title":"AnroidAnnotations","date":"2014-12-19T05:16:21.000Z","path":"2014/12/19/AnroidAnninotations/","text":"Android开发中，很多时候，我们都需要写一大段一大段的代码用来初始化控件，设置监听，一点都不简洁，这个时候，我们可以使一些强大的工具来帮助我们。 简介AnroidAnnotaions](https://github.com/excilys/androidannotations/wiki)是一款可以快速实现Android开发动态注入的框架，可以帮助我们实现精简的代码，它的目标就是&quot;Fast Android Development.Easy maintatinance”。 特点 依赖注入：实现布局、视图、系统服务、资源的注入 简化线程模型：以注释方法来完成UiThread和BackgroudThread 事件绑定：可以不再使用丑陋的匿名监听器 REST client：创建客户端接口 简单快速：只需要50kb，没有任何性能上的问题 导入 AnroidStudio在build.gradle文件中添加 12345678910111213141516171819202122232425262728293031323334//Copy Begin---从这里开始复制----apply plugin: &apos;android-apt&apos;//添加使用apt插件def AAVersion = &apos;3.0.1&apos;//这里设置AA的版本号buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; //这里设置gradle的版本 classpath &apos;com.android.tools.build:gradle:0.12.2&apos; //这里设置apt的版本 classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.+&apos; &#125;&#125;repositories &#123; mavenCentral() mavenLocal()&#125;apt &#123; arguments &#123; androidManifestFile variant.processResources.manifestFile resourcePackageName &apos;com.houny.androidannotations&apos;//TODO 注意这里要设置当前项目的包名 &#125;...dependencies &#123; compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) //Copy Begin-------从这里开始复制-------------- apt &quot;org.androidannotations:androidannotations:$AAVersion&quot; compile &quot;org.androidannotations:androidannotations-api:$AAVersion&quot; //Copy End--------一直复制到这里-------------&#125;... Eclipse ADT 下载androidannotations-xxx.jar和androidannotations-api-xxx.jar 分别将api-xxx.jar放入libs目录下，xxx.jar放入compile-libs目录下 然后打开Project|Properties|Java Compiler，选中Enable annontation processing 查看Annontation Process|Factory Path点击Add JARs把xxx.jar添加进来 新的ADT里面Java Compiler已经被精简到，可以下载Java Developement Tools 使用AnroidAninotaions的使用很简单，只需要使用几个自定义注解就可以完成注入123456789101112131415161718192021222324252627282930313233// 布局@EActivity(R.layout.main)public class MainActivity extends Activity &#123; // 控件 @ViewById(R.id.myInput); EditText myInput; @ViewById(R.id.myTextView); TextView textView; // 资源 @AnimationRes Animation fadIn; // 点击监听 @click void myButton() &#123; textView.setText(\"Hello!\"); &#125; // 后台线程 @Background void background()&#123; //... uiThread(); &#125; @UiThread void uiThread()&#123; //... &#125;&#125;","tags":[{"name":"AndroidAninotations","slug":"AndroidAninotations","permalink":"http://seniorzhai.github.io/tags/AndroidAninotations/"},{"name":"动态注入","slug":"动态注入","permalink":"http://seniorzhai.github.io/tags/动态注入/"}]},{"title":"一句话解释？和！","date":"2014-12-18T09:23:37.000Z","path":"2014/12/18/一句话解释？和！/","text":"因为Swift支持类型推导，所以Swifi不会自动给变量赋值初值，也就是变量不会有默认值，所以?和!应运而生 ?如果?前面的值不为nil，则继续执行?后面的操作，如果为nil，则略过?后面的操作，避免了crash !如果!前面的值非nil,则强制执行后面的操作，如果不加判断，前面的值为nil，就会crash","tags":[{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"Pop动画引擎","date":"2014-12-17T08:08:08.000Z","path":"2014/12/17/POP动画引擎/","text":"POP动画极为流畅，秘密就在于POP通过CADisplayLink高达60FPS的特性，打造了一个游戏级的动画引擎。CADisplayLink是一个类似NSTimer的定时器，不同之处在于，NSTimer用于定义任务的执行周期，它的执行收到了CPU阻塞影响，而CADisplayLink则用于定义画面的重绘，动画的演变，基于帧(frames)的间隔。通过CADisplayLink程序的重绘速度设定到和屏幕刷新频率一致，因此可以得到流畅的交互动画。 基本类型Spring AnimationSpring Animation提供了一个弹簧效果的动画，通过一系列参数的设置，完成风骚的动画 Bounciness 反弹，影响动画作用的参数的变化幅度 Speed 速度 Tension 拉力，影响回弹力度以及速度 Friction 摩擦力，如果开启，动画会不断重复，幅度逐渐削弱，知道停止 Mass 质量，细微的影响动画的回弹力度以及速度 12345678910// 创建一个二维平面沿X轴和Y轴进行缩放的动画POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerScaleXY];// 指定缩放倍数，不指定fromValue，POP会默认使用当前大小anim.toValue = [NSValue valueWithCGPoint:CGPointMake(2.0,2.0)];anim.springBounciness = 4.0;anim.springSpeed = 12.0;// 指定Callback，在动画执行的过程中，会不断调用该blockanim.completionBlock = ^(POPAnimation *anim,BOOL finished)&#123; if(finished) &#123;NSLog(@&quot;animation finished!&quot;);&#125;&#125;; Decay AnimationDecay Animation变现为一个衰减效果的动画，设置一个参数velocity(速率)123456POPDecayAnimation *anim = [POPDecayAnimation animWithPropertyNamed:kPOPLayerPositionX];anim.velocity = @(100.0);anim.fromValue = @(25.0);anim.completionBlock = ^(POPAnimation *anim,BOOL finished)&#123; if(finished)&#123;NSLog(@&quot;Stop&quot;);&#125; &#125;; 设置deceleration（负向速度）可以设置一个加速度量 Property Animation &amp; Basic AnimationProperty Animation为属性动画，是Spring Animation和Decay Animation的父类12345678910111213141516171819POPBasicAnimation *anim = [POPBasicAnimation animation];anim.duration = 10.0;// 一个慢开慢停的动画anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];// 定义属性POPAnimatableProperty * prop = [POPAnimatableProperty propertyWithName:@&quot;count&quot; initializer:^(POPMutableAnimatableProperty *prop) &#123; prop.readBlock = ^&#123;id obj,CFFloat values[]) // 告诉POP如何获取值 &#123; value[0] = [[obj description] floatValue];&#125;; prop.writeBlock = ^(id obj,const CFFloat values[]) // 如何改变值 &#123; [obj setText:[NSString stringWithFormat:@&quot;%.2f&quot;,values[0]]];&#125;; // 设置动画变化阀值 prop.threshold = 0.01;&#125;];anim.property = prop;anim.fromValue = @(0.0);anim.toValue = @(100.0);","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"},{"name":"Animation","slug":"Animation","permalink":"http://seniorzhai.github.io/tags/Animation/"}]},{"title":"Android异步操作UI","date":"2014-12-16T06:24:28.000Z","path":"2014/12/16/Android异步操作UI/","text":"Android应用的主线程（UI线程）用作更新UI，不可以让主线程做费时操作，否则会出现ANR（App Not Response），一般处理耗时操作时都需要开启一个线程，线程执行结束，发送消息给主线程来更新UI常用的方法有： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) Handler机制 runOnUiThreadrunOnUiThread是Activity的内置方法，它先判断当前线程是不是主线程，如果是则执行，不是则使用Handler机制post到消息队列1234567public final void runOnUiThread(Runnable action)&#123; if(Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; View.postView.post本质上同样是使用Hander来传递Runnable对象12345678910public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if(attchInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; ViewRootImpl.getRunQueue().post(action); // ViewRootImpl.getRunQueue().postDelayed(action, delayMillis); return true;&#125; View.postDelayed同样是使用Handler HandlerAndroid使用的消息机制为Handler-Looper，实现线程的通信，线程通过Looper建立自己的消息循环，MessageQueue是FIFO的消息对列，Looper负责从MessageQueue中取出消息，并且分发到消息指定目标Handler对象，Handler对象绑定到线程的局部变量Looper，封装了发送消息和处理消息的接口。Handler类构造方法123456789101112131415161718192021222324252627public Handler(Callback callback,boolean async) &#123; ... mLooper = Looper.myLooper(); // 如果是普通线程，想要成为Looper线程，必须使用Looper.prepare() // 若是主线程(UI线程)，在Activity启动时，已经调用过Looper.prepare() if(mLooper == null)&#123; throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); &#125; // 消息队列只有一个 mQueue = mLooper.mQueue; mCallback = callback; mAsynchronnous = async; &#125; // Looper对象是线程本地存储(ThreadLocal) public static Looper myLooper() &#123; return sThreadLocal.get() &#125; // prepare的作用是创建线程中唯一的Looper对象，若已经存在则抛出异常 private static void prepare(boolean quitAllowed)&#123; if(sThreadLocal.get() != null)&#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; ... Handler的构造方法通过当前线程唯一的Looper对象来初始化消息队列（共享的Looper的mQueue） 初始化Android应用程序在启动时，会在进程中加载ActivityThread类，并且执行这个类的main函数1234567891011public final class ActivityThread &#123; ... public static final void main(String[] args) &#123; ... Looper.preparMainLooper(); ... // 开始循环处理队列消息 Looper.loop(); ... &#125;&#125; 消息的发送和接收创建一个Message对象使用setData()方法或arg参数等方式携带一些数据，借助Handler将消息发送出去，主线程创建Handler对象时实现其handleMessage方法即可123456789101112131415161718new Thread(new Runnable() &#123; @Override public void run &#123; Message message = new Message(); message.arg1 = 1; Bundle bundle = new Bundle(); bundle.putString(\"data\",\"data\"); message.setData(bundle); handler.sendMessage(message); &#125;&#125;).start();Handler handler = new Handler()&#123; @Override public void handleMessgae(Message msg) &#123; ...... &#125;&#125; 在Handler中提供了很多发送消息的方法，其中除了sendMessageAtFrontOfQueue()方法外，其他方法都会调用sendMessageAtTime()方法，源码如下1234567891011121314151617public boolean sendMessageAtTime(Messgae msg,long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\",e.getMessage(),e); return false; &#125; return enqueueMessage(queue,msg,uptimeMillis);&#125;private boolean enqueueMessage(MessageQueue queue,Message msg,long uptimeMillis) &#123; msg.target = this; if(mAsynchronous)&#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg,uptimeMillis);&#125; 由于MessageQueue是在Looper中创建，线程中只有一个MessageQueue123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean enqueueMessage(Message msg,long when) &#123; if(msg.isInUse()) &#123; //msg.when != 0 throw new AndroidRuntimeException(msg + \" This message is already in use.\"); &#125; if (msg.target == null) &#123; throw new AndroidRuntimeException(\"Message must have a target.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; RuntimeException e = new RuntimeException( msg.target + \" sending message to a Handler on a dead thread\");) Log.w(\"MessageQueu\",e.getMessage(),e); return false; &#125; msg.when = when; Message p = mMessages; boolean needWake; if(p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message = prev; for(;;) &#123; prev = p; p = p.next; if(p == null || when &lt; p.when) &#123; break; &#125; if(needWake &amp;&amp; p.isAsunchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if(needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; MessageQueue使用mMessage对象表示当前待处理的消息，msg入队时，如果当前MessgaeQueue中的mMessage对象不为空，说明有某个message正在入队，此时在for循环中等待，一直等到mMessage为空 如果使用sendMessageAtFrontOfQueue()方法来发送消息，它也会调用enqueueMessage()来让消息入队，只不过时间为0，这时会把mMessages赋值为新入队的这条消息，然后将这条消息的next指定为刚才的mMessage12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static void loop() &#123; final Looper me = myLooper(); if(me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.queue; // 获取消息队列 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for(;;)&#123; Message msg = queue.next(); if(msg == null) &#123; // 如果为null，说明消息队列已退出 return; &#125; &#125; Printer logging = me.mLogging; if(logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); if(logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycle(); &#125;&#125;public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 标准的异步消息处理的写法应该是:1234567891011121314class LooperThread extends Thread &#123; public Handler mHandler;//1.定义Handler public void run() &#123; Looper.prepare();//2.初始化Looper mHandler = new Handler() &#123;//3.定义处理消息的方法 public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop();//4.启动消息循环 &#125;&#125;","tags":[]},{"title":"Crouton的使用","date":"2014-12-15T10:14:10.000Z","path":"2014/12/15/Crouton的使用/","text":"Crouton是一个显示提示信息的显示工具类，可以用来代替Toast。默认显示在窗口的顶部，可以按队列一个接着一个显示。 使用 通过CharSequence创建Crouton 1Crouton.makeText(Activity,CharSequence,Style).show(); 通过字符串资源创建Crouton 1Crouton.makeText(Activity,int,Style).show(); 在ViewGroup下附加Crouton 12Crouton.makeText(Activity,int,Style,int).show();Crouton.makeText(Activity,int,Style,ViewGroup).show(); 取消显示 12// 可以在onDestroy()函数中添加下面的方法，取消所有预定的CroutonCrouton.cancelAllCroutons(); 默认Style Style.ALERT Style.CONFIRM Style.INFO 自定义的Style可以设置： 显示时间 Configuration.Builder().setDuration() 尺寸 显示的文本 自定义视图 出现和消失的动画 Configuration.Builder().setInAnimation()/setOutAnimation 显示的图像 背景色 Style.Builder().setBackgroundColor() 导入方式12345678dependencies &#123; ... compile(&apos;de.keyboardsurfer.android.widget:crouton:1.8.5@aar&apos;) &#123; // exclusion is not neccessary, but generally a good idea. exclude group: &apos;com.google.android&apos;, module: &apos;support-v4&apos; &#125; ...&#125; 例子 https://github.com/SeniorZhai/CroutonDemo","tags":[{"name":"Crouton","slug":"Crouton","permalink":"http://seniorzhai.github.io/tags/Crouton/"},{"name":"提示","slug":"提示","permalink":"http://seniorzhai.github.io/tags/提示/"}]},{"title":"PagerAdapter与ViewPager","date":"2014-12-15T02:49:36.000Z","path":"2014/12/15/PagerAdapter与ViewPager/","text":"PagerAdapterPagerAdapter是android.support.v4包中的类，它的子类有FragmentPagerAdapter，FragmentStatePagerAdapter，这两个Adapter都是Fragment的适配器，用于实现Fragment的滑动效果。PagerAdapter主要是ViewPager的适配器，ViewPager也是android.support.v4扩展包中添加的控件，可以实现控件的活动效果。 instantiateItem(ViewGroup,int) // 将显示的控件进行初始化，并加入到ViewGroup中去 destroyItem(ViewGroup,int,Object) // 销毁控件 getCount() // 控件的数量 isViewFromObject(View,Object) // 判断是否是同一对象 FragmentPagerAdapterFragemntPagerAdapter用于处理Fragment页面的横向滑动，每一个页面都是一个Fragment，并且每一个Fragment都将会保存到Fragment Manager当中，当用户没有可能再次回到页面时，Fragment Manager才会将其销毁适用于静态Fragment，每个页面对应的Fragment用户可以访问时会一直在内存中，当页面数量比较大时，建议使用FragmentStatePagerAdapterFragmentPagerAdapter需要实现getItem(int)和getCount()方法1234567891011121314151617public class MyAdapter extends FragmentActivity &#123; static final int NUM_ITEMS = 10; public MyAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public getCount()&#123; return NUM_ITEMS; &#125; @Override public Fragment getItem(int position)&#123; return fragments.get(position); // 返回Fragment &#125;&#125; FragmentStatePagerAdapterFragmentStatePagerAdapter只保留当前页面，当页面离开实现后，就会被消除，释放其资源。 getItem() 返回Fragment，生成新的Fragment对象，可以使用setArguments()传递初始化参数 instantiateItem() 除非FragmentManager可以从SavedState中恢复对应的Fragment的情况外，该函数会调用getItem()函数，生成新的Fragment对象，新的对象将被FragmentTransaction.add() destroyItem() 将Fragment移除，即调用FragmentTransaction.remove()","tags":[{"name":"Adapter","slug":"Adapter","permalink":"http://seniorzhai.github.io/tags/Adapter/"},{"name":"PagerAdapter","slug":"PagerAdapter","permalink":"http://seniorzhai.github.io/tags/PagerAdapter/"}]},{"title":"JSONModel的使用","date":"2014-12-13T05:14:54.000Z","path":"2014/12/13/JSONModel的使用/","text":"使用JSONModel 创建一个新的Ocjective-C的类并继承JSONModel 在头文件中声明Json中Keys同名属性12345678910@import &quot;JSONModel.h&quot;@interface CountryModel : JSONModel@property (assign,nonatomic) int id;@property (strong,nonatomic) NSString* country;@property (strong,nonatomic) NSString* dialCode;@property (assign,nonatomic) BOOL isInEurope;@end 不需要在.m文件中填写任何东西 解析JSON字符串时123NString* json = ...NSError* error = nil;CountryModel* contryModel = [[CountryModel alloc] initWithString:json error:&amp;error]; 示例基础的例子12345&#123; \"id\":\"123\", \"name\":\"Product name\", \"price\":12.95&#125; 1234567@interface ProductModel : JSONModel@property (assign,nonatomic) int id;@property (strong,nonatomic) NSString* name;@property (assign,nonatomic) float price;@end 嵌套类123456789&#123; \"order_id\":104, \"total_price\":13.45, \"product\":&#123; \"id\":\"123\", \"name\":\"Product name\", \"price\":12.34 &#125;&#125; 1234567@interface OrderModel : JSONModel@property (assign,nonatomic) int order_id;@property (assign,nonatomic) float total_price;@property (strong,nonatomic) ProductModel* product;@end 嵌套集合12345678910111213141516&#123; \"oder_id\":104, \"total_price\":103.45, \"products\" : [ &#123; \"id\":\"123\", \"name\":\"Product # 1\", \"price\":12.95 &#125;, &#123; \"id\":\"137\", \"name\":\"Product # 2\", \"price\":82.95 &#125; ]&#125; 123456789101112131415161718192021222324@potocol ProductModel@end@interface ProductModel : JSONModel@property (assign,nonatomic) int id;@property (strong,nonatomic) NSString* name;@property (assign,nonatomic) float price;@end@implementation ProductModel@end@interface OrderModel : JSONModel@property (assign,nonatomic) int order_id;@property (assign,nonatomic) float tital_price;@property (strong,nonatomic) NSArray&lt;ProductModel&gt; *products;@end@implementation OrderModel@end 修改Key值1234567891011&#123; \"order_id\":104, \"order_details\" : [ &#123; \"name\":\"Product# 1\", \"price\":&#123; \"usd\":12.95 &#125; &#125; ]&#125; 1234567891011121314151617@interface OrderModel : JSONModel@property (assign,nonatomic) int id;@property (assign,nonatomic) float price;@property (strong,nonatomic) NSString* productName;@end@implementation OrderModel+ (JSONKeyMapper *)keyMapper&#123; return [[JSONKeyMapper alloc] initWithDictionary:@&#123; @&quot;order_id&quot;:@&quot;id&quot;, @&quot;order_details.mame&quot;:@&quot;productName&quot;, @&quot;order_details.price&quot;:@&quot;price&quot; &#125;];&#125;@end 全局改变Key123456[JSONModel setGlobalKeyMapper:[ [JSONKeyMapper alloc] initWithDictionary:@&#123; @&quot;item_id&quot;:@&quot;ID&quot;, @&quot;item_name&quot;:@&quot;itemName&quot; &#125;]]; 使用JSON请求123456[[JSONHTTPClient requestHeaders] setValue:@&quot;MySecret&quot; forKey:@&quot;AuthorizationToken&quot;];[JSONHTTPClient postJSONFromURLWithString:@&quot;http://mydomain.com/api&quot; params:@&#123;@&quot;postParma1&quot;:@&quot;valuel&quot;&#125; completion:^(id json,JSONModelError *err)&#123; &#125;]; JSON文本和Dictionary的转换12345ProductModel* pm = [[ProductModel alloc] initWithString:jsonString error:nil];pm.name = @&quot;Changed Name&quot;;NSDictionary* dict = [pm toDictionary];NSString* string = [pm toJSONString]; 自定义Date格式123456789101112131415@implementation JSONValueTransformer (CustomTransformer)- (NSDate *)NSDateFromNSString:(NSString *)string &#123; NSDateFormatter *formatter = [[NSDatrFormatter alloc] init]; [formatter setDateFormat:APIDateFormat]; return [formatter dateFromString:string];&#125;- (NSString *)JSONObjectFromNSDate:(NSDate *)date &#123; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:APIDateFormat]; return [formatter stringFromDate:date];&#125;@end 注：关于名字为id的属性，可以使用id命名，而且需要使用NSNumber或者NSString的类型来定义","tags":[{"name":"Json","slug":"Json","permalink":"http://seniorzhai.github.io/tags/Json/"},{"name":"Model","slug":"Model","permalink":"http://seniorzhai.github.io/tags/Model/"},{"name":"JSON解析","slug":"JSON解析","permalink":"http://seniorzhai.github.io/tags/JSON解析/"}]},{"title":"AFNetworking text/html错误","date":"2014-12-12T10:11:42.000Z","path":"2014/12/12/AFNetworking-text-html错误/","text":"因为AFNetworking从2.0默认不支持text/html在AFURLResponseSerialization.m的223行self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];中添加text/html","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://seniorzhai.github.io/tags/AFNetworking/"}]},{"title":"Android、iOS大不同——生命周期","date":"2014-12-11T02:07:29.000Z","path":"2014/12/11/Android、iOS大不同——生命周期/","text":"iOS Application生命周期AppDelegate - (BOOL)application:(UIApplication *)applicationwillFinishLaunchingWithOptions:(NSDictionary *)launchOptions 将要启动 - (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions 程序首次完成启动时执行，若直接启动，launchOptions没有数据，若由其他应用启动，launchOptions包含数据 - (void)applicationWillResignActive:(UIApplication *)application 应用进入后台，程序失去激活(Active)时调用 需要在此方法中执行下列任务 暂停正在执行的任务 禁止计时器 减少OpenGL ES帧率 若为游戏应暂停游戏 - (void)applicationDidEnterBackground:(UIApplication *)application 已经进入后台时调用 释放共享资源 保存用户数据 作废计时器 保存足够的程序状态以便一次恢复 - (void)applicationWillEnterForeground:(UIApplication *)application 从后台进入前台时调用 - (void)applicationDidBecomeActive:(UIApplication *)application 应用进入激活状态 - (void)applicationWillTerminate:(UIApplication *)application 应用兼将要退出时调用UIController alloc 创建对象 init 初始化对象 loadView 从nib载入视图 viewDidLoad 载入完成 viewWillApper 视图出现在屏幕之前 viewWillDisapper 渲染完成，显示在屏幕上 viewDiddisapper 从屏幕移除之前 viewWillUnload 已经从屏幕移除 viewDidUnload 载出之前 dealloc 被销毁Android Activity生命周期 onCreate() 创建Activity onStart() 创建或从后台重新到前台时被调用 onRestart() 从后台到前台时被调用 onResume() 创建或者被覆盖、后台重新回到前台时被调用 onPause() 被覆盖或者锁屏时被调用 onStop() 退出当前Activity或者跳转到新的Activity时被调用 onDestroy() 退出Activity时被调用，调用之后Activity就被销毁了 onSaveInstanceState(Budle outState) Activity被系统销毁时调用 onRestoreInstanceState(Budle savedInstanceState) Activity重建时被调用对比第一次启动iOS:12345- [AppDelegate application:didFinishLaunchingWithOptions:]- [ViewController viewDidLoad]- [ViewController viewWillAppear:]- [AppDelegate applicationDidBecomeActivie:]- [ViewController viewDidAppear:] Android:123onCreate()onStart()onResume() 应用进入后台iOS12- [AppDelegate applicationWillResignActive:]- [AppDelegate applicationDidEnterBackground:] Android12onPause()onStop() 应用从后台进入前台iOS12- [AppDelegate applicationWillEnterForeground:]- [AppDelegate applicationDidBecomeActive:] Android12onStart()onResume() 完全退出应用iOS1234- [AppDelegate applicationDidEnterBackground:]- [ViewController viewWillDisappear:]- [ViewController viewDidDisappear:]- [AppDelegate applicationWillTerminate:] Android123onPause()onStop()onDestroy() 分析Android、iOS的生命周期看着大同小异，但是差别还算比较大。Android的Activity类似iOS中UIApplication + UIViewController。iOS的应用像是一个全屏展开的窗口，UIApplication负责管理运行状态的生命周期，UIController负责管理视图，视图间靠通知传递数据Android的App可以理解为Activity，Service，Centent Provider，BroadcastReceiver组成，可视部分主要由Activity组成，Activity要管理运行状态和视图，而且每个Activity的运行状态相对独立，四大组件之间、包括应用之间都可以通过Intent传递数据。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"},{"name":"生命周期","slug":"生命周期","permalink":"http://seniorzhai.github.io/tags/生命周期/"}]},{"title":"模糊工具类","date":"2014-12-09T13:28:27.000Z","path":"2014/12/09/模糊工具类/","text":"https://github.com/SeniorZhai/BlurAndroid123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165public class Blur&#123; private static final String TAG = \"Blur\"; public static Bitmap fastblur(Context context,Bitmap sentBitmap,int radius) &#123; if (VERSION.SDK_INT &gt; 16) &#123; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(),true); final RenderScript rs = RenderScript.create(context); final Allocation input = Allocation.createFromBitmap(rs,sentBitmap,Allocation.MipmapControl.MIPMAP_NONE,Allocation.USAGE_SCRIPT); final Allocation output = Allocation.createTyped(rs,input.getType()); final ScriptIntrinsicBlur script = ScriptIntrinsicBlur.create(rs,Element.U8_4(rs)); script.setRadius(radius); script.setInput(input); script.forEach(output); output.copyTo(Bitmap); return bitmap; &#125; Bitmap bitmap = sentBitmap.copy(sentBitmap.getConfig(),true); if (radius &lt; 1) &#123; return (null); &#125; int w = bitmap.getWith(); int h = bitmap.getHight(); int[] pix = new int[w * h]; bitmap.getPixels(pix,0,w,0,0,w,h); int wm = w - 1; int hm = h - 1; int wh = w * h; int div = radius + radius + 1; int r[] = new int[wh]; int g[] = new int[wh]; int b[] = new int[wh]; int rsum,gsum,bsum,x,y,i,p,yp,yi,yw; int vmin[] = new int[Math.max(w,h)]; int dv[] = new int[256 * divsum]; for (i = 0;i &lt; 256 * divsum;i++) &#123; dv[i] = (i / divsum); &#125; yw = yi = 0; int[][] stack = new int[div][3]; int stackpointer; int stackstart; int[] sir; int rbs; int r1 = radius + 1; int routsum,goutsum,boutsum; int rinsum,ginsum,binsum; for (y = 0;y &lt; h;y ++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; for (i = -radius;i &lt; radius; i++) &#123; p = pix[yi + Math.min(wm,Math.max(i,0))]; sir = stack[i + radius]; sir[0] = (p &amp; 0xff0000) &gt;&gt; 16; sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8; sir[2] = (p &amp; 0x0000ff); rbs = r1 - Math.abs(i); rsum += sir[0] * rbs; gsum += sir[1] * rbs; bsum += sir[2] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; &#125; stackpointer = radius; for (x = 0; x &lt; w; x++) &#123; rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0; yp = -radius * w; for (i = -radius; i &lt;= radius; i++) &#123; yi = Math.max(0, yp) + x; sir = stack[i + radius]; sir[0] = r[yi]; sir[1] = g[yi]; sir[2] = b[yi]; rbs = r1 - Math.abs(i); rsum += r[yi] * rbs; gsum += g[yi] * rbs; bsum += b[yi] * rbs; if (i &gt; 0) &#123; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; &#125; else &#123; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; &#125; if (i &lt; hm) &#123; yp += w; &#125; &#125; yi = x; stackpointer = radius; for (y = 0; y &lt; h; y++) &#123; // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] ) pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum]; rsum -= routsum; gsum -= goutsum; bsum -= boutsum; stackstart = stackpointer - radius + div; sir = stack[stackstart % div]; routsum -= sir[0]; goutsum -= sir[1]; boutsum -= sir[2]; if (x == 0) &#123; vmin[y] = Math.min(y + r1, hm) * w; &#125; p = x + vmin[y]; sir[0] = r[p]; sir[1] = g[p]; sir[2] = b[p]; rinsum += sir[0]; ginsum += sir[1]; binsum += sir[2]; rsum += rinsum; gsum += ginsum; bsum += binsum; stackpointer = (stackpointer + 1) % div; sir = stack[stackpointer]; routsum += sir[0]; goutsum += sir[1]; boutsum += sir[2]; rinsum -= sir[0]; ginsum -= sir[1]; binsum -= sir[2]; yi += w; &#125; &#125; Log.e(\"pix\", w + \" \" + h + \" \" + pix.length); bitmap.setPixels(pix, 0, w, 0, 0, w, h); return (bitmap); &#125;&#125;","tags":[{"name":"模糊","slug":"模糊","permalink":"http://seniorzhai.github.io/tags/模糊/"},{"name":"Blur","slug":"Blur","permalink":"http://seniorzhai.github.io/tags/Blur/"}]},{"title":"常用AndroidStudio快捷键","date":"2014-12-09T08:40:35.000Z","path":"2014/12/09/常用AndroidStudio快捷键/","text":"功能 Mac OSX Win/Linux 单行注释 Cmd + / Ctrl + / 多行注释 Cmd + Alt + / Ctrl + Alt + / 格式化代码 Cmd + Alt + L Ctrl + Alt + L 清除无效包引用 Alt + Control + O Alt + Ctrl + O 查找 Cmd + F Ctrl + F 替换 Cmd + R Ctrl + R 上下移动代码 Alt + Shift + Up/Down Alt + Shift + Up/Down 删除行 Cmd + Delete Ctrl + Y 扩大缩小选中范围 Alt + Up/Down Ctrl + W/Ctrl + Shift + W 快捷生成结构体 Cmd + Alt + T Ctrl + Alt + T 快捷覆写方法 Control + O Ctrl + O 快捷定位到行首/尾 Cmd + Left/Right Ctrl + Left/Right 折叠展开代码块 Cmd + Plus/Minus Ctrl + Plus/Minus 折叠全部代码块 Cmd + Shift + Plus/Minus Ctrl + Shift + Plus/Minus 文件结构 Cmd + F12 Ctrl + F12 查找调用位置 Cmd + option + H Ctrl + Alt + H 大小写转换 Cmd + Shift + U Ctrl + Shift + U Alt + enter(option + return) 导包，自动修正 Ctrl+X(command + X) 删除行 Ctrl+D(command + D) 复制行 Alt + Ctrl + Enter(option + control + return) 代码补全","tags":[{"name":"AndroidStudio","slug":"AndroidStudio","permalink":"http://seniorzhai.github.io/tags/AndroidStudio/"}]},{"title":"使用Gradle构建Android项目","date":"2014-12-09T05:48:44.000Z","path":"2014/12/09/使用Gradle构建Android项目/","text":"GradleGradle以Groovy为基础，面向Java应用，基于DSL语法的自动化构建工具 Gradle基本结构1234567891011121314buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.0.0' &#125;&#125;apply plugin: 'android'android&#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\"&#125; buildscript{…} 设置脚本的运行环境 apply plugin: ‘android’ 设置使用android插件构建项目 android{…} 设置编译android项目的参数 任务task执行通常的任务有 输出一个项目文件，Android就是打包APK 运行检查，检查程序的错误，语法等 执行assemble和check 清理项目输出文件 基本的构建定制支持的配置有 minSdkVersion 最小支持sdk版本 targetSdkVersion 编译时目标的sdk版本 versionCode 程序版本号 versionName 程序版本名称 applicationId 程序包名 package Name for the test application 测试用的程序包名 instrumentation test runner 测试用的instrumentation实例1234567891011android&#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\" defaultConfig&#123; versionCode 12 versionName \"2.0\" minSdkVersion 16 targetSdkVersion 16 &#125;&#125; 签名配置12345678910111213141516171819202122android&#123; signingConfigs &#123; debug&#123; storeFile file(\"debug.keystore\") &#125; myConfig&#123; storeFile file(\"other.keystore\") storePassword \"android\" keyAlias \"androiddebugkey\" keyPassword \"android\" &#125; &#125; buildTypes &#123; foo &#123; debuggable true jinDebugBuild true signingConfig signingConfigs.myConfig &#125; &#125;&#125; 设置代码混淆12345678android &#123; buildTypes&#123; release &#123; runProguard true proguardFile getDefaultProguardFile('poguard-android.txt') &#125; &#125;&#125; 依赖配置1234dependencies&#123; compile files('libs/foo.jar') // 单个文件 compile fileTree(dir:'libs',include:['*.jar']) // 多个文件&#125; maven仓库1234567891011repostiories &#123; mavenCentral()&#125;dependencies &#123; complie 'com.google.guava:guava:11.0.2'&#125;android &#123; ...&#125;","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://seniorzhai.github.io/tags/Android-Studio/"},{"name":"Gradle","slug":"Gradle","permalink":"http://seniorzhai.github.io/tags/Gradle/"}]},{"title":"Python面向对象","date":"2014-12-05T06:28:29.000Z","path":"2014/12/05/Python面向对象/","text":"类(class) 用来描述具体相同的属性和方法的对象集合 类变量 类内部的公有变量 数据成员 类变量或者实例变量用于处理类及其实例对象的相关的数据 方法重载(override) 父类继承的方法不能满足子类的需求，可以对其进行修改 实例变量 在方法中定义的变量，只作用于当前实例的类 继承 派生类继承基类 实例化 创建一个类的实例 方法 类中定义的函数 对象 通过类定义的数据结构实例 创建类123class ClassName: 'Optional class documentation string' # 类文档字符串 class_suite # 类体 getattr(obj,name[,default]):访问对象的属性 hasattr(obj,name):检查是否存在一个属性 setattr(obj,name,value):设置一个属性，如果不存在会创建一个新的属性 delattr(obj,name):删除属性 Python内置类属性 __dict__:类的属性(包含一个字典) __doc__:类的文档字符串 __name__:类名 __module__:类定义所在的模块(类的全名是__main__.className) __base__:类的所有父类构成元素 Python对象销毁在Python内部记录着所有使用对象各有多少引用，一个内部跟踪变量，称为一个引用计数器析构函数__del__在对象消逝的时候被调用","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://seniorzhai.github.io/tags/面向对象/"}]},{"title":"Python数学函数","date":"2014-12-04T13:12:01.000Z","path":"2014/12/04/Python数学函数/","text":"数学函数 函数 描述 abs(x) 绝对值 ceil(x) 上入整数 cmp(x,y) 比较 exp(x) e的x次幂 fabs(x) 绝对值 floor(x) 下舍取整 log(x) log运算 log10(x) log10运算 max(x1,x2…) 取最大值 min(x1,x2…) 取最小值 modf(x) 返回X的整数部分与小数部分 pow(x,y) x**y round(x[,n]) 四舍五入 sqrt(x) 平方根 随机数 函数 描述 choice(seq) 从序列中的元素中随机挑选一个元素 randrange([start,]stop[,step]) 从指定范围内按指定基数的集合中获取一个随机数 random() 随机生成一个实数，在[0,1)范围内 seed([x]) 改变随机数生成的种子seed shuffle(lst) 将序列的所有元素随机排序 uniform(x,y) 随机生成一个实数，在[x,y]范围内 三角函数 函数 描述 acos(x) 反余弦 asin(x) 反正弦 atan(x) 反正切 atan2(y,x) 给定坐标的反正切 cos(x) 余弦值 hypot(x,y) 欧几里得范数sqrt(x*x+y*y) sin(x) 正弦 tan(x) 正切 degrees(x) 弧度转换为角度 radians(x) 将角度转换成弧度 数学常量 pi 圆周率 e 数学常数e","tags":[{"name":"数学","slug":"数学","permalink":"http://seniorzhai.github.io/tags/数学/"}]},{"title":"Python标识符、保留字符","date":"2014-12-04T12:44:40.000Z","path":"2014/12/04/Python标识符、保留字符/","text":"标识符在Python中标识符由字母、数字、下划线组成，但不能以数字开头标识符区分大小写以下划线开头的标识符是有特殊意义的，以单下划线开头(_foo)表示不能直接访问的类属性，需要通过类提供的借口进行访问以双下划线开头的(__foo)代表类的私有成员，以双下划线开头和结尾的(__foo__)表示Python里特殊方法，如__init__()表示类的构造函数 保留字符 and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield and exec not assert finally or break for pass class from print continue global raise def if return del import try elif in while else is with except lambda yield 变量类型 Numbers(数字) int(有符号整形) long(长整型) float(浮点数) comples(复数) a+bj或者comples(a,b)表示 String(字符串) List(列表) Tuple(元组) Dictionary(字典) 类型转换 函数 描述 int(x[,base]) 将x转换为一个整数 long(x[,base]) 将x装换成一个长整型 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 unichr(x) 将一个整数转换为Unicode字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 算术运算符 运算符 描述 + 加 - 减 * 乘 / 除 % 取模 ** 幂 // 取整除 比较运算符 运算符 描述 == 等于 != 不等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 成员运算符 运算符 描述 in 是否在指定序列中 not in 是否不再指定序列中 身份运算符 运算符 描述 is 判断两个变量是不是引用自一个对象 is not 判断两个变量是不是引用不同的对象","tags":[{"name":"基础","slug":"基础","permalink":"http://seniorzhai.github.io/tags/基础/"}]},{"title":"android-async-http","date":"2014-11-27T02:36:00.000Z","path":"2014/11/27/android-async-http/","text":"android-async-http封装了 http 请求，直接支持 json，gzip 压缩，相当省事12345678910111213141516AsyncHttpClient client = new AsyncHttpClient();PersitentCookieStore cookieStore = new PersistentCookieCookieStore(context);client.setCookieStore(cookieStore);client.post(url,params,new JsonHttpResponseHandler())&#123; @Override public void onSuccess(int statusCode, Header[] headers, JSONObject response)&#123; &#125; @Override public void onFailure(int statusCode, Header[] headers, Throwable throwable, JSONObject errorResponse) &#123; &#125; @Override public void onFinish() &#123; &#125;&#125;","tags":[{"name":"异步","slug":"异步","permalink":"http://seniorzhai.github.io/tags/异步/"},{"name":"async","slug":"async","permalink":"http://seniorzhai.github.io/tags/async/"},{"name":"网络请求","slug":"网络请求","permalink":"http://seniorzhai.github.io/tags/网络请求/"}]},{"title":"RecyvlerView","date":"2014-11-26T13:41:12.000Z","path":"2014/11/26/RecyclerView/","text":"RecyclerView是android-support-v7-21中新增的一个Widgets，是ListView的升级版，更加先进和灵活。使用RecylerVIew组件，需要指定一个Adapter和布局管理器，布局管理器定位item在RecyclerView中的位置，Adapter负责重用子视图、回收视图，避免View的创建和findViewById()的使用，提高性能。RecylerView提供了以下布局管理器: LinearLayoutManager 线性布局，纵向或者横向滚动的列表视图 GirdLayoutManager 显示item为网格布局 StaggeredGridLayoutManager 显示item为交错的网格布局使用在布局中定义12345&lt;android.support.v7.widget.RecyclerView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:scrollbars=\"vertical\" android:id=\"@+id/recyclerview\"/&gt; 在Java代码中设置Adapter和数据12345678mRecyclerView = (RecyclerView)findViewById(R.id.recyclerview); // 设置高性能模式，必须在确定内容大小不变的情况下设置 mRecyclerView.setHasFixedSize(true); // 设施线性布局 mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mAdapter = new MyAdapter(); mRecyclerView.setAdapter(mAdapter); 同时编写自己的Adapter1234567891011121314151617181920212223242526private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;&#123; public class ViewHolder extends RecyclerView.ViewHolder &#123; public TextView mTextView; public ViewHolder(View v)&#123; super(v); mTextView = (TextView)v.findViewById(R.id.info); &#125; &#125; @Override public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View v = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item_layout,viewGroup,false); ViewHolder vh = new ViewHolder(v); return vh; &#125; @Override public void onBindViewHolder(ViewHolder viewHolder, int i) &#123; viewHolder.mTextView.setText(\"Android CecyclerView\"); &#125; @Override public int getItemCount() &#123; return 100; &#125;&#125; item的布局1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.CardView xmlns:card_view=\"http://schemas.android.com/apk/res-auto\" android:layout_gravity=\"center\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" card_view:cardCornerRadius=\"4dp\" &gt; &lt;TextView android:layout_gravity=\"center\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/info\" /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/LinearLayout&gt; RecyclerView默认情况下就有动画，在删除或者增加Ite的时候。如果需要自定义动画，继承RecyclerView.ItemAnimator类，并且使用RecyclerView.setItemAnimator()方法将定义的动画设置到我们的视图中。Demo","tags":[{"name":"Meterial Design","slug":"Meterial-Design","permalink":"http://seniorzhai.github.io/tags/Meterial-Design/"},{"name":"RecyclerView","slug":"RecyclerView","permalink":"http://seniorzhai.github.io/tags/RecyclerView/"}]},{"title":"Paint类","date":"2014-11-24T09:33:01.000Z","path":"2014/11/24/Paint类/","text":"Paint即画笔，在绘图过程中起到了极其重要的作用，画笔主要保存了颜色，样式等绘制信息，指定了如何绘制文本和图形，画笔对象有很多设置方法，大体上可以分为两类，一类与图形绘制相关，一类与文本绘制相关。 图形绘制 setARGB(int a,int r,int g,int b); 设置绘制的颜色，a代表透明度，r，g，b代表颜色值 setAlpha(int a); 设置绘制图形的透明度 setColor(int color); 设置绘制的颜色，使用颜色值来表示，该颜色值包括透明度和RGB颜色 setAntiAlias(boolean aa); 设置是否使用抗锯齿功能，会消耗较大资源，绘制图形速度会变慢 setDither(boolean dither); 设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰 setFilterBitmap(boolean filter); 如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作，加快显示速度，本设置项依赖于dither和xfermode的设置 setMaskFilter(MaskFilter maskfilter); 设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等 setColorFilter(ColorFilter colorfilter); 设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 setPathEffect(PathEffect effect); 设置绘制路径的效果，如点画线等 setShader(Shader shader); 设置图像效果，使用Shader可以绘制出各种渐变效果 setShadowLayer(float radius ,float dx,float dy,int color); 在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色 setStyle(Paint.Style style); 设置画笔的样式，为FILL，FILL_OR_STROKE，STROKE setStrokeCap(Paint.Cap cap); 当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的图形样式，如圆形样式Cap.ROUND,或方形样式Cap.SQUARE setSrokeJoin(Paint.Join join); 设置绘制时各图形的结合方式，如平滑效果等 setStrokeWidth(float width); 当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度 setXfermode(Xfermode xfermode); 设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果文本绘制 setFakeBoldText(boolean fakeBoldText); 模拟实现粗体文字，设置在小字体上效果会非常差 setSubpixelText(boolean subpixelText); 设置该项为true，将有助于文本在LCD屏幕上的显示效果 setTextAlign(Paint.Align align); 设置绘制文字的对齐方向 setTextScaleX(float scaleX); 设置绘制文字x轴的缩放比例，可以实现文字的拉伸的效果 setTextSize(float textSize); 设置绘制文字的字号大小 setTextSkewX(float skewX); 设置斜体文字，skewX为倾斜弧度 setTypeface(Typeface typeface); 设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等 setUnderlineText(boolean underlineText); 设置带有下划线的文字效果 setStrikeThruText(boolean strikeThruText); 设置带有删除线的效果","tags":[{"name":"Paint","slug":"Paint","permalink":"http://seniorzhai.github.io/tags/Paint/"}]},{"title":"十大Material Design项目","date":"2014-11-24T03:05:41.000Z","path":"2014/11/24/十大Material-Design项目/","text":"MaterialDesignLibraryMaterialDesignLibrary可以说是颇受开发者瞩目的一个控件效果库，能够让开发者在Android 2.2系统上使用Android 5.0才支持的控件效果，比如扁平、矩形、浮动按钮，复选框以及各式各样的进度指示器等。MaterialDesignLibrary还拥有SnackBar、Dialog、Color selector组件，可非常便捷地对应用界面进行设置。进度指示器样式效果设置：12345&lt;com.gc.materialdesign.views.ProgressBarCircularIndetermininate android:id=\"@+id/progressBarCircularIndetermininate\" android:layout_width=\"32dp\" android:layout_height=\"32dp\" android:background=\"# 1E88E5\" /&gt; Dialog12Dialog dialog = new Dialog(Context context,String title, String message); dialog.show(); RippleEffect来自法兰西的Robin Chutaux开发的RippleEffect基于MIT许可协议开源，能够在Android API 9+上实现Material Design，为开发者提供了一种极为简易的方式来创建带有可扩展视图的header视图，并且允许最大程度上的自定制。用法（在XML文件中声明一个RippleView）： 1234567891011121314151617&lt;com.andexert.library.RippleView android:id=\"@+id/more\" android:layout_width=\"?android:actionBarSize\" android:layout_height=\"?android:actionBarSize\" android:layout_toLeftOf=\"@+id/more2\" android:layout_margin=\"5dp\" ripple:rv_centered=\"true\"&gt; &lt;ImageView android:layout_width=\"?android:actionBarSize\" android:layout_height=\"?android:actionBarSize\" android:src=\"@android:drawable/ic_menu_edit\" android:layout_centerInParent=\"true\" android:padding=\"10dp\" android:background=\"@android:color/holo_blue_dark\"/&gt; &lt;/com.andexert.library.RippleView&gt; MaterialEditTextAppCompat v21也为开发者提供了Material Design的控件外观支持，其中就包括EditText，但却并不好用，没有设置颜色的API，也没有任何Google Material Design Spec中提到的特性。于是，来自国内的开发者“扔物线”开发了MaterialEditText库，直接继承EditText，无需修改Java文件即能实现自定义控件颜色。自定义Base Color： 1app:baseColor=\"# 0056d3\" 自定义Error Color：12app:maxCharacters=\"10\" app:errorColor=\"# ddaa00\" Android-LollipopShowcaseAndroid-LollipopShowcase是由来自奥地利的移动、后端及Web开发者Mike Penz所开发的演示应用，集中演示了新Material Design中所有的UI效果，以及Android Lollipop中其他非常酷炫的特性元素，比如Toolbar、RecyclerView、ActionBarDrawerToggle、Floating Action Button（FAB）、Android Compat Theme等。 MaterialListMaterialList是一个能够帮助所有Android开发者获取谷歌UI设计规范中新增的CardView（卡片视图）的开源库，支持Android 2.3+系统。作为ListView的扩展，MaterialList可以接收、存储卡片列表，并根据它们的Android风格和设计模式进行展示。此外，开发者还可以创建专属于自己的卡片布局，并轻松将其添加到CardList中。 1234567891011121314&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingLeft=\"@dimen/activity_horizontal_margin\" android:paddingRight=\"@dimen/activity_horizontal_margin\" android:paddingTop=\"@dimen/activity_vertical_margin\" android:paddingBottom=\"@dimen/activity_vertical_margin\"&gt; &lt;com.dexafree.materiallistviewexample.view.MaterialListView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:id=\"@+id/material_listview\"/&gt; &lt;/RelativeLayout&gt; android-floating-action-buttonFloating Action Button（FAB）是众多专家大牛针对Material Design讨论比较细化的一个点，通过圆形元素与分割线、卡片、各种Bar的直线形成鲜明对比，并使用色彩设定中鲜艳的辅色，带来更具突破性的视觉效果。也正因如此，在Github上，有着许多与FAB相关的开源项目，基于Material Design规范的开源Android浮动Action Button控件android-floating-action-button便是其中之一。其主要特性如下： 支持常规56dp和最小40dp的按钮； 支持自定义正常、Press状态以及可拖拽图标的按钮背景颜色； AddFloatingActionButton类能够让开发者非常方便地直接在代码中写入加号图标； FloatingActionsMenu类支持展开/折叠显示动作。 android-uiandroid-ui是Android UI组件类库，支持Android API 14+，包含了ActionView、RevealColorView等UI组件。其中，ActionView可使Action动作显示动画效果，而RevealColorView则带来了Android 5.0中的圆形显示/隐藏动画体验。 Material MenuMaterial Menu为开发者带来了非常酷炫的Android菜单、返回、删除以及检查按钮变形，完全控制动画，并为开发者提供了两种MaterialMenuDrawable包装。自定义颜色等操作： 1234567891011121314// change color MaterialMenu.setColor(int color) // change transformation animation duration MaterialMenu.setTransformationDuration(int duration) // change pressed animation duration MaterialMenu.setPressedDuration(int duration) // change transformation interpolator MaterialMenu.setInterpolator(Interpolator interpolator) // set RTL layout support MaterialMenu.setRTLEnabled(boolean enabled) Android-ObservableScrollViewAndroid-ObservableScrollView是一款用于在滚动视图中观测滚动事件的Android库。它能够轻而易举地与Android 5.0 Lollipop引进的工具栏（Toolbar）进行交互，还可以帮助开发者实现拥有Material Design应用视觉体验的界面外观，支持ListView、ScrollView、WebView、RecyclerView、GridView组件。交互代码回调： 12345678910111213@Override public void onUpOrCancelMotionEvent(ScrollState scrollState) &#123; ActionBar ab = getSupportActionBar(); if (scrollState == ScrollState.UP) &#123; if (ab.isShowing()) &#123; ab.hide(); &#125; &#125; else if (scrollState == ScrollState.DOWN) &#123; if (!ab.isShowing()) &#123; ab.show(); &#125; &#125; &#125; Material Design Icons最后，再来介绍一下Google Material Design规范的官方开源图标集Material Design Icons。良心Google开源了包括Material Design系统图标包在内的750个字形，涵盖动作、音视频、通信、内容、编辑器、文件、硬件、图像、地图、导航、通知、社交等各个方面，适用于Web、Android和iOS应用开发，绝对是开发者及设计师必备的资源。图标格式主要包括： SVG格式，24px和48px； SVG和CSS Sprites； 适用于Web平台的1x、2x PNG格式图标； 适用于iOS的1x、2x、3x PNG图标； 所有图标的Hi-dpi版本（hdpi、mdpi、xhdpi、xxhdpi、xxxhdpi）。","tags":[{"name":"Material Design","slug":"Material-Design","permalink":"http://seniorzhai.github.io/tags/Material-Design/"},{"name":"Android 5.0","slug":"Android-5-0","permalink":"http://seniorzhai.github.io/tags/Android-5-0/"}]},{"title":"ListView嵌套GridView","date":"2014-11-20T13:20:25.000Z","path":"2014/11/20/ListView嵌套GridView/","text":"ListView和GridView都是可滑动控件，需要自定义GridView重写其onMeadure()123456...protected void onMeasure(int widthMeasureSpec,int heightMeasureSpec) &#123; int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,MeasureSpec.AT_MOST); super.onMeasure(widthMeasureSpec,expandSpec);&#125;... 同时，GridView作为item必须设置android:layout_height=“wrap_content” 理解layout、measureView和ViewGroup都是Android基本视图单位，ViewGroup也是一种View，但ViewGroup能够包含Viewmeasure设置View的大小，如果有child view，循环measure函数layout为摆放child view的位置","tags":[{"name":"layout","slug":"layout","permalink":"http://seniorzhai.github.io/tags/layout/"},{"name":"GridView","slug":"GridView","permalink":"http://seniorzhai.github.io/tags/GridView/"},{"name":"ListView","slug":"ListView","permalink":"http://seniorzhai.github.io/tags/ListView/"},{"name":"嵌套","slug":"嵌套","permalink":"http://seniorzhai.github.io/tags/嵌套/"},{"name":"measure","slug":"measure","permalink":"http://seniorzhai.github.io/tags/measure/"}]},{"title":"GridLayout","date":"2014-11-20T10:14:48.000Z","path":"2014/11/20/GridLayout/","text":"","tags":[{"name":"GridLayout","slug":"GridLayout","permalink":"http://seniorzhai.github.io/tags/GridLayout/"}]},{"title":"StickyListHeadersListView","date":"2014-11-20T05:43:07.000Z","path":"2014/11/20/StickyListHeadersListView/","text":"StickyListHeaders是一个带标题的ListView的带三方库 使用在activity或Fragment的xml文件1234&lt;se.emilsjolander.stickylistheaders.StickyListHeadersListView android:id=\"@+id/list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 在onCreate()或onCreateView()中获取StickyListHeadersListView123StickyListHeadersListView stickyList = (StickyListHeadersListView) findViewById(R.id.list);MyAdapter adapter = new MyAdapter(this);stickyList.setAdapter(adapter); 同时要实现一个Adapter1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Mydapter extends BaseAdapter implements StickyListHeadersAdapter &#123; @Override public int getCount()&#123; return content.length; &#125; @Override public Object getItem(int position) &#123; return content[position]; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder; if (convertView == null) &#123; holder = new ViewHolder(); convertView = inflater.inflate(R.layout.test_list_item_layout, parent, false); holder.text = (TextView) convertView.findViewById(R.id.text); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.text.setText(content[position]); return convertView; &#125; @Override public View getHeaderView(int position, View convertView, ViewGroup parent) &#123; HeaderViewHolder holder; if (convertView == null) &#123; holder = new HeaderViewHolder(); convertView = inflater.inflate(R.layout.header, parent, false); holder.text = (TextView) convertView.findViewById(R.id.text); convertView.setTag(holder); &#125; else &#123; holder = (HeaderViewHolder) convertView.getTag(); &#125; //set header text as first char in name String headerText = \"\" + content[position].subSequence(0, 1).charAt(0); holder.text.setText(headerText); return convertView; &#125; @Override public long getHeaderId(int position) &#123; //return the first character of the country as ID because this is what headers are based upon return content[position].subSequence(0, 1).charAt(0); &#125; class HeaderViewHolder &#123; TextView text; &#125; class ViewHolder &#123; TextView text; &#125;&#125;","tags":[{"name":"HeadersList","slug":"HeadersList","permalink":"http://seniorzhai.github.io/tags/HeadersList/"},{"name":"带标题的ListView","slug":"带标题的ListView","permalink":"http://seniorzhai.github.io/tags/带标题的ListView/"}]},{"title":"sp与px的换算","date":"2014-11-19T05:07:53.000Z","path":"2014/11/19/sp与px的换算/","text":"sp:Scale-independent pixels，Android的字体单位，以160PPI的屏幕为标准，默认设置字体大小为100%时，1sp=1pxsp与px的换算公式：sp*PPI(Pixle per inch) = px 常见尺寸PPI xhdpi: 2.0 hdpi: 1.5 mdpi: 1.0 ldpi: 0.75","tags":[{"name":"文本大小","slug":"文本大小","permalink":"http://seniorzhai.github.io/tags/文本大小/"},{"name":"sp","slug":"sp","permalink":"http://seniorzhai.github.io/tags/sp/"},{"name":"px","slug":"px","permalink":"http://seniorzhai.github.io/tags/px/"}]},{"title":"WebSpider","date":"2014-11-19T01:56:54.000Z","path":"2014/11/19/WebSpider/","text":"URI和URLURI(Universal Resource Identifier)是通用资源标志符通常由三部分组成： 访问资源的命名机制 存放资源的主机名 资源自身的名称http://www.baidu.com/img/bdlogo.png可以解释为 一个可以通过HTTP协议访问的资源 位于主机www.baidu.com上 通过/img/bdlogo.png访问 URLURL是URI的一个子集，是Uniform Resource Locator的缩写，译为统一资源定位符，简而言之URL是Internet上描述信息资源的字符串。URL的一般格式为(带方括号[]为可选项)protocol://hostname[:port]/path/[parameters][?query]# fragment 第一部分是协议 第二部分为存有资源的主机IP也可能包括端口号 第三部分是主机资源的具体地址，如目录和文件名等 区别URI属于URL更低级层次的抽象，一种字符串文本标准URI表示请求服务器的路径定义一个资源，而URL同时说明要如何访问这个资源 抓取网页内容1234import urllib2response = urllib2.urlopen('http://www.baidu.com')html = response.read()print html 使用请求12345import urllib2req = urllib2.Request('http://www.baidu.com')response = urllib2.urlopen(req)the_page = respense.read()print the_page Post请求12345678910111213import urllibimport urllib2url = 'http://www.someserver.com/register.cgi'values = &#123;'name':'WHY', 'location':'SDU', 'language','Python'&#125;data = urllib.urlencode(values)req = urllib2.Request(url,data)response = urllib2.urlopen(req)the_page = response.read() GET请求1234567891011121314151617import urllib2import urllibdata = &#123;&#125;data['name'] = 'WHY'data['location'] = 'SDU'data['language'] = 'Python'url_values = urllib.urlencode(data)print url_valuesname = Somebody + Here&amp;language=Python&amp;location=Northamptonurl = 'http://www.example.com/example.cgi'full_url = url + '?' + url_valuesdata = urllib2.open(full_url) 设置Headers1234567891011121314import urllibimport urllib2url = 'http://www.someserver.com/cgi-bn/register.cgi'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5;Windows NT)'values = &#123;'name':'WHY', 'location':'SDU', 'language':'Python'&#125;headers = &#123;'User-Agent':user_agent&#125;data = urllib.urlencode(values)req = urllib2.Request(url,data,headers)response = urllib.urlopen(req)the_page = response.read() 异常URLError通常，URLError在没用网络连接(没有路由到特定服务器)或者服务器不存在产生这种情况下，异常同样会带有reason属性，他是一个tuple包含了一个错误号和一个错误信息12345678import urllib2req = urllib2.Request('http://www.baibai.com')try: urllib2.urlopen(req)except urllib2.URLError,e: print e.reason HTTPError服务器上每个HTTP应答对象response包含一个数字”状态码”有时状态码服务器无法完成请求，默认的处理器会为你处理一部分应答HTTP状态码分别以1~5开头由3位整数组成： 200:请求成功，处理方式：获得相应的内容，进行处理 201:请求完成，结果是创建了新资源，心创建资源的URI可再响应的实体中得到 202:请求被接受，处理尚未完成 处理方式：阻塞等待 204:服务器已经实现了请求，但没有返回心的信息，如果客户是用户代理，则无须为此更新自身的文档视图，处理方式 丢弃 300: 作为3XX类型回应的默认解释，存在多个可用的被请求资源。处理方式：若程序中能够处理，则进行进一步处理，如果程序不能处理，则丢弃 301:请求到飞资源都会被分配一个永久的URL，这个就可以在将来通过URL来访问此资源，处理方式：重定向到分配的URL 302:请求到的资源在一个不同的URL处临时保存，处理方式：重新向到临时的URL 400:非法请求 处理方式 丢弃 401:未授权 处理方式 丢弃 403:禁止 处理方式 丢弃 404:没有找到 处理方式 丢弃 5XX:服务器错误，处理方式 丢弃HTTPError产生后会有一个整形code属性，是服务器发送的行管错误BaseHTTPServer.BaseHTTPRequestHandler.reponse是一个很有用的应答号码字典，显示HTTP协议使用所有的应答号1234567import urllib2req = urllib2.Request('http://bbs.csdn.net/callmewhy')try: urllb2.urlopen(req)except urllib2.URLError, e: print e.code","tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://seniorzhai.github.io/tags/爬虫/"},{"name":"Spider","slug":"Spider","permalink":"http://seniorzhai.github.io/tags/Spider/"}]},{"title":"使用curl调试接口","date":"2014-11-18T09:34:18.000Z","path":"2014/11/18/使用curl调试接口/","text":"curl是一个向服务器传输数据的工具，支持http、ftp、ftps、scp、sftp、tftp、telnet协议 打开网页1curl http://www.baidu.com/ 也可以保存1curl http://www.baidu.com &gt; ./buidu.html 或者1curl -o ./baidu.html http://www.baidu.com GET请求1curl http://www.baidu.com/s?wd=curl POST请求1curl -d &quot;name=test&amp;page=1&quot; http://www.baidu.com 展示Header只会显示头部内容1curl -I http://www.baidu.com 显示通信过程1curl -v www.baidu.com 如果需要详细的信息还可以使用123curl --trace output.txt www.baidu.com# 或者curl --trace-ascii output.txt www.baidu.com HTTP方法curl默认是GET方法，使用-X参数可以支持其他动词12curl -X POST www.baidu.comcurl -X DELETE www.baidu.com Referer字段在http request头部信息中提供referer字段，表示你是从哪里跳转过来的1curl --referer http://www.example.com http://www.example.com User Agent字段User Agent用来表示客户端信息iPhon4的User Agent是 Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7 1curl --user-agent &quot;[User Agent]&quot; [URL] 增加头部信息1curl --header &quot;Content-Type:application/json&quot; http://example.com","tags":[{"name":"Api","slug":"Api","permalink":"http://seniorzhai.github.io/tags/Api/"},{"name":"调试","slug":"调试","permalink":"http://seniorzhai.github.io/tags/调试/"},{"name":"curl","slug":"curl","permalink":"http://seniorzhai.github.io/tags/curl/"}]},{"title":"GridView属性","date":"2014-11-17T13:46:14.000Z","path":"2014/11/17/GridView属性/","text":"android:numColumns=”auto_fit” 列数设置为自动 android:columnWitdh 列的宽度 android:stretchMode=”columnWidth” 缩放模式，如何填满空余位置，columnWitdh分摊给item宽度，SpacingWidth分摊给间隔，none无，spacingWidthUniform每一列间隔均匀地缩放 android:verticalSpacing 行间距 android:horizontalSpacing 列间距 android:cacheColorHint 拖动默认背景 android:scrollbars 滚动条是否显示 android:fadeScrollbars 是否自动隐藏滚动条 android:fastScrollEnabled 是否支持快速滚动 android:fadingEdge 褪去边缘颜色 android:fadingEdgeLength 褪去边缘的长度 android:stackFromBottom 列表显示最下面 android:transcriptMode=”alwaysScroll” 动态添加数据时，列表将自动往下滚动最新的条目可以自动滚动到可视范围内 android:drawSelectorOnTop 点击某条记录不放，颜色会在记录的后面成为背景色,内容的文字可见","tags":[{"name":"GridView","slug":"GridView","permalink":"http://seniorzhai.github.io/tags/GridView/"}]},{"title":"CocoaPods","date":"2014-11-17T01:18:42.000Z","path":"2014/11/17/CocoaPods/","text":"CocoaPods是一个objc的依赖管理工具，本身利用ruby的依赖管理gem进行构建 下载及安装本地安装好Ruby环境，在Terminator中输入以下命令 sudo gem install cocoapods 由于cocoapods.org会被墙，所以需要使用淘宝镜像来访问123$ gem sources --remove https://rubygems.org/$ gem sources -a http://ruby.taobao.org/$ gem sources -l # 查看 使用CocoaPods示例导入AFNetworking为了确定AFNetworking是否支持CocoaPods可以先使用CocoaPods的搜索功能验证以下1$ pod search AFNetworking 如果可以在终端中看到关于AFNetworking类库的一些信息，说明AFNetworking支持CocoaPods 首先用XCode建立一个工程，然后关闭XCode 在工程目录下创建Podfile文件，并写入12platform :ios,&apos;7.0&apos;pod &quot;AFNetworking&quot;,&quot;~&gt; 2.0&quot; 以上文本可以在开源库的github上找到，上述文本的意思是支持iOS7.0使用AFNetworking 2.0版本 在命令行中(工程目录下)，执行安装命令pod install 完成后，可以在工程目录下看到XXX.xcworkspace文件，点击他就可进入已包含AFNetworking的工程","tags":[{"name":"CocosPods","slug":"CocosPods","permalink":"http://seniorzhai.github.io/tags/CocosPods/"},{"name":"依赖管理","slug":"依赖管理","permalink":"http://seniorzhai.github.io/tags/依赖管理/"}]},{"title":"TextView属性详解","date":"2014-11-16T11:37:48.000Z","path":"2014/11/16/TextView属性详解/","text":"android:autoLink 设置是否当文本为URL链接/email/电话号码/map时，显示为可点击的链接，可选值(none/web/email/phone/map/all) android:bufferType 指定getTexy()方式取得的文本类型，选项editable类似StringBuilder可追加字符，也就是说getText后可调用append方法设置文本内容。 android:capitalize 设置英文字母大写类型 android:cursorVisible 设置光标为显示/隐藏，默认显示 android:digits 设置允许输入哪些字符 android:drawableBottom在text的下方输入一个drawable android:drawableLeft 在左边输出一个drawable android:drawablePadding 设置text与drawable的间隔 android:drawbaleRight 在右边输出一个drawable android:drawbaleTop 在上方输出一个drawable android:editable 设置是否可编辑 android:editorExtras 设置文本的额外输入数据 android:ellipsize 设置文字过长时，该控件该如何显示，可选值设置start省略号显示在开头，end省略号显示在结尾，middle省略号显示在中间，marquee以跑马灯的方式显示 android:freezesText 设置保存文本的内容以及光标位置 android:gravity 设置文本位置 android:hintText 为空时显示的文本提示信息 android:imeOptions 附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角显示“完成”，而不设置显示默认是一个回车 android:imeActionId 设置IME动作ID android:imeActionLabel 设置IME动作标签 android:inputMethod 为文本指定输入法 android:inputType 设置文本的类型，用于帮助输入法显示合适的键盘类型 android:linksClickable 设置连接是否可以dianji android:marqueeRepeatLimit在ellipsize指定marquee的情况下，设置重复滚动的次数，marquee_forever时表示无限次 android:ems设置TextView的宽度为N个字符的宽度 android:maxEms 设置TextView的宽度为最长为N个字符的宽度 android:minEms 设置TextView的宽度为最短为N个字符的宽度 android:maxLength 限制显示的文本长度，超出部分不显示 android:lines 设置文本的行数，设置两行就显示两行，即使第二行没有数据 android:maxLines 设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自定换行，超出行数将不显示 android:minLines 设置文本的最小行数 android:lineSpacingExtra设置行间距 android:lineSpacingMultiplier设置行间距的倍数 android:numeric 设置后TextView有点击效果 android:password 以.显示文本 android:phoneNumber 设置为电话号码的输入方式 android:privateImeOptions 设置输入法选项 android:scorllHorizontally 设置文本超出宽度的情况下，是否出现横拉条 android:selectAllOnFocus 如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。 TextView中设置后无效果 android:shadowColor 指定文本阴影的颜色，需要与shadowRadius一起使用 android:shadowDx设置阴影横向坐标开始位置 android:shadowDy设置阴影纵向坐标开始位置 android:shadowRadius设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好 android:singleLine设置单行显示 android:singleLine=”true”显示单行 android:textAppearance设置文字外观。如 “?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，?表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse android:textColor 设置文本颜色 android:textColorHighlight 被选中文字的底色，默认为蓝色 android:textColorLink 文字连接的颜色 android:textColorHint 设置提示信息的颜色，默认是灰色 android:textScaleX 设置文字自检间隔，默认为1.0f android:textSize 设置文字大小，推荐度量单位sp android:textStyle 设置字形[bold(粗体)，italic(斜体)，bolditalic(又粗又斜)] android:typeface 设置字体，必须是以下常量值之一：normal 0，sans 1，serif 2，monospace(等宽字体) 3 android:height 设置文本区域的高度，支持度量单位 px/dp/sp/in/mm android:maxHeight 设置文本区域的最大高度 android:minHeight 设置文本区域的最小高度 android:width 设置文本区域的宽度 android:maxWidth 设置文本区域的最大宽度 android:minWidth 设置文本区域的最小宽度","tags":[{"name":"TextView","slug":"TextView","permalink":"http://seniorzhai.github.io/tags/TextView/"},{"name":"EditView","slug":"EditView","permalink":"http://seniorzhai.github.io/tags/EditView/"}]},{"title":"SublimeText插件卸载","date":"2014-11-13T13:01:24.000Z","path":"2014/11/13/SublimeText插件卸载/","text":"shift+ctrl(Mac command) + P输入package 查找romove package 输入需要删除的插件 回车，OK👌","tags":[{"name":"SublimeText","slug":"SublimeText","permalink":"http://seniorzhai.github.io/tags/SublimeText/"}]},{"title":"EventBus","date":"2014-11-08T13:30:52.000Z","path":"2014/11/08/EventBus/","text":"EventBus是Android上一个事件发送/接受的解决方案之一 简化了组建之间的通信 事件有发送方和接收方 执行在Activity、Fragment和后台进程上 避免了复杂的、容易出错的依赖和生命周期问题 快速、轻便、稳定 拥有先进的功能，如交付线程、用户优先级 3步使用EventBus 定义事件Evenetspublic class MessageEvent{ /* 加入需要的额外字段 */ } 准备接受eventBus.register(this);public void onEvent(AnyEventType event){ /* Do something */} 发送事件eventBus.post(event);在工程中加入EventBusGradle: compile ‘de.greenrobot:eventbus:2.2.1’Maven: de.greenrobot eventbus 2.2.1","tags":[]},{"title":"RippleEffect","date":"2014-11-08T06:52:50.000Z","path":"2014/11/08/RippleEffect/","text":"12345678910111213141516&lt;com.andexert.library.RippleView android:id=\"@+id/more\" ripple:rv_centered=\"true\" android:layout_width=\"120dp\" android:layout_height=\"60dp\" android:layout_margin=\"5dp\"&gt; &lt;ImageView android:layout_width=\"120dp\" android:layout_height=\"60dp\" android:layout_centerInParent=\"true\" android:background=\"@android:color/holo_blue_light\" android:padding=\"10dp\" android:src=\"@android:drawable/ic_menu_edit\" /&gt;&lt;/com.andexert.library.RippleView&gt; 定制属性 app:rv_alpha:波纹的透明度，integer类型，默认为90，范围0-255 app:rv_framerate:波纹放大过程中的步进，integer类型，默认10 app:rv_rippleDuration:波纹动画的间隔，integer类型，默认400 app:paddingStart:波纹其实padding app:paddingEnd:波纹结束padding app:rv_color:波纹的颜色，color类型，默认是白色 app:rv_centered:是否在控件的最中间，boolean类型，默认false app:rv_type:波纹类型，enum类型(simpleRipple,doubleRipple,rectangle)，默认simpleRipple app:rv_zoom:是否开启放大动画，boolean类型，默认false app:rv_zoomDuration:放大动画的时间，integer类型，默认150 app:rv_zoomScale:放大动画，integer类型，默认1.03","tags":[{"name":"Animation","slug":"Animation","permalink":"http://seniorzhai.github.io/tags/Animation/"},{"name":"MaterialDesign","slug":"MaterialDesign","permalink":"http://seniorzhai.github.io/tags/MaterialDesign/"},{"name":"波纹","slug":"波纹","permalink":"http://seniorzhai.github.io/tags/波纹/"},{"name":"按钮","slug":"按钮","permalink":"http://seniorzhai.github.io/tags/按钮/"}]},{"title":"AndroidDialog","date":"2014-11-06T05:26:49.000Z","path":"2014/11/06/AndroidDialog/","text":"提示创建代码12345678910111213141516171819protected void dialog()&#123; AlertDialog.Builder builder = new Builder(mContext); builder.setMessage(\"确定退出么？\"); builder.setTitle(\"提示\"); builder.setPostiveButton(\"确认\",new OnClickListener()&#123; @Override public void onClick(DialogInterface dialog,int which) &#123; dilog.dismiss(); // &#125; &#125;); builder.setNegativeButton(\"取消\",new OnClickListner()&#123; @Override public void onClick(DialogInterface dialog,int which)&#123; dialog.dismiss(); &#125; &#125;); builder.create().show();&#125; 三个按钮1234567891011121314151617181920212223Dialog dialog = new AlertDialog.Builder(this).setIcon( android.R.drawable.btn_star).setTitle(\"喜好调查\").setMessage( \"你喜欢李连杰的电影吗？\").setPositiveButton(\"很喜欢\", new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(Main.this, \"我很喜欢他的电影。\", Toast.LENGTH_LONG).show(); &#125; &#125;).setNegativeButton(\"不喜欢\", new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(Main.this, \"我不喜欢他的电影。\", Toast.LENGTH_LONG) .show(); &#125; &#125;).setNeutralButton(\"一般\", new OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(Main.this, \"谈不上喜欢不喜欢。\", Toast.LENGTH_LONG) .show(); &#125; &#125;).create(); dialog.show(); 简单的自定View123new AlerDialog.Builder(mContext).setTitle(\"请输入\").setIcon(android.R.drawable.ic_dialog_info) .setView(new EditText(this)).setPositiveButton(\"确定\",null) .setNegativeButton(\"取消\",null).show() 消息内容一组单选框12345new AlerDialog.Builder(mContext).setTitle(\"单选框\") .setMultiChoiceItems( new String[]&#123;\"Item1\",\"Item2\"&#125;,null,null) .setPositiveButton(\"确定\",null) .setNegativeButton(\"取消\",null).show(); 消息内容是一组多选框12345678new AlerDialog.Builder(mContext).setTitle(\"多选框\") .setIcon(android.R.drawable.ic_dialog_info) .setSingleChoiceItems(new String[]&#123;\"Item1\",\"Item2\"&#125;,0 new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface dialog,int which)&#123; dialog.dismiss(); &#125; &#125;).setNegativeButton(\"取消\",null).show(); 信息内容是一组简单列表项``javanew AlertDialog.Builder(this).setTitle(“列表框”).setItems( new String[] { “Item1”, “Item2” }, null).setNegativeButton( “确定”, null).show();1234567891011121314## 信息内容自定义布局![](/img/14110607.png)```xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:background=&quot;# ffffffff&quot; android:orientation=&quot;horizontal&quot; android:id=&quot;@+id/dialog&quot;&gt; &lt;TextView android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:id=&quot;@+id/tvname&quot; android:text=&quot;姓名：&quot; /&gt; &lt;EditText android:layout_height=&quot;wrap_content&quot; android:layout_width=&quot;wrap_content&quot; android:id=&quot;@+id/etname&quot; android:minWidth=&quot;100dip&quot;/&gt;&lt;/LinearLayout&gt; 123456LayoutInflater inflater = getLayoutInflater(); View layout = inflater.inflate(R.layout.dialog, (ViewGroup) findViewById(R.id.dialog)); new AlertDialog.Builder(this).setTitle(\"自定义布局\").setView(layout) .setPositiveButton(\"确定\", null) .setNegativeButton(\"取消\", null).show();","tags":[{"name":"Dialog","slug":"Dialog","permalink":"http://seniorzhai.github.io/tags/Dialog/"}]},{"title":"Android中include和merge标记的区别和使用","date":"2014-11-06T05:13:41.000Z","path":"2014/11/06/Android中include和merge标记的区别和使用/","text":"include和merge标记的作用主要是为了解决layout的重用的问题 include比如多个Activity需要相同的标题layout即可使用include来重用1&lt;include layout=\"@layout/titlebar\" /&gt; 使用include之后，titlebar文件就会被完全嵌入到include缩指定的位置，而且也可以重新更改一些属性123&lt;include layout=\"@layout/titlebar\" android:layout_width=\"math_parent\" android:layout_height=\"math_parent\" /&gt; mergeinclude有一个副作用就是它需要套用一层root接点如果不需要的话，可以使用merge标记12345&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;ImageView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/logo\" /&gt;&lt;/merge&gt; 这样在嵌套的时候，merge标记就会被忽略掉，避免冗余的layout","tags":[{"name":"include","slug":"include","permalink":"http://seniorzhai.github.io/tags/include/"},{"name":"merge","slug":"merge","permalink":"http://seniorzhai.github.io/tags/merge/"},{"name":"复用","slug":"复用","permalink":"http://seniorzhai.github.io/tags/复用/"},{"name":"layout","slug":"layout","permalink":"http://seniorzhai.github.io/tags/layout/"}]},{"title":"FastApple","date":"2014-11-05T12:27:50.000Z","path":"2014/11/05/FastApple/","text":"让你的App Store飞起来设置DNS为42.121.236.241或者74.117.62.158如果失效可以在http://fasterapple.com/查看最新的DNS地址","tags":[{"name":"Apple","slug":"Apple","permalink":"http://seniorzhai.github.io/tags/Apple/"}]},{"title":"Swift不可错过的10大开源项目","date":"2014-11-05T05:04:32.000Z","path":"2014/11/05/Swift不可错过的10大开源项目/","text":"Swift的设计非常优雅，较Obj-C更易于学习，当然也非常强大。下面是十个强大的开源Swift项目 AlamofireAlamofire是一个用Swift编写的HTTP网络库，由此前热门开源项目AFNetworking的的作者mattt开发，可非常简单地用于异步网络通信。关于何时使用AFNetworking，何时使用Alamofire，可参看作者对两种情况的分析，不过很好的一点是AFNetworking和Alamofire两个库并不相互排斥，可以很好地共存于相同的代码库中。 要求：Xcode 6.0，iOS 7.0+ / Mac OS X 10.9+ Surge（Swift + Accelerate）Surge基于Accelerate框架开发，用于执行矩阵数学、数字信号处理以及图像处理等方面。换句话说，它可以快速处理复杂的数学、语音以及图像信号。并且依然来自于大神级人物mattt。 SwiftyJSONSwiftyJSON使得用Swift处理JSON数据更加容易。这是解析JSON字符串封装类。实现功能与Javascript中的JSON.parse相近，使用方便。 要求：Xcode 6.0，iOS 7.0+ / Mac OS X 10.9+ Dollar.swiftDollar是一个Swift库，提供了有用的函数式编程辅助方法，无需扩展任何内置对象。Dollar类似于Lo-Dash或者Javascript中的Underscore。 ExSwiftExSwidt包含一组标准类型和类的Swift扩展。 SwiftTaskSwiftTask是用Swift编写的状态机，综合了 Promise + progress + pause + cancel，使用 SwiftState ( Swift 编写的优雅的状态机)。 HanekeSwiftHaneke是一个用 Swift 编写的轻量级iOS通用缓存，易于使用。特性： CartographyCartography在Swift声明Auto Layout SleipnirSleipnir是一个适用于Swift的BDD（Behavior Driven Development）风格框架，灵感来自于Cedar（一款BDD风格的Objective-C测试框架）。核心原则：Sleipnir不依赖NSObject，是纯Swift BDD测试框架；Sleipnir不使用XCTest；有着很好的命令行输出，支持自定义测试报告，等等。 QuickQuick是一个适用于Swift和Objective-C的行为驱动开发测试框架。借鉴了RSpec, Specta以及Ginkgo。","tags":[{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"},{"name":"开源","slug":"开源","permalink":"http://seniorzhai.github.io/tags/开源/"}]},{"title":"可视化黑客攻击","date":"2014-11-05T05:01:41.000Z","path":"2014/11/05/可视化黑客攻击/","text":"iPviking:在线黑客攻击可视化地图有一个由挪威公司对全世界互联网数据流攻击进行的实时检测可视化数据图，用户可以直观的看到世界各地的攻击数据，这个检测平台可以监测到网络上的各种攻击方式，来源于哪个国家等详细数据。http://map.ipviking.com/","tags":[{"name":"网站","slug":"网站","permalink":"http://seniorzhai.github.io/tags/网站/"}]},{"title":"iPhone界面适配详解","date":"2014-11-04T09:45:31.000Z","path":"2014/11/04/iPhone界面适配详解/","text":"显示效果 3GS iPhone 4/4s iPhone 5/5s iPhone 6 iPhone 6 Plus 元素素材 3GS defult_Head_image.png 97 × 97 defult_btn_image.png 229 × 45 iPhone 4/4s default_Head_image@2x.png 193 × 193 default_btn_image@2x.png 458 × 89 iPhone 5/5s default_Head_image_5@2x.png 193 × 193 default_btn_image_5@2x.png 458 × 89 iPhone 6 default_Head_image_6@2x.png 263 × 263 default_btn_image_6@2x.png 573 × 112 iPhone 6 Plus default_Head_image6@3x.png 484 × 484 default_btn_image6@3x.png 1062 × 282 真机效果 iPhone 5/5s iPhone 6 iPhone 6 Plus","tags":[{"name":"适配","slug":"适配","permalink":"http://seniorzhai.github.io/tags/适配/"},{"name":"界面","slug":"界面","permalink":"http://seniorzhai.github.io/tags/界面/"},{"name":"多分辨率","slug":"多分辨率","permalink":"http://seniorzhai.github.io/tags/多分辨率/"}]},{"title":"Notification通知的使用","date":"2014-10-31T15:49:55.000Z","path":"2014/10/31/Notification通知的使用/","text":"Notification是应用程序提醒用户发生某些事件的一种方式，包括以下功能： 显示状态栏图标 灯光/LED闪烁 让手机振动 发出声音提醒（铃声、Media Store中的音频） 在通知托盘中显示额外的信息 在通知栏中使用交互式操作来广播Intent Notification ManagerNotificationManager是用来处理Notification的系统Service，使用getSystemService方法可以获得对它的引用1NotificationManager notificationManager = (NotificationManager)gerSystemService(Context.NOTIFICATION_SERVICE); 通过NotificationManager可以触发新的Notification，修改现有的Notification删除不需要的Notifition 创建Notification向用户传递信息的方式： 状态栏图标 声音、闪光灯和振动 在展开的通知托盘中显示详细信息 创建Notification和配置状态栏图标1Notification notification = new Notification(R.drawable.icon,\"Notification\",System.currentTimeMills()); // 指定图标，文本，时间戳 还可以设置Notification对象的number属性来显示一个状态栏显示一个状态图标所表示的时间数量 使用默认的Notification声音、闪灯和振动向Notification添加声音、闪灯和振动效果的可以使用默认的设置： Notification.DEFAULT_LIGHTS 灯 Notification.DEFAULT_SOUND 声音 Notification.DEFAULT_VIBRATE 振动1notification.defaults = Notification.DEFAULT_SOUND | Notification.DEFAULT_VIBRATE; 可以使用Notification.DEFAULT_ALL开启全部 发出声音使用sound属性向Notification分配一个新的声音并指定音频文件的URI12Uri ringURI = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION);notification.sound = ringURI; 设备振动首先需要设置权限1&lt;user-permission android:name=\"android.permisson.VIBRATE\" /&gt; 设置振动方式时，可以向Notification的vibrate属性分配一个long[]类型数组来设置振动和暂停时间的交替1notification.vibrate = new long[] &#123;1000,1000,1000,1000&#125; 闪屏Notification还可以设置设备的LED的颜色和闪烁频率1234notification.ledARGB = Color.RED; //设置LED颜色notification.ledOffMS = 0; //设置LED闪烁的频率notification.ledOnMS = 1; notification.flags = notification.flags | Notification.FLAG_SHOW_FIGHTS; // 要使用LED必须添加flags属性 Notification BuilderApi 11(Android 3.0)引入的Api，简化了Notification的配置12345678910111213Notification.Builder builder = new Notification.Builder(mContext);builer.setSmallIcon(R.drawable.icon); .setTicker(\"Notification\") .setWhen(System.currrntTimeMillis()) .setDefaults(Notification.DEFAULT_SOND | Notification.DEFAULT_VIBRATE) .setSound( RingtoneManager.getDefaultUri( RingtoneManager.TYPE_NOTIFICATION)) .setVibrate(new long[] &#123;1000,1000,1000,1000,1000,1000&#125;) .setLights(Color.RED,0,1);Notication notification = builder.getNotification(); 设置和自定义通知托盘UI配置Notification的外观主要方法有 设置setLatesEventInfo方法更新标准的通知托盘所显示的详细信息 设置Notification Builder创建和控制众多可选通知托盘UI中的一个 设置contentView和contentIntent属性，以便使用Remote View对象展开的状态显示分配一个自定义的UI 从Api 11(Android 3.0)开始，描述自定义UI的Remote Views对象可以为每个View分配一个Broadcast Intent，以使他们完全可交互 标准的Notification UI```","tags":[]},{"title":"onSaveInstanceState&onRestoreInstanceState","date":"2014-10-31T15:17:10.000Z","path":"2014/10/31/onSaveInstanceState&onRestoreInstanceState/","text":"onSaveInstanceState当Activity可能会被销毁时，该Activity的onSaveInstanceState会被执行，除非Activity是主动销毁的。onSaveInstanceState的调用遵循一个规则，即未经允许，则onSaveInstanceState会被系统调用，这是一个保留数据的机会.通常onSaveInstanceState被调用的情况有： 当用户按下HOME键时 长按HOME键，选择运行其他的程序时 按下电源键（关闭屏幕显示）时 从Activity启动新的Activity时 屏幕切换时 屏幕切换时，系统会销毁Activity再自动创建Activity，onSaveInstance一定会被执行 onRestoreInstanceStateonRestoreInstanceState会在Activity被系统销毁后，被重建时调用，在Activity的onStart之后调用123456789protected void onSaveInstanceState(Bundle savedInstanceState) &#123; super.onSaveInstanceState(icicle); savedInstanceState.putLong(\"param\", value);&#125;public void onCreate(Bundle savedInstanceState) &#123; if (savedInstanceState != null)&#123; value = savedInstanceState.getLong(\"param\"); &#125;&#125;","tags":[{"name":"保存数据","slug":"保存数据","permalink":"http://seniorzhai.github.io/tags/保存数据/"},{"name":"SaveInstance","slug":"SaveInstance","permalink":"http://seniorzhai.github.io/tags/SaveInstance/"}]},{"title":"AutoCompleteTextView","date":"2014-10-29T06:11:24.000Z","path":"2014/10/29/AutoCompleteTextView/","text":"AutoCompleteTextView工作流程依赖Adapter和Filter，一个处理视图(BaseAdapter)，一个是数据过滤(Filterable) Filter有两个重要方法： protected FilterResults performFiltering(CharSequence prefix) 定制过滤策略，根据输入的prefix对数据进行过滤，并组装成FilterResults结果返回 protected void publisgResults(CharSequence constraint,FilterResults results) 发布结果，把上面方法的结果按照一定的要求处理后，通知Adapter进行数据视图刷新","tags":[]},{"title":"PopupWindow用法","date":"2014-10-27T08:30:35.000Z","path":"2014/10/27/PopupWindow用法/","text":"1234567PopupWindow mPop = new PopupWindow(getLayoutInflater().inflate(R.layout.window,null),LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);mPop.setAnimationStyle(R.style.AnimationPreview);mPop.setOutsideTouchable(true); // 点击外部是否关闭mPop.setFocusable(false); // 设置PopupWindow能否获得焦点mPop.showAsDropDown(anchor,0,0); // 设置显示PopupWindow的位置在View的下方，x,y表示坐标偏移量mPop.showAtLocation(findViewById(R.id.parent),Gravity.LEFT,0,-90); // 以某个View为参考，表示弹出窗口以parent组件为参考，位于左侧，偏移-90mPop.setOnDismissListenerd(new PopupWindow.OnDismissListener()&#123;&#125;); // 设置窗口消失事件","tags":[]},{"title":"Swift与OC中nil的区别","date":"2014-10-26T14:56:37.000Z","path":"2014/10/26/Swift与OC中nil的区别/","text":"在Objective-C中，nil是一个指针不存在的对象。Swift中，nil是一个空值，不单单指指针，任何可选变量都可以被设为nil，且不能用于非可选类型。1var num : Int ? = 4 //可选类型，要么为nil要么为4","tags":[{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"nil","slug":"nil","permalink":"http://seniorzhai.github.io/tags/nil/"}]},{"title":"runOnUiThread()更新UI","date":"2014-10-26T10:41:35.000Z","path":"2014/10/26/runOnUiThread()更新UI/","text":"Activity.runOnUiThread()是Handlers的特殊情况，使用Handlers可以在自己的线程里创建事件查询。默认情况下，使用handler不是”代码在UI线程中运行”，handlers会绑定到其实例化的线程上，想要创建直接绑定UI线程的handlers需要looper1Handler mHandler = new Handler(Looper.getMainLooper()); 如果使用runOnUiThread，需要使用handler：1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125;","tags":[{"name":"线程","slug":"线程","permalink":"http://seniorzhai.github.io/tags/线程/"},{"name":"Thread","slug":"Thread","permalink":"http://seniorzhai.github.io/tags/Thread/"},{"name":"Ui","slug":"Ui","permalink":"http://seniorzhai.github.io/tags/Ui/"}]},{"title":"Android屏幕适配知识","date":"2014-10-24T12:21:54.000Z","path":"2014/10/24/Android屏幕适配知识/","text":"基本概念 分辨率，即手机屏幕的像素点数，一般描述为宽×高，Android常见的分辨率有480×800、720×1280、1080×1920等 屏幕大小，即手机屏幕对角线的物理尺寸，以英寸(inch)为单位(1英寸=2.54厘米) 像素密度(dpi:dots per inch或PPI:pixels per inch)，即每英寸的像素点数，数值越高显示越细腻 如下图：分辨率为1080×1920，尺寸为5英寸，根据勾股定理对角线的像素约2203，那么像素密度大约为440 密度分级因为手机的像素密度千奇百怪，在屏幕适配的时候必须按一定规则分类，于是有了密度分级，每部Android手机都有一个初始的固定密度，120、160、320、480……通常情况240×320的屏幕是低密度120dpi即ldpi，320×480为中密度160dpi即mdpi，480*800为高密度240dpi即hdpi，720×1280为超高密度320dpi即xhpi，1080×1920为超超高密度480dpi即xxhdpi dp密度无关的像素dp也成为dip即density-independent pixel，为了实现在不同分辨率的屏幕上显示“看上去”一样大小需要使用dp来指定尺寸。文字尺寸一般使用sp即scale-independentpixel，这样字体的大小就会随着系统设置调节字号的大小而改变 dp与px的转换像素密度为160dpi的中密度手机屏幕为基准屏幕，即320×480的屏幕，此时1dp=1px像素密度为240dpi的高密度屏幕，即480×800的屏幕，为了显示一张在320×480屏幕“看上去”一样大小的尺寸，需要把尺寸放大1.5倍，此时1dp=1.5px一次类推dp在不同像素密度下的比例为：ldpi:mdpi:xhdpi:xxhdpi=3:4:6:8:12，间隔数字之间是2的倍数当Android系统字号设为“普通”时，sp与px的尺寸换算和dp与px一样 建议目前市面上普遍的机型为720×1280即xhdpi，此时1dp=2px，图片资源放在drawable-xhdpi文件夹中","tags":[]},{"title":"Android、iOS切图规范","date":"2014-10-23T12:45:50.000Z","path":"2014/10/23/Android、iOS切图规范/","text":"","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"gravity属性","date":"2014-10-22T13:01:59.000Z","path":"2014/10/22/gravity属性/","text":"android:gravity 用于设置View中内容相对于View组件的对齐方式 android:layout_gravity 用于设置View组件相对于Container的对齐方式","tags":[{"name":"gravity","slug":"gravity","permalink":"http://seniorzhai.github.io/tags/gravity/"}]},{"title":"httplib模块","date":"2014-10-16T06:57:09.000Z","path":"2014/10/16/httplib模块/","text":"httplib.HTTPConnection(host,[,port,[,strict,[,timeout]]]) 表示一次与服务器的交互，即请求/响应。host表示服务器主机，port表示端口号(默认值是80)，参数strict默认值为false，表示在无法解析服务器返回的状态行时(status line)是否剖出BadStatusLine异常，可选参数timeout表示超时时间 HTTPConnection.request(method,url,[,body[,headers]]) 发送一次请求，method表示请求方法，url表示请求资源，body表示提交服务器的数据，必须是字符串，headers表示请求的http头 HTTPConnection.getresponse() 获取Http 响应 HTTPConnection.connect() 连接到HTTP服务器 HTTPConnection.close() 关闭与服务器连接 HTTPConnection.set_debuglevel(level) 设置调试级别，参数level默认为0，表示不输出任何调试信息 httplib.HTTPResponse 表示服务器对客户端的相应，通过HTTPConnection.getresponse()来创建 HTTPResponse.read([amt]) 获取响应的消息体，如果请求的是一个普通的网页，该方法返回页面的html，可选参数amt表示从响应流中读取指定字节的数据 HTTPResponse.getheader(name[, default]) 获取响应头。Name表示头域(header field)名，可选参数default在头域名不存在的情况下作为默认值返回。 HTTPResponse.getheaders() 以列表的形式返回所有的头信息。 HTTPResponse.msg 获取所有的响应头信息。 HTTPResponse.version 获取服务器所使用的http协议版本。11表示http/1.1；10表示http/1.0。 HTTPResponse.status 获取响应的状态码。如：200表示请求成功。 HTTPResponse.reason 返回服务器处理请求的结果说明。一般为”OK” 12345678910headers = &#123;\"Content-type\": \"application/x-www-form-urlencoded\" , \"Accept\": \"text/plain\"&#125;values = &#123;'param1':'2','param2':'3'&#125;params = urllib.urlencode(values)conn = httplib.HTTPConnection(\"ave.bolyartech.com\") conn.request(\"POST\", \"/params.php\", params,headers)response = conn.getresponse() print response.status, response.reason print response.read()conn.close();","tags":[{"name":"http","slug":"http","permalink":"http://seniorzhai.github.io/tags/http/"},{"name":"python","slug":"python","permalink":"http://seniorzhai.github.io/tags/python/"}]},{"title":"Eclipse实用快捷键","date":"2014-10-15T05:55:09.000Z","path":"2014/10/15/Eclipse实用快捷键/","text":"Ctrl + o快速跳转可以搜索(显示大纲) Ctrl + 上下键移动行 Ctrl + shift + r搜索文件 Ctrl + m最大化编辑窗口 Ctrl + shift + o导入包 Ctrl + 1快速修复 Ctrl + pageup/pagedown选项卡切换 Ctrl + W关闭当前编辑框 Ctrl + d删除行 Ctrl + shift + F4关闭所有编辑框 Ctrl + shift + X选中文本全部大写 Ctrl + shift + Y选中文本全部小写 Ctrl + shift + F格式化当前代码 Shift + Enter插入空行 Ctrl + shift + T查找Java类文件 Ctrl + shift + G查找引用 Ctrl + K高亮代码 Alt + shift + R重命名","tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://seniorzhai.github.io/tags/eclipse/"}]},{"title":"Android主题和样式","date":"2014-10-14T05:14:42.000Z","path":"2014/10/14/Android主题和样式/","text":"位置在Android Frameworks/base/core/res/res/values目录下 themes.xml themes_device_defaults.xml styles.xml styles_device_defaults.xml 主题Themetheme.xml定义了Android低版本的theme和Holo theme，themes_device_defaults.xml定义了DeviceDefault主题(继承自Holo主题)系统如何选择默认主题呢？1234567891011121314151617181920212223/**frameworks/base/core/java/android/content/res/Resources.java*/public static int selectDefaultTheme(int curTheme, int targetSdkVersion) &#123; return selectSystemTheme(curTheme, targetSdkVersion, com.android.internal.R.style.Theme, com.android.internal.R.style.Theme_Holo, com.android.internal.R.style.Theme_DeviceDefault);&#125; public static int selectSystemTheme(int curTheme, int targetSdkVersion, int orig, int holo, int deviceDefault) &#123; if (curTheme != 0) &#123; return curTheme; &#125; if (targetSdkVersion &lt; Build.VERSION_CODES.HONEYCOMB) &#123; // &lt; 11 return orig; &#125; if (targetSdkVersion &lt; Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; // &lt; 14 return holo; &#125; return deviceDefault;&#125; 当=11&amp;&amp;14时，使用DeviceDefault主题 系统主题Theme列表系统默认大的主题是三种：Theme,Theme.Holo,Theme.DeviceDefault, 但是实际上在此基础系统还定义了大量的派生主题，最典型的是对应的Light主题。 详解每个主题item分类 颜色 123456789&lt;item name=\"colorForeground\"&gt;@android:color/bright_foreground_dark&lt;/item&gt;&lt;item name=\"colorForegroundInverse\"&gt;@android:color/bright_foreground_dark_inverse&lt;/item&gt;&lt;item name=\"colorBackground\"&gt;@android:color/background_dark&lt;/item&gt;&lt;item name=\"colorBackgroundCacheHint\"&gt;?android:attr/colorBackground&lt;/item&gt;&lt;item name=\"colorPressedHighlight\"&gt;@color/legacy_pressed_highlight&lt;/item&gt;&lt;item name=\"colorLongPressedHighlight\"&gt;@color/legacy_long_pressed_highlight&lt;/item&gt;&lt;item name=\"colorFocusedHighlight\"&gt;@color/legacy_selected_highlight&lt;/item&gt;&lt;item name=\"colorMultiSelectHighlight\"&gt;@color/legacy_selected_highlight&lt;/item&gt;&lt;item name=\"colorActivatedHighlight\"&gt;@color/legacy_selected_highlight&lt;/item&gt; 字体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;item name=\"textAppearance\"&gt;@android:style/TextAppearance&lt;/item&gt;&lt;item name=\"textAppearanceInverse\"&gt;@android:style/TextAppearance.Inverse&lt;/item&gt; &lt;item name=\"textColorPrimary\"&gt;@android:color/primary_text_dark&lt;/item&gt;&lt;item name=\"textColorSecondary\"&gt;@android:color/secondary_text_dark&lt;/item&gt;&lt;item name=\"textColorTertiary\"&gt;@android:color/tertiary_text_dark&lt;/item&gt;&lt;item name=\"textColorPrimaryInverse\"&gt;@android:color/primary_text_light&lt;/item&gt;&lt;item name=\"textColorSecondaryInverse\"&gt;@android:color/secondary_text_light&lt;/item&gt;&lt;item name=\"textColorTertiaryInverse\"&gt;@android:color/tertiary_text_light&lt;/item&gt;&lt;item name=\"textColorPrimaryDisableOnly\"&gt;@android:color/primary_text_dark_disable_only&lt;/item&gt;&lt;item name=\"textColorPrimaryInverseDisableOnly\"&gt;@android:color/primary_text_light_disable_only&lt;/item&gt;&lt;item name=\"textColorPrimaryNoDisable\"&gt;@android:color/primary_text_dark_nodisable&lt;/item&gt;&lt;item name=\"textColorSecondaryNoDisable\"&gt;@android:color/secondary_text_dark_nodisable&lt;/item&gt;&lt;item name=\"textColorPrimaryInverseNoDisable\"&gt;@android:color/primary_text_light_nodisable&lt;/item&gt;&lt;item name=\"textColorSecondaryInverseNoDisable\"&gt;@android:color/secondary_text_light_nodisable&lt;/item&gt;&lt;item name=\"textColorHint\"&gt;@android:color/hint_foreground_dark&lt;/item&gt;&lt;item name=\"textColorHintInverse\"&gt;@android:color/hint_foreground_light&lt;/item&gt;&lt;item name=\"textColorSearchUrl\"&gt;@android:color/search_url_text&lt;/item&gt;&lt;item name=\"textColorHighlight\"&gt;@android:color/highlighted_text_dark&lt;/item&gt;&lt;item name=\"textColorHighlightInverse\"&gt;@android:color/highlighted_text_light&lt;/item&gt;&lt;item name=\"textColorLink\"&gt;@android:color/link_text_dark&lt;/item&gt;&lt;item name=\"textColorLinkInverse\"&gt;@android:color/link_text_light&lt;/item&gt;&lt;item name=\"textColorAlertDialogListItem\"&gt;@android:color/primary_text_light_disable_only&lt;/item&gt; &lt;item name=\"textAppearanceLarge\"&gt;@android:style/TextAppearance.Large&lt;/item&gt;&lt;item name=\"textAppearanceMedium\"&gt;@android:style/TextAppearance.Medium&lt;/item&gt;&lt;item name=\"textAppearanceSmall\"&gt;@android:style/TextAppearance.Small&lt;/item&gt;&lt;item name=\"textAppearanceLargeInverse\"&gt;@android:style/TextAppearance.Large.Inverse&lt;/item&gt;&lt;item name=\"textAppearanceMediumInverse\"&gt;@android:style/TextAppearance.Medium.Inverse&lt;/item&gt;&lt;item name=\"textAppearanceSmallInverse\"&gt;@android:style/TextAppearance.Small.Inverse&lt;/item&gt;&lt;item name=\"textAppearanceSearchResultTitle\"&gt;@android:style/TextAppearance.SearchResult.Title&lt;/item&gt;&lt;item name=\"textAppearanceSearchResultSubtitle\"&gt;@android:style/TextAppearance.SearchResult.Subtitle&lt;/item&gt; &lt;item name=\"textAppearanceEasyCorrectSuggestion\"&gt;@android:style/TextAppearance.EasyCorrectSuggestion&lt;/item&gt;&lt;item name=\"textAppearanceMisspelledSuggestion\"&gt;@android:style/TextAppearance.MisspelledSuggestion&lt;/item&gt;&lt;item name=\"textAppearanceAutoCorrectionSuggestion\"&gt;@android:style/TextAppearance.AutoCorrectionSuggestion&lt;/item&gt; &lt;item name=\"textAppearanceButton\"&gt;@android:style/TextAppearance.Widget.Button&lt;/item&gt; &lt;item name=\"editTextColor\"&gt;@android:color/primary_text_light&lt;/item&gt;&lt;item name=\"editTextBackground\"&gt;@android:drawable/edit_text&lt;/item&gt; &lt;item name=\"candidatesTextStyleSpans\"&gt;@android:string/candidates_style&lt;/item&gt; &lt;item name=\"textCheckMark\"&gt;@android:drawable/indicator_check_mark_dark&lt;/item&gt;&lt;item name=\"textCheckMarkInverse\"&gt;@android:drawable/indicator_check_mark_light&lt;/item&gt; &lt;item name=\"textAppearanceLargePopupMenu\"&gt;@android:style/TextAppearance.Widget.PopupMenu.Large&lt;/item&gt;&lt;item name=\"textAppearanceSmallPopupMenu\"&gt;@android:style/TextAppearance.Widget.PopupMenu.Small&lt;/item&gt; 按钮 12345678910&lt;item name=\"buttonStyle\"&gt;@android:style/Widget.Button&lt;/item&gt; &lt;item name=\"buttonStyleSmall\"&gt;@android:style/Widget.Button.Small&lt;/item&gt;&lt;item name=\"buttonStyleInset\"&gt;@android:style/Widget.Button.Inset&lt;/item&gt; &lt;item name=\"buttonStyleToggle\"&gt;@android:style/Widget.Button.Toggle&lt;/item&gt; &lt;item name=\"selectableItemBackground\"&gt;@android:drawable/item_background&lt;/item&gt;&lt;item name=\"borderlessButtonStyle\"&gt;?android:attr/buttonStyle&lt;/item&gt;&lt;item name=\"homeAsUpIndicator\"&gt;@android:drawable/ic_ab_back_holo_dark&lt;/item&gt; List 12345678910&lt;item name=\"listPreferredItemHeight\"&gt;64dip&lt;/item&gt;&lt;item name=\"listPreferredItemHeightSmall\"&gt;?android:attr/listPreferredItemHeight&lt;/item&gt;&lt;item name=\"listPreferredItemHeightLarge\"&gt;?android:attr/listPreferredItemHeight&lt;/item&gt;&lt;item name=\"dropdownListPreferredItemHeight\"&gt;?android:attr/listPreferredItemHeight&lt;/item&gt;&lt;item name=\"textAppearanceListItem\"&gt;?android:attr/textAppearanceLarge&lt;/item&gt;&lt;item name=\"textAppearanceListItemSmall\"&gt;?android:attr/textAppearanceLarge&lt;/item&gt;&lt;item name=\"listPreferredItemPaddingLeft\"&gt;6dip&lt;/item&gt;&lt;item name=\"listPreferredItemPaddingRight\"&gt;6dip&lt;/item&gt;&lt;item name=\"listPreferredItemPaddingStart\"&gt;6dip&lt;/item&gt;&lt;item name=\"listPreferredItemPaddingEnd\"&gt;6dip&lt;/item&gt; Window 123456789101112131415161718&lt;item name=\"windowBackground\"&gt;@android:drawable/screen_background_selector_dark&lt;/item&gt;&lt;item name=\"windowFrame\"&gt;@null&lt;/item&gt;&lt;item name=\"windowNoTitle\"&gt;false&lt;/item&gt;&lt;item name=\"windowFullscreen\"&gt;false&lt;/item&gt;&lt;item name=\"windowOverscan\"&gt;false&lt;/item&gt;&lt;item name=\"windowIsFloating\"&gt;false&lt;/item&gt;&lt;item name=\"windowContentOverlay\"&gt;@null&lt;/item&gt;&lt;item name=\"windowShowWallpaper\"&gt;false&lt;/item&gt;&lt;item name=\"windowTitleStyle\"&gt;@android:style/WindowTitle&lt;/item&gt;&lt;item name=\"windowTitleSize\"&gt;25dip&lt;/item&gt;&lt;item name=\"windowTitleBackgroundStyle\"&gt;@android:style/WindowTitleBackground&lt;/item&gt;&lt;item name=\"android:windowAnimationStyle\"&gt;@android:style/Animation.Activity&lt;/item&gt;&lt;item name=\"android:windowSoftInputMode\"&gt;stateUnspecified|adjustUnspecified&lt;/item&gt;&lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt;&lt;item name=\"windowActionModeOverlay\"&gt;false&lt;/item&gt;&lt;item name=\"windowCloseOnTouchOutside\"&gt;false&lt;/item&gt;&lt;item name=\"windowTranslucentStatus\"&gt;false&lt;/item&gt;&lt;item name=\"windowTranslucentNavigation\"&gt;false&lt;/item&gt; Dialog 1234&lt;item name=\"dialogTheme\"&gt;@android:style/Theme.Dialog&lt;/item&gt;&lt;item name=\"dialogTitleIconsDecorLayout\"&gt;@layout/dialog_title_icons&lt;/item&gt;&lt;item name=\"dialogCustomTitleDecorLayout\"&gt;@layout/dialog_custom_title&lt;/item&gt;&lt;item name=\"dialogTitleDecorLayout\"&gt;@layout/dialog_title&lt;/item&gt; AlertDialog 1234&lt;item name=\"alertDialogTheme\"&gt;@android:style/Theme.Dialog.Alert&lt;/item&gt;&lt;item name=\"alertDialogStyle\"&gt;@android:style/AlertDialog&lt;/item&gt;&lt;item name=\"alertDialogCenterButtons\"&gt;true&lt;/item&gt;&lt;item name=\"alertDialogIcon\"&gt;@android:drawable/ic_dialog_alert&lt;/item&gt; Panel 123456789&lt;item name=\"panelBackground\"&gt;@android:drawable/menu_background&lt;/item&gt;&lt;item name=\"panelFullBackground\"&gt;@android:drawable/menu_background_fill_parent_width&lt;/item&gt;&lt;!-- These three attributes do not seems to be used by the framework. Declared public though --&gt;&lt;item name=\"panelColorBackground\"&gt;# 000&lt;/item&gt;&lt;item name=\"panelColorForeground\"&gt;?android:attr/textColorPrimary&lt;/item&gt;&lt;item name=\"panelTextAppearance\"&gt;?android:attr/textAppearance&lt;/item&gt; &lt;item name=\"panelMenuIsCompact\"&gt;false&lt;/item&gt;&lt;item name=\"panelMenuListWidth\"&gt;296dip&lt;/item&gt; 滚动条(Scrollbar) 1234567&lt;item name=\"scrollbarFadeDuration\"&gt;250&lt;/item&gt;&lt;item name=\"scrollbarDefaultDelayBeforeFade\"&gt;300&lt;/item&gt; &lt;item name=\"scrollbarSize\"&gt;10dip&lt;/item&gt;&lt;item name=\"scrollbarThumbHorizontal\"&gt;@android:drawable/scrollbar_handle_horizontal&lt;/item&gt;&lt;item name=\"scrollbarThumbVertical\"&gt;@android:drawable/scrollbar_handle_vertical&lt;/item&gt;&lt;item name=\"scrollbarTrackHorizontal\"&gt;@null&lt;/item&gt;&lt;item name=\"scrollbarTrackVertical\"&gt;@null&lt;/item&gt; 文字选中(Text selection) 12345678910&lt;item name=\"textSelectHandleLeft\"&gt;@android:drawable/text_select_handle_left&lt;/item&gt;&lt;item name=\"textSelectHandleRight\"&gt;@android:drawable/text_select_handle_right&lt;/item&gt;&lt;item name=\"textSelectHandle\"&gt;@android:drawable/text_select_handle_middle&lt;/item&gt;&lt;item name=\"textSelectHandleWindowStyle\"&gt;@android:style/Widget.TextSelectHandle&lt;/item&gt;&lt;item name=\"textEditPasteWindowLayout\"&gt;@android:layout/text_edit_paste_window&lt;/item&gt;&lt;item name=\"textEditNoPasteWindowLayout\"&gt;@android:layout/text_edit_no_paste_window&lt;/item&gt;&lt;item name=\"textEditSidePasteWindowLayout\"&gt;@android:layout/text_edit_side_paste_window&lt;/item&gt;&lt;item name=\"textEditSideNoPasteWindowLayout\"&gt;@android:layout/text_edit_side_no_paste_window&lt;/item&gt;&lt;item name=\"textSuggestionsWindowStyle\"&gt;@android:style/Widget.TextSuggestionsPopupWindow&lt;/item&gt;&lt;item name=\"textEditSuggestionItemLayout\"&gt;@android:layout/text_edit_suggestion_item&lt;/item&gt;","tags":[{"name":"Holo","slug":"Holo","permalink":"http://seniorzhai.github.io/tags/Holo/"}]},{"title":"Material","date":"2014-10-14T05:14:42.000Z","path":"2014/10/14/Material/","text":"Material ThemeMaterial Theme的定义如下 @android:style/Theme.Material @android:style/Theme.Material.Light @android:style/Theme.Material.DarkActionBar 自定义主题的基础颜色1234567&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"android:Theme.Material\"&gt; &lt;item name=\"android:colorPrimary\"&gt;@color/primary&lt;/item&gt; &lt;item name=\"android:colorPrimaryDark\"&gt;@color/primary_dark&lt;/item&gt; &lt;item name=\"android:colorAccent\"&gt;@color/accent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;","tags":[{"name":"Material","slug":"Material","permalink":"http://seniorzhai.github.io/tags/Material/"}]},{"title":"UIL图片异步加载库的使用","date":"2014-10-14T03:14:42.000Z","path":"2014/10/14/UIL图片异步加载库的使用/","text":"使用作为图片加载库必须设置网络、SD卡权限12&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 设置缓存目录123File cacheDir = StorageUtils.getOwnCacheDirectory(getApplicationContext(),\"imageloader/Cache\");// 设置ImageLoaderConfiguration.discCache(new UnlimitedDiscCache(cacheDir)); 配置ImageLoaderConfiguration12345678910111213141516171819ImageLoaderConfiguration config = new ImageLoaderConfiguration .Builder(context) .memoryCacheExtraOptions(480,800) // 保存的每个文件的最大长宽 .discCacheExtraOptions(480,800,CompressFormat.JPEG,75,null) // 设置详细信息，最好不要设置 .threadPoolSize(3) // 线程池加载的数量 .threadPriority(Thread.NORM_PRIORITY - 2) .denyCacheImageMultipleSizesInMemory() .memoryCache(new UsingFreqLimitedMemoryCache(2 * 1024 * 1024)) // 缓存，可以自己实现 .memoryCacheSize(2 * 1024 * 1024) .discCacheSize(50 * 1024 * 1024) .discCacheFileNameGenerator(new Md5FileNameGenerator()) // 保存URI名称用MD5加密 可以使用HashCodeFileNameGenerator .tasksProcessingOrder(QueueProcessingType.LIFO) .discCacheFileCount(100) // 缓存文件数量 .discCache(new UnlimitedDiscCache(cacheDir)) // 自定义缓存路径 .defaultDisplayImageOptions(DisplayImageOptions.createSimple()) .imageDownloader(new BaseImageDownloader(context,5 * 1000,30 * 1000)) // 连接超时5s，读取超时30s .writeDebugLogs() .build(); // 开始构建ImageLoader.getInstance().init(config); 加载1234567891011121314151617181920// 获取ImageLoader实例ImageLoader imageLoader = ImageLoader.getInstance();// 设置配置DisplayImageOptions option;options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.ic_launcher) // 设置图片在下载期间显示的图片 .showImageForEmptyUri(R.drawable.ic_launcher) // 设置图片Uri为空或者是错误的时候显示的图片 .showImageOnFail(R.drawable.ic_laucher) // 设置图片加载、解码过程错误的时候显示的图片 .cacheInMemory(true) // 设置下载的图片是否缓存在内存中 .cacheOnDisc(true) // 设置下载的图片是否缓存在SD卡中 .considerExifParams(true) // 是否考虑JPEG图像EXIF参数(旋转、翻转) .imageScaleType(ImageScaleType.EXACTLY_STRETCHED) //设置图片以何种编码方式显示 .bitmapConfig(Bitmap.Config.RGB_565) // 设置图片的解码类型 .decodingOptions(android.graphics.BitmapFactory.Options decodingOptions) // 设置图片的解码配置 .delayBeforeLoading(int delayInMillis) // 下载完的延迟时间 .preProcessor(BitmapProcessor preProcessor) // 设置图片加入缓存前，对bitmap进行设置 .resetViewBeforeLoading(true) // 设置图片在下载前是否重置，复位 .displayer(new RondedBitmapDisplayer(20)) // 是否设置为圆角 .displayer(new FadeInBitmapDisplayer(100)) // 是否显示加载渐入动画 .build(); // 构建完成 不需要的可以不做配置 .imageScaleType(ImageScaleType imageScaleType) 设置图片的缩放方式 EXACTLY:图像将完全按比例缩小到目标大小 EXACTLY_STRETCHED:图片会缩放到目标大小 IN_SAMPLE_INT:图像将被二次采样的整数倍 IN_SAMPLE_POWER_OF_2:图片将降低2倍，直到下一减少步骤，使图像更小的目标大小 NONE:图片不会调整 .displayer(BitmapDisplayer displayer) 是设置 图片的显示方式 RoundedBitmapDisplayer(int roundPixels) 设置圆角图片 FakeBitmapDisplayer() 这个类什么都没做 FadeInBitmapDisplayer(int durationMillis) 设置图片渐显的时间 SimpleBitmapDisplayer() 正常显示一张图片 12ImageLoader.getInstance().displayImage(imageUrl, imageView); // imageUrl代表图片的URL地址，imageView代表承载图片的IMAGEVIEW控件 ImageLoader.getInstance().displayImage(imageUrl, imageView，options); // imageUrl代表图片的URL地址，imageView代表承载图片的IMAGEVIEW控件 ， options代表DisplayImageOptions配置文件 加载监听123456789101112131415161718imageLoader.displayImage(imageUrl, imageView, options, new ImageLoadingListener() &#123; @Override public void onLoadingStarted() &#123; //开始加载的时候执行 &#125; @Override public void onLoadingFailed(FailReason failReason) &#123; //加载失败的时候执行 &#125; @Override public void onLoadingComplete(Bitmap loadedImage) &#123; //加载成功的时候执行 &#125; @Override public void onLoadingCancelled() &#123; //加载取消的时候执行 &#125;&#125;); 加载监听进度12345678910111213141516171819202122imageLoader.displayImage(imageUrl, imageView, options, new ImageLoadingListener() &#123; @Override public void onLoadingStarted() &#123; //开始加载的时候执行 &#125; @Override public void onLoadingFailed(FailReason failReason) &#123; //加载失败的时候执行 &#125; @Override public void onLoadingComplete(Bitmap loadedImage) &#123; //加载成功的时候执行 &#125; @Override public void onLoadingCancelled() &#123; //加载取消的时候执行 &#125;,new ImageLoadingProgressListener() &#123; @Override public void onProgressUpdate(String imageUri, View view, int current,int total) &#123; //在这里更新 ProgressBar的进度信息 &#125; &#125;); 注意事项 权限 必须初始化ImageLoader.getInstance().init(config) ImageLoader是根据ImageView的height，width确定图片的宽高 如果经常出现OOM ①减少配置之中线程池的大小，.(.threadPoolSize)推荐1-5； ②使用.bitmapConfig(Bitmap.config.RGB_565)代替ARGB_8888; ③使用.imageScaleType(ImageScaleType.IN_SAMPLE_INT)或者try.imageScaleType(ImageScaleType.EXACTLY)； ④避免使用RoundedBitmapDisplayer.他会创建新的ARGB_8888格式的Bitmap对象； ⑤使用.memoryCache(new WeakMemoryCache())，不要使用.cacheInMemory(); 其他12345String imageUri = \"http://site.com/image.png\"; // from Web String imageUri = \"file:///mnt/sdcard/image.png\"; // from SD card String imageUri = \"content://media/external/audio/albumart/13\"; // from content provider String imageUri = \"assets://image.png\"; // from assets String imageUri = \"drawable://\" + R.drawable.image; // from drawables (only images, non-9patch)","tags":[{"name":"UIL","slug":"UIL","permalink":"http://seniorzhai.github.io/tags/UIL/"},{"name":"异步加载","slug":"异步加载","permalink":"http://seniorzhai.github.io/tags/异步加载/"}]},{"title":"Android分辨率适配","date":"2014-10-14T03:14:42.000Z","path":"2014/10/14/Android分辨率适配/","text":"基本概念 分辨率：屏幕上显示的像素个数，单位尺寸内像素点越多，显示的图像就越清楚 主流分辨率:480*800、720*1280、1080*1920 像素密度 240dpi(480*800)、320dpi(720*1280)、480dpi(1080*1920) 单位 px:像素 dp:设备独立像素(160dpi为标准)240dpi下，1dp=1.5px 320dpi下，1dp=2px 480dpi下，1dp=3px sp:等同于dp，用于描述字体大小240dpi下，1sp=1.5px 320dpi下，1sp=2px 480dpi下，1sp=3px 常见分辨率 4:3 VGA 640*480 QVGA 320*240 HVGA 480*320 SVGA 800*600 5:3 WVGA 800*480 16:9 FWVGA 854*480 HD 1920*1080 QHD 960*540 720p 1280*720 1080p 1920*1080 Apple iPhone4/4s 960*640 iPhone5/5s 1136*640 iPhone6 1334*750 iPhone6Plus 1920*1080 小米1 854*480 小米2 1280*720 红米1/1s/note 1280*720 对应的DPI HVGA mdpi WVGA hdpi FWVGA hdpi QHD hdpi 720p xhdpi 1080p xxhdpi最佳方案 选取320dpi下(720*1280)进行设计，此分辨率下1dp=2px 对于一切切图资源特殊处理 输出多套分辨率的切图，例如480p和720p，在设计的时候要注意好切图区域的大小能被2和1.5整除的大小，如48p*48px、96*96px等。 使用相对于单位进行标注 采用自适应布局 标注尽量采用相对关系 文字中文字体：默认为Droid Sans Fallback,设计时可采用微软雅黑。英文字体：Andriod4.x及以上采用Roboto，Andrio2.x和andriod3.x采用 Droid Sans。建议尽量采用系统默认字体。Andriod规范建议，字号采用12sp、14sp、18sp、22sp等四个级别来设计。（实际设计时可以按实际情况调整） 总结 采用720*1280分辨率来进行设计。（设计时，采用偶数值进行设计，方便dp和px的转换） 开始标注了，标注尽量采用相对位置进行标注。 切图了，在720*1280下进行切图，可以完全适配720*1280后放大缩小切图资源 分别适配480*800、1080*1920 不要忘记了，开发完后要进行bug测试（视觉方面的）","tags":[{"name":"分辨率","slug":"分辨率","permalink":"http://seniorzhai.github.io/tags/分辨率/"}]},{"title":"volley详解","date":"2014-10-14T02:20:43.000Z","path":"2014/10/14/volley详解/","text":"基本请求12345678910111213StringRequest stringRequest = new StringRequest(\"http://www.baidu.com\",new Response.Listener&lt;String&gt;()&#123; @Override public void onResponse(String response) &#123; // &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResopnse(VolleyError error) &#123; // &#125; &#125;&#125;);// 添加请求道请求队列中mQueue.add(stringRequest); 三个参数分别是目标服务器的URL地址，服务器响应成功的回调，服务器响应失败的回调 Post123456789StringRequest stringRequest = new StringRequest(Method.POST,url,listener,errorListenrer) &#123; @Override protected Map&lt;String,String&gt; getParams() throws AuthFailureError &#123; Map&lt;String,String&gt; map = newHash&lt;String,String&gt;(); map.put(\"params1\",\"value1\"); map.put(\"params2\",\"value2\"); return map; &#125;&#125; JsonRequestJsonRequest是一个抽象类，有两个直接子类，JsonObjectRequest和JsonArrayRequest，分别用于处理JSON数据和JSON数组1234567891011JsonObjectRequest jsonObjectRequest = new JsonObjectRequest(\"http://m.weather.com.cn/data/101010100.html\",null, new Response.Listener&lt;JSONObject&gt;() &#123; @Override public void onResponse(JSONObject response) &#123; Log.d(\"TAG\", response.toString()); &#125; &#125;, new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.e(\"TAG\", error.getMessage(), error); &#125; &#125;); ImageRequest12345678910111213ImageRequest imageRequest = new ImageRequest( \"https://avatars3.githubusercontent.com/u/5416585?v=2&amp;s=460\", new Response.Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap response) &#123; imageView.setImageBitmap(response); &#125; &#125;,0,0,Config.RGB_565,new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; imageView.setImageResource(R.drawable.default_image); &#125; &#125;); 第三第四个参数指定允许图片最大的宽度和高度，如果指定的网络图片的宽度或高度大于这里的最大值，则会对图片进行压缩，指定为0即表示不管图片多大都不压缩。 ImageLoader","tags":[{"name":"网络","slug":"网络","permalink":"http://seniorzhai.github.io/tags/网络/"},{"name":"Volley","slug":"Volley","permalink":"http://seniorzhai.github.io/tags/Volley/"}]},{"title":"Python实现简单的Post请求","date":"2014-10-13T07:19:52.000Z","path":"2014/10/13/Python实现简单的Post请求/","text":"1234567891011import urllibimport urllib2url = 'http://ave.bolyartech.com/params.php'values = &#123;'param1':'2','param2':'3'&#125;data = urllib.urlencode(values)print datareq = urllib2.Request(url, data) # Post请求response = urllib2.urlopen(req)the_page = response.read() # 读取返回数据print the_page","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"},{"name":"Post","slug":"Post","permalink":"http://seniorzhai.github.io/tags/Post/"}]},{"title":"Python-十 - 常用内建模块","date":"2014-10-13T03:17:22.000Z","path":"2014/10/13/Python-十---常用内建模块/","text":"collections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtupletuple可以表示不变集合，例如一个二维坐标就可以表示成p = (1,2)如果使用class表示太过臃肿，namedtuple就可以派上用场123from collections import namedtuplePoint namedtuple('Point',['x','y'])p = Point(1,2) namedtuple是一个函数，用来创建自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素12# 定义一个圆Circle = namedtuple('Circle',['x','y','r']) dequedeque可以高效地实现插入和删除操作的双向列表，适用于队列和栈1234from collections import dequeq = deque(['a','b','c'])q.append('x')q.appendleft('y') # 添加到头部 deque除了实现list的append()和pop()外，还支持appendleft()和popleft()可以头部添加或删除元素 defaultdict适用dict时，如果引用的key不存在，就会抛出KeyError，如果希望不存在时，返回一个默认值，就可以用defaultdict:1234from collections import defaultdictdd = defaultdict(lambda: 'N/A')dd['key1'] = 'abc'dd['key2'] # 'N/A' OrderedDictdict的Key是无序的，OrderedDict的key会按照插入的顺序排列，不是Key本身的排序12from collections import OrderedDictod = OrderedDict([('a', 1), ('b', 2), ('c', 3)]) OrderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：12345678910111213141516171819from collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict): def __init__(self, capacity): super(LastUpdatedOrderedDict, self).__init__() self._capacity = capacity def __setitem__(self, key, value): containsKey = 1 if key in self else 0 if len(self) - containsKey &gt;= self._capacity: last = self.popitem(last=False) print 'remove:', last if containsKey: del self[key] print 'set:', (key, value) else: print 'add:', (key, value) OrderedDict.__setitem__(self, key, value) CounterCounter是dict的子类，是一个简单的计数器12345from collections import Counterc = Counter()for ch in 'programming': c[ch] = c[ch] + 1c # Counter(&#123;'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1&#125;) base64Base64是一种用64个字符表示任意二进制数据的方法Base64的原理很简单，首先准备一个包含64个字符的数组： [‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/‘]每3个字节一组，一共3x8=24bit，划为4组，每组正好6bit: 这样的得到4个字数作为索引，然后查表，获得相应的4个字符，就是编码后的字符串Base64编码会把3个字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉123import base64base64.b64encode('binary\\x00string') # 'YmluYXJ5AHN0cmluZw=='base64.b64decode('YmluYXJ5AHN0cmluZw==')# 'binary\\x00string' 标准的Base64编码后可能出线+和/，在URL就不能直接作为参数，可以使用url safe的base编码，把字符+和/分别变成-和_123base64.b64encode('i\\xb7\\x1d\\xfb\\xef\\xff') # 'abcd++//'base64.urlsafe_b64encode('i\\xb7\\x1d\\xfb\\xef\\xff') # 'abcd--__'base64.urlsafe_b64decode('abcd--__') # 'i\\xb7\\x1d\\xfb\\xef\\xff' 由于=字符会出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，很多Base64编码后会把=去掉因为Base64是把3个字节变成4个字节，所以Base64编码的长度永远是4的倍数，去掉=后，解码时增加=到4的倍数，再正常解码 structPython的struct模块用来处理str和其他二进制数据类型的转换12import structstruct.pack('&gt;I',10240099) # '\\x00\\x9c@c' 把任意数据类型变成字符串 pack第一个参数是处理指令，&gt;表示字节顺序是big-endian(网络序)，I表示4字节无符号整数1struct.unpack('&gt;IH','\\xf0\\xf0\\xf0\\xf0\\x80\\x80') # (4042322160,32896) H表示2字节无符号整数Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。首先找一个bmp文件，没有的话用“画图”画一个。读入前30个字节来分析：12&gt;&gt;&gt; s = '\\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00'BMP格式采用小端方式存储数据，文件头的结构按顺序如下： 两个字节：’BM’表示Windows位图，’BA’表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。所以，组合起来用unpack读取：12&gt;&gt;&gt; struct.unpack('&lt;ccIIIIIIHH', s)('B', 'M', 691256, 0, 54, 40, 640, 360, 1, 24) 结果显示，’B’、’M’说明是Windows位图，位图大小为640x360，颜色数为24。 hashlibhashlib提供了常见的摘要算法，如MD5，SHA1等摘要算法又称为哈希算法、散列算法，通过函数把任意长度的数据转换成为一个长度固定的数据串(通常用16进制的字符串表示)摘要算法是单向的，反向推导十分困难，原始数据有一点改动，都会导致计算出的摘要完全不同12345678import hashlibmd5 = hashlib.md5()md5.update('how to use md5 in python hashlib?')print md5.hexdugest() # d26a53750bc40b38b65a520292f69306# 如果数据量很大，可以多次调用update()md5.update('how to use md5 in')md5.update('python hashlib?') MD5是最常见的摘要算法，速度很快，生成结果是固定的128bit字节，通常用一个32位的16进制字符串表示常见的摘要算法还有SHA1:123456import hashlibsha1 = hashlib.sha1()sha1.update('how to use sha1 in ')sha1.update('python hashlib?')print sha1.hexdigest() SHA1的结果是160bit字节，通常用一个40位的16进制字符串表示比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长 摘要算法的应用比如用户的密码，使用明文保存十分的不安全，可以使用摘要算法保存摘要一些常用口令的MD5值容易被计算出来，所以可以在用户口令基础上加复杂的字符串实现加盐算法12def calc_md5(password): return get_md5(password + 'the-Salt') 只要Salt(盐)不泄露，即使再简单的MD5反推明文也是很难实现的 XMLXML作为一种包装数据的形式，使用的范围越来越小，远远不及JSON，但是还是有必要了解操作XML有两种方法：DOM和SAX，DOM会把整个XML读入到内存，因此占用内存大，解析慢，但是可以访问任意树的节点。SAX是流模式，边读边解析，占用内存小，解析快，但是要处理事件1234567891011121314151617181920# 解析&lt;a href=\"/\"&gt;python&lt;/a&gt;from xml.parsers.expat import ParseCreateclass DefaultSaxHandler(object): def start_element(self,name,attrs): print('sax:start_element:%s,attrs:%s' % (name,str(attrs))) def end_elemnet(self,name): print('sax:end_element:%s' % name) def char_data(self,text): print('sax:char_data:%s' % text)handler = DefaultSaxHandler()parser = ParserCreate()parser.returns_unicode = True # 返回element名称和char_data都是unicodeparser.StartElementHandler = handler.start_elementparser.EndElementHandler = handler.end_elementparser.CharacterDataHandler = handler.char_dataparser.Parse(xml) HTMLParserHTML是XML子集，语法不如XML严格，解析时可以使用HTMLParser12345678910111213141516171819202122232425262728from HTMLParser import HTMLParserfrom htmlentitydefs import name2codepointclass MyHTMLParser(HTMLParser): def handle_starttag(self,tag,attrs): print('&lt;%s&gt;' % tag) def handle_endtag(self,tag): print('&lt;/%s&gt;' % tag) def handle_startendtag(self,tag,attrs): print('&lt;%s/&gt;' % tag) def handle_data(self,data): print('data') def handle_comment(self,data): print('&lt;!-- --&gt;') def handle_entityref(self,name): print('&amp;%s;' % name) def handle_charref(self,name): print('&amp;# %s;' % name)parser = MyHTMLParser()parser.feed('&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Some &lt;a href=\\\"# \\\"&gt;html&lt;/a&gt; tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;') feed可以调用多次，不一定要一次性把HTML字符串都塞进去","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Lambda","date":"2014-10-13T03:17:22.000Z","path":"2014/10/13/Lambda/","text":"lambda函数也叫匿名函数即函数没有具体的名称lambda语句用来创建新的函数对象，并且在运行时返回它们1234567def make_repeater(n): return lambda s: s * ntwice = make_repeater(2)print twice('word') # wordwordprint twice(5) # 10 lambda语句用来创建函数对象，本质上，lambda需要一个参数，后面仅跟单个表达式作为函数体，而表达式的值被这个新建的函数返回。主要的作用： 使用Python写一些脚本时，使用lambda可以省去定义函数的过程 对于一些抽象，不会别的地方再复用的函数可以使用 使用lambda在某些时候可以让代码更容易理解","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python小技巧","date":"2014-10-13T03:09:07.000Z","path":"2014/10/13/Python小技巧/","text":"交换变量123x = 6y = 5x,y = y,x 行内if语句1print \"Hello\" if True else \"World\" # Hello 连接不同类型的对象连接12345678910111213nfc = [\"Packers\", \"49ers\"]afc = [\"Ravens\", \"Patriots\"]nfc + afc # ['Packers', '49ers', 'Ravens', 'Patriots']print str(1) + \" world\"&gt;&gt;&gt; 1 world print `1` + \" world\"&gt;&gt;&gt; 1 worldprint 1, \"world\"&gt;&gt;&gt; 1 worldprint nfc, 1&gt;&gt;&gt; ['Packers', '49ers'] 1 数字技巧12345.0//2 # 向下取整 22**5 # 2的5次方.3/.1 # 2.9999999999999996.3//.1 # 2.0 数值比较12345x = 2if 3 &gt; x &gt; 1 print xif 1 &lt; x &gt; 0 print x 同时迭代两个列表1234nfc = [\"Packers\", \"49ers\"]afc = [\"Ravens\", \"Patriots\"]for teama, teamb in zip(nfc, afc): print teama + \" vs. \" + teamb 带索引的列表迭代123teams = [\"Packers\", \"49ers\", \"Ravens\", \"Patriots\"]for index, team in enumerate(teams): print index, team 列表推导式12numbers = [1,2,3,4,5,6]even = [number for number in numbers if number%2 == 0] # 取偶数 字典推导12teams = [\"Packers\", \"49ers\", \"Ravens\", \"Patriots\"]print &#123;key: value for value, key in enumerate(teams)&#125; 初始化列表1items = [0]*3 列表转换成字符串123teams = [\"Packers\", \"49ers\", \"Ravens\", \"Patriots\"]print \", \".join(teams)&gt;&gt;&gt; 'Packers, 49ers, Ravens, Patriots'","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python 九 - 进程和线程","date":"2014-10-11T08:09:07.000Z","path":"2014/10/11/Python-九---进程和线程/","text":"Unix/Linux操作系统提供了fork()系统调用，fork()调用一次，返回两次，因为操作系统自动把当前进程(父进程)复制一份(子进程)，分别在父进程和子进程返回。子进程永远返回0，而父进程返回子进程的ID。一个父进程可以fork出很多子进程，所以父进程要记下每个子进程的ID，而子进程字需要getppid()就可以拿出父进程的ID123456789# multiprocessing.pyimport osprint 'Process (%s) start...' % os.getpid()pid = os.fork()if pid==0: print 'I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())else: print 'I (%s) just created a child process (%s).' % (os.getpid(), pid) 注：Windows没有fork调用，所以上面代码在windows无法运行有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务 multiprocessingmultiprocessing模块是跨平台版本的多进程模块，它提供了一个Process类来代表一个进程对象12345678910111213from multiprocessing import Processimport osdef run_proc(name): print 'Run child process %s (%s)...' % (name,os.getpid())if __name__=='__main__': print 'Run child process %s .' % os.getpid() p = Process(target=run_proc,args=('test',)) print 'Process will start.' p.start() # 启动`start()` p.join() # 等待子进程结束再继续往下运行 print 'Process end.' Pool需要启动大量子进程，可以用进程池的方式批量创建子进程:12345678910111213141516171819from multiprocessing import poolimport os,time,randomdef long_time_task(name): print 'Run task %s (%s)...' % (name,os.getpid()) start = time.time() time.sleep(random.random() * 3) end = time.time() print 'Task %s runs %0.2f seconds.' % (name,(end - start))if __name__=='__main__': print 'Parent process %s.' % os.getpid() p = Pool() for i in range(5): p.apply_async(long_time_task,args=(i,)) print'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocesses done.' Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用之后就不能继续添加新的Process了。Pool默认大小是CPU的核数，可以在Pool()中设置参数，设置同时进行的任务数 进程间通信Python提供了Queue、Pipes等多种方式来交互数据12345678910111213141516171819202122from multiprocessing import Process,Queueimport os,time,randomdef write(q): for value in ['A','B','C']: print 'Put %s to queue...' % value q.put(value) time.sleep(random.random())def read(q): while True: value = q.get(True) print 'Get %s from queue.' % valueif __name__=='__main__': q = Queue() pw = Process(target=write,args=(q,)) pr = Process(target=read,args=(q,)) pw.start() pr.start() pw.join() # 等待pw结束 pr.terminate() # pr进程是死循环，无法等待其结束，只能强制终止 在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所有，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python 八 - 文件IO","date":"2014-10-11T03:29:34.000Z","path":"2014/10/11/Python-八---文件IO/","text":"文件读写Python内置的open()函数可以传入文件名和标示符打开一个文件对象1f = open('./test.txt','r') r表示读，如果文件不存在open()函数会抛出一个IOError错误如果文件打开成功，调用read()函数可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示1str = f.read() 因为文件对象会占用系统资源，所以使用完毕需要调用close()函数关闭文件Python引入with语句帮助我们自动调用close方法12with open('./file','r') as f: f.read() read方法可以read(size)每次最多读取size个字节的内容，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list12for line in f.readlines(): print(line.strip()) # 把末尾的`\\n`删掉 二进制文件读取二进制文件比如图片、视频等，用rb模式打开即可：1f = open('./test.jpg','rd') 字符编码读取非ASCALL编码的文本文件，必须以二进制模式打开，再解码，比如GBK编码的文件123f = open('./gbk.txt','rb')u = f.read().decode('gbk')print u 写文件在open函数传入标识符W或者wb表示写文件或写二进制文件123f = open('./test.txt','w')f.write('Hello,world!')f.close 也可以使用with语句12with open('./test.txt','w') as f: f.write('Hello,world!') 写入特定编码也需要转码 文件操作要操作文件需要导入Python内置的os模块12import osos.name # 操作系统的名字 如果是posix说明系统是Linux、Unix或者Mac OS X，如果是nt就是Windows系统获取系统详细信息可以调用uname()函数通过os.environ可以看到系统环境变量的dict要获取环境变量的某个值可以调用os.getenv()函数 操作文件和目录 os.path.abspath(‘.’) # 当前目录的绝对路径 os.path.join(‘/User/zoe’,’testDir’) # 合并路径 os.path.split(‘/Users/zoe/testDir/file.txt’) # 拆分目录 os.path.splitext(‘/path/file.txt’) # 拆分文件扩展名 os.mkdir(‘./testdir’) # 创建目录 os.rmdir(‘./testdir’) # 删除目录 os.rename(‘test.txt’,’test.py’) # 重命名 os.remove(‘test.txt’) # 删除文件os模块中并没有复制文件可以使用shutil模块提供的copyfile()函数1234# 列出当前目录下的所有子目录list1 = [x for x in os.listdir('.') if os.path.isdir(x)]# 列出所有py文件list2 = [x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py'] 序列化Python提供了cPickle和pickle两个模块来实现序列化，两个模块功能一致，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢，用的时候先尝试导入cPickle，如果失败了，再导入pickle1234try: import cPickle as pickleexcept ImportError: import pickle 使用pickle.dumps()方法把任意对象序列化成一个str，然后，把str写入文件也可以使用pickle.dump()直接把对象序列化写入file12345d = dict(name='Bob',age=20,score=88)str = pickle.dumps(d)f = open('dump.txt','wb')pickle.dump(d,f)f.close() 反序列化是用pickle.loads()方法通过读取到字符串反序列化出对象，也可以直接用pickle.load()方法从file中直接反序列化出对象123f = open('dump.txt','rb')d = pickle.load(f)f.close() Pickle的缺点很明显，只能用于Python并且可能不同版本的Python批次都不兼容 JSONJSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： JSON类型 Python类型 {} dict [] list “string” str或u”unicode” 1234.56 int或float true/flase True/False null None Python内置的json模块提供了完善的Python对象到JSON格式的转换123import jsond = dict(name='Bob',age=20,score=88)json.dumps(d) # '&#123;\"age\": 20, \"score\": 88, \"name\": \"Bob\"&#125;' 同样dump()方法可以直接把JSON写入文件，loads()或load()方法可以把反序列化 JSON进阶对象序列化，需要实现一个转换函数1234567891011121314151617import jsonclass Stundent(object): def __init__(self,name,age,score): self.name = name self.age = age self.score = scores = Stundent('Bob',20,88)def student2dict(std): return &#123; 'name':std.name, 'age':std.age, 'score':std.score &#125;json.dumps(s,default=student2dict) # 先被student2dict转换成dict在顺利序列化为JSON 通常class实例都有一个__dict__属性，用来存储实例变量，所以也可以这么写：1json.dumps(s,default=lambda obj:obj.__dict__) 反序列化时1234def dict2student(d): return Student(d['name'],d['age'],d['score'])json.loads(json_str,object_hook=dict2student)","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python 七 - 错误与调试","date":"2014-10-11T03:28:31.000Z","path":"2014/10/11/Python-七---错误与调试/","text":"try错误12345678try: r = 10/0 print rexcept ZeroDivisionError,e: print 'except:',efinally: print 'finally'print 'END' 在某段代码可能会出错时，就可以用try来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即except语句块，执行完except后，如果有finally语句块，则执行finally语句块，至此执行完毕如果没有发生错误发生，可以在except语句块后面加一个else，如果没有错误发生时，会自动执行else语句 记录错误Python内置的logging模块可以非常容易地记录错误信息：1234567891011121314151617# err.pyimport loggingdef foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar('0') except StandardError,e: logging.exception(e)main()print 'END' 同样是出错，但程序打印完错误后会继续执行，并正常退出 抛出错误错误是class，捕获一个错误就是捕获到该class的一个实例，因此，错误不是凭空产生的，而是有意创建抛出的。Python内置函数会抛出很多类型的错误，可以使用raise语句抛出错误123456789# err.pyclass FooError(StandarError): passdef foo(s): n = int(s) if n == 0: raise FooError('invalid value:%s' % s) return 10/n 断言12345678# err.pydef foo(s): n = int(s) assert n != 0,'n is zero!' return 10 / ndef main(): foo('0') assert的意思是，表达式n != 0应该是True，否则，后面的代码就会出错(AssertionError)Python解释器可以用-0参数来关闭assert logging1234567# err.pyimport loggings = '0'n = int(s)logging.info('n = %d' % n)print 10 / n logging.info()可以输出一段文本，可以使用logging.basicConfig(level=logging.INFO)指定记录信息的级别，有debug、info、warning、error，当指定level=INFO时，其他级别都不起作用，其他同理。 pdb调试器，可以让程序以单步方式运行，可以随时查看运行状态1234# err.pys = '0'n = int(s)print 10 / n 然后启动 $ python -m pdb err.py以参数-m pdb启动后，pdb定位到下一步要执行的代码-&gt; s = &#39;0&#39;输入命令l查看运行代码输入n可以单步指定代码也可以输入p 变量名来查看变量输入q结束调试，退出程序 pdb.set_trace()只需要import pdb然后在可能出错的地方放一个pdb.set_trace()就可以设置一个断点1234567# err.pyimport pdbs = '0'n = int(s)pdb.set_trace()print 10 / n 运行代码，程序自动在pdb.set_trace()暂停并进入pdb调试环境，可以用c继续运行","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python中的yield","date":"2014-10-10T06:33:42.000Z","path":"2014/10/10/Python中的yield/","text":"如果函数中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。而变成generator的函数在每次调用next()的时候执行遇到yield语句返回，再次执行时从上一次返回的yield语句继续执行12345def fib(max): a,b,c = 0,1,0 while c &lt; max: yield b a,b,c = b,a+b,c+1 &gt;&gt;&gt; o = fib(1000) &gt;&gt;&gt; o.next() 1 &gt;&gt;&gt; o.next() 1 &gt;&gt;&gt; o.next() 2 &gt;&gt;&gt; o.next() 3 &gt;&gt;&gt; o.next()","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"},{"name":"yield","slug":"yield","permalink":"http://seniorzhai.github.io/tags/yield/"}]},{"title":"Shell(一)","date":"2014-10-10T05:36:31.000Z","path":"2014/10/10/Shell(一)/","text":"Shell是一个程序，它接收从键盘输入的命令，然后把命令传递给操作系统去执行，几乎所有的Linux发行版都提供了一个名为bash的程序，bash是Shell的一种，是Bourne Again Shell的缩写，是Shell的增强版。 简单的命令 date 当前日期 cal 当前月份的日历 df 磁盘剩余空间 free 空闲内存数量 exit 结束终端模拟器 文件操作 ls 列出目录包含的文件和子目录 cd 切换当前目录 .指的是当前目录，..值当前目录的父目录 cd 更改工作目录到主目录 cd - 更改工作目录到先前的工作目录 cd ~ 切换到当前用户的主目录，加username可切换到对应用户的主目录 pwd 打印出当前工作目录名 ls ls -l 表示长模式输出 ls -t 表示按文件修改时间的先后排序 ls -lt –reverse 表示相反顺序输出 选项 长选项 描述 -a –all 列出所有文件，包括隐藏文件 -d –directory 显示目录本身的详细信息 -F –classify 在每个所列出的名字后面加上指示符，比如名字是目录名，则会加上/字符 -h –human-readable 以长格式列出，以人们可读的格式，而不是以字节数来显示文件大小 -l 以长格式显示 -r -reverse 以相反的顺序显示结果，默认按照字母升序排列 -S 按文件大小来排序 -t 按照修改时间来排序 filefile命令可以查看文件的简要描述 less浏览文件内容 命令 行为 Page Up or b 向后翻滚一页 Page Down or space 向前翻滚一页 UP Arrow 向前移动一行 Down Arrow 向后移动一行 G 移动到最后一行 g 移动到开头一行 /charaters 向前查找指定的字符串 n 向前查找下一个出现的字符串 h 显示帮助屏幕 q 推出less程序 Linux系统目录 目录 介绍 / 根目录 /bin 系统启动和运行所必须的二进制程序 /boot 包含内核和启动加载程序 /dev 设备 /etc 系统层面的配置文件，包含一系列的shell脚本 /home 用户目录 /lib 系统程序所需的库文件 /mnt 挂载点 /opt 用来安装“可选的”软件，存储可能安装在系统中的商用软件 /root root账户的主目录 /sbin 系统二进制文件，完成重大系统任务的程序 /tmp 临时文件 /usr 普通用户的所有程序和文件 /usr/bin 安装的可执行文件 /usr/lib 共享库 /usr/sbin 系统管理程序 /usr/share 共享数据，图标、桌面背景、配置文件等 /usr/share/doc 文档 /var 需要改动的文件存储的地方。各种数据库，假脱机文件，用户邮件等 /var/log 日志文件","tags":[{"name":"shell","slug":"shell","permalink":"http://seniorzhai.github.io/tags/shell/"}]},{"title":"ColorPicker","date":"2014-10-09T01:50:13.000Z","path":"2014/10/09/ColorPicker/","text":"一个简单的带动画的颜色选择Dialog 使用123456789new AnimatedColorPickDialog.Builder(MainActivity.this) .setTitle(\"选择一个颜色\") .setColors(styleColors) //颜色数组 RGB十六进制整数格式 .setOnColorClickListener(new AnimatedColorPickerDialog.ColorClickListener() &#123; @Override public void onColorClick(int color) &#123; colorDisplayView.setBackgroundColor(color); &#125; &#125;).create().show(); 示例:https://github.com/SeniorZhai/ColorPickDialog","tags":[{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"},{"name":"颜色选择器","slug":"颜色选择器","permalink":"http://seniorzhai.github.io/tags/颜色选择器/"}]},{"title":"在Chrome上使用Markdown","date":"2014-09-30T02:17:29.000Z","path":"2014/09/30/在Chrome上使用Markdown/","text":"作为码农，高效的排版是必不可缺的，作为Markdown的重度依赖者，今天发现了一个插件，可以帮助我在Chrome上任何的使用。 Markdown here Github地址 Chrome插件地址 如果想取消转换，选中转换后的效果，同样选择Mardown Toggle就可以了","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://seniorzhai.github.io/tags/Markdown/"}]},{"title":"CountDownTimer倒计时类","date":"2014-09-30T01:38:22.000Z","path":"2014/09/30/CountDownTimer倒计时类/","text":"Android官方有提供CountDownTimer类可以帮助我们很好的实现倒计时功能123456789101112131415mButton.setOnClickListener(new View.onClickListener()&#123; @Override public void onClick(View v)&#123; new CountDownTimer(10000,1000) &#123; // 倒计时长，和回调间隔 public void onTick(long millisUntilFinished) &#123; mButton.setText(millisUntilFinished / 1000 + \"s后重新发送\"); &#125; public void onFinish() &#123; mButton.setText(\"重新获取验证码\"); mButton.setEnabled(true); &#125; &#125; &#125;&#125;);","tags":[{"name":"倒计时","slug":"倒计时","permalink":"http://seniorzhai.github.io/tags/倒计时/"},{"name":"Api","slug":"Api","permalink":"http://seniorzhai.github.io/tags/Api/"}]},{"title":"Android Studio导入Jar包及第三方开源库的方法","date":"2014-09-29T06:48:52.000Z","path":"2014/09/29/Android-Studio导入Jar包及第三方开源库的方法/","text":"Jar包Jar包的处理相对简单，将Jar包复制到lib文件夹中，然后右击Jar包选择add as a library即可导入。删除时，需要先删除build.gradle中的语句，再删除Jar包 添加远程开源库一般新的开源库在其README.md中都会有相应连接，比如FlatUI，在其GitHub页面可以得到以下内容要将上面内容添加到项目中的build.gradle中，切勿添加到全局的build.gradle文件中去 添加本地开源库下载开源库后，放置在app目录同级的目录下，编辑setting.gradle文件加入:开源库文件名，例如在app同级目录下放置了volley的开源文件夹，编辑setting.gradle的内容为1include ':app',\":volley\" 之后再app目录下的build.gradle文件下，在dependencies{}节点下加入:1compile project(':volley')","tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://seniorzhai.github.io/tags/Android-Studio/"},{"name":"IDE","slug":"IDE","permalink":"http://seniorzhai.github.io/tags/IDE/"}]},{"title":"晃动动画","date":"2014-09-29T02:51:28.000Z","path":"2014/09/29/晃动动画/","text":"效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class AnimationUtils &#123; public static ObjectAnimator tada(View view) &#123; return tada(view, 1f); &#125; public static ObjectAnimator tada(View view, float shakeFactor) &#123; PropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofKeyframe(View.SCALE_X, Keyframe.ofFloat(0f, 1f), Keyframe.ofFloat(.1f, .9f), Keyframe.ofFloat(.2f, .9f), Keyframe.ofFloat(.3f, 1.1f), Keyframe.ofFloat(.4f, 1.1f), Keyframe.ofFloat(.5f, 1.1f), Keyframe.ofFloat(.6f, 1.1f), Keyframe.ofFloat(.7f, 1.1f), Keyframe.ofFloat(.8f, 1.1f), Keyframe.ofFloat(.9f, 1.1f), Keyframe.ofFloat(1f, 1f) ); PropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofKeyframe(View.SCALE_Y, Keyframe.ofFloat(0f, 1f), Keyframe.ofFloat(.1f, .9f), Keyframe.ofFloat(.2f, .9f), Keyframe.ofFloat(.3f, 1.1f), Keyframe.ofFloat(.4f, 1.1f), Keyframe.ofFloat(.5f, 1.1f), Keyframe.ofFloat(.6f, 1.1f), Keyframe.ofFloat(.7f, 1.1f), Keyframe.ofFloat(.8f, 1.1f), Keyframe.ofFloat(.9f, 1.1f), Keyframe.ofFloat(1f, 1f) ); PropertyValuesHolder pvhRotate = PropertyValuesHolder.ofKeyframe(View.ROTATION, Keyframe.ofFloat(0f, 0f), Keyframe.ofFloat(.1f, -3f * shakeFactor), Keyframe.ofFloat(.2f, -3f * shakeFactor), Keyframe.ofFloat(.3f, 3f * shakeFactor), Keyframe.ofFloat(.4f, -3f * shakeFactor), Keyframe.ofFloat(.5f, 3f * shakeFactor), Keyframe.ofFloat(.6f, -3f * shakeFactor), Keyframe.ofFloat(.7f, 3f * shakeFactor), Keyframe.ofFloat(.8f, -3f * shakeFactor), Keyframe.ofFloat(.9f, 3f * shakeFactor), Keyframe.ofFloat(1f, 0) ); return ObjectAnimator.ofPropertyValuesHolder(view, pvhScaleX, pvhScaleY, pvhRotate). setDuration(1000); &#125; public static ObjectAnimator nope(View view) &#123; int delta = view.getResources().getDimensionPixelOffset(R.dimen.spacing_medium); PropertyValuesHolder pvhTranslateX = PropertyValuesHolder.ofKeyframe(View.TRANSLATION_X, Keyframe.ofFloat(0f, 0), Keyframe.ofFloat(.10f, -delta), Keyframe.ofFloat(.26f, delta), Keyframe.ofFloat(.42f, -delta), Keyframe.ofFloat(.58f, delta), Keyframe.ofFloat(.74f, -delta), Keyframe.ofFloat(.90f, delta), Keyframe.ofFloat(1f, 0f) ); return ObjectAnimator.ofPropertyValuesHolder(view, pvhTranslateX). setDuration(500); &#125;&#125;","tags":[{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"}]},{"title":"Sublime Text使用指南","date":"2014-09-28T06:33:22.000Z","path":"2014/09/28/Sublime-Text使用指南/","text":"安装Package ControlSublime Text支持大量插件，Package Control能够帮助我们管理这些插件，它可以方便的浏览、安装和卸载Sublime Text中的插件 使用Ctrl+`打开Sublime Text控制台 输入下面命令道控制台 1import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404&apos; + &apos;e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 等待Package Control安装完成，使用Ctrl + Shift + P打开命令板 基本操作 Ctrl + Enter在当前行下面增加一行并跳至该行 Ctrl + Shift + Enter在当前行上增加一行并跳至该行 Ctrl + ←/→逐词移动 Ctrl + Shift + ←/→逐词选择 Ctrl + ↑/↓移动显示区域 Ctrl + Shift + ↑/↓移动当前行选择 Ctrl + D选择当前光标所在的词并高亮该词出现的位置，再次按下选择该词下次出现的位置 Ctrl + K在多重选词的过程中进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑 Ctrl + Shift + L将当前选中区域打散，然后进行同时编辑 Ctrl + J将当前选中的区域合并成一行查找&amp;替换Sublime Text的查找功能可以分为快速查找、标准查找、多文件查找快速查找使用Shift + ←/→或者Ctrl + D选中关键字，然后使用F3跳到其下一个出现的位置，Shift + F3跳到其上一个出现的位置，Alt + F3可以选中其出现的所有位置标准查找&amp;替换使用Ctrl + F调出搜索框进行搜索使用Ctrl + H调出替换框，Ctrl +_Shift + H替换当前关键字，Ctrl + Alt + H替换所有匹配关键字关键字查找&amp;替换 Alt + C切换大小写敏感模式 Alt + W切换整字匹配模式多文件搜索Ctrl + Shift + F开启多文件搜索&amp;替换跳转 Ctrl + P会列出当前打开的文件（或者是当前文件夹的文件），输入文件名然后Enter跳转至该文件。 Ctrl + R会列出当前文件中的符号（例如类名和函数名，但无法深入到变量名），输入符号名称Enter即可以跳转到该处。此外，还可以使用F12快速跳转到当前光标所在符号的定义处（Jump to Definition）。 Ctrl + G然后输入行号以跳转到指定行。组合跳跃在Ctrl + P匹配文件后，可以进行后续输入以跳转到更精确的位置 @符号跳转：输入@demo跳转到demo符号所在的位置 #关键字跳转：输入# keyword跳转到keyword所在的位置 :行号跳转：输入:12跳转到文件的第12行。文件夹用Ctrl + K, Ctrl + B显示或隐藏侧栏，使用Ctrl + P快速跳转到文件夹里的文件。 使用Ctrl + Shift + N创建一个新窗口 Ctrl + N在当前窗口创建一个新标签，Ctrl + W关闭当前标签，Ctrl + Shift + T恢复刚刚关闭的标签。 分屏：Alt + Shift + 2进行左右分屏，Alt + Shift + 8进行上下分屏，Alt + Shift + 5进行上下左右分屏（即分为四屏）。 分屏下，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏 F11 全屏 Shift + F11 切换无干扰全屏格式化手动格式化使用Ctrl + [向左缩进，Ctrl + ]向右缩进，Ctrl + Shift + V以当前缩进粘贴代码此外也可以使用插件实现自动缩进和智能对齐 HTMLBeautify：格式化HTML。 AutoPEP8：格式化Python代码。 Alignment：进行智能对齐。中文输入法BugSublime Text一直存在一个Bug：中文输入框不跟随。解决方法是安装IMESupport插件，之后重启Sublime Text问题就解决了。","tags":[{"name":"Sublime Text","slug":"Sublime-Text","permalink":"http://seniorzhai.github.io/tags/Sublime-Text/"}]},{"title":"Python遍历","date":"2014-09-27T07:24:13.000Z","path":"2014/09/27/Python遍历/","text":"模块(module)可以更好的组织已有的程序 引入模块12345import first # 引入first模块# ...import a as b # 引入a模块并重命名为bfrom a import function1 # 引入a模块中的function1对象from a import * # 引入a模块中的所有对象 搜索路径 程序所在的文件夹 标准库的安装路径 操作系统环境中PYTHONPATH所包含的路径模块包可以把功能相似的模块放在同一个文件夹下，通过import this_dir.module引入thisdir文件夹下的module模块该文件夹中必须包含一个__init__.py的文件来提醒Python该文件夹为一个模块包，__init__.py可以是一个空文件","tags":[{"name":"遍历","slug":"遍历","permalink":"http://seniorzhai.github.io/tags/遍历/"}]},{"title":"Python模块","date":"2014-09-27T06:24:13.000Z","path":"2014/09/27/Python模块/","text":"内置方法 type() 查看数据类型 dir() 返回所以属性和方法 help() 返回帮助信息 range(x,y) 获取x到y-1的元素列表 常用方法 count() 列表含多少元素 index(x) 差选下标为x的元素 append() 在末尾添加元素 sort() 排序 pop() 或许最后一个元素，并去除 remove() 删除元素 insert(x,y) 在下边x的位置插入y 字典常用方法 keys() 返回dict所有键 values() 返回dict所有值 items() 返回dict所有元素 clear() 清空dict del dic{‘tom’} 删除’tom’元素 len() 获取地点的元素总数 12345678910dic = &#123;'zoe':1,'joy':2,'tom':3&#125;print dicprint len(dic)print dic.keys()print dic.values()print dic.items()del dic['tom']print dicdic.clear()print dic","tags":[{"name":"模块","slug":"模块","permalink":"http://seniorzhai.github.io/tags/模块/"}]},{"title":"为什么是Service不是Thread?","date":"2014-09-26T09:14:32.000Z","path":"2014/09/26/为什么是Service不是Thread/","text":"","tags":[]},{"title":"Python常用方法","date":"2014-09-26T00:24:13.000Z","path":"2014/09/26/Python常用方法/","text":"内置方法 type() 查看数据类型 dir() 返回所以属性和方法 help() 返回帮助信息 range(x,y) 获取x到y-1的元素列表 常用方法 count() 列表含多少元素 index(x) 差选下标为x的元素 append() 在末尾添加元素 sort() 排序 pop() 或许最后一个元素，并去除 remove() 删除元素 insert(x,y) 在下边x的位置插入y 字典常用方法 keys() 返回dict所有键 values() 返回dict所有值 items() 返回dict所有元素 clear() 清空dict del dic{‘tom’} 删除’tom’元素 len() 获取地点的元素总数 12345678910dic = &#123;'zoe':1,'joy':2,'tom':3&#125;print dicprint len(dic)print dic.keys()print dic.values()print dic.items()del dic['tom']print dicdic.clear()print dic","tags":[{"name":"常用","slug":"常用","permalink":"http://seniorzhai.github.io/tags/常用/"}]},{"title":"git命令","date":"2014-09-24T01:06:08.000Z","path":"2014/09/24/git命令/","text":"生成ssh-key Clone and Push 创建和切换分支 创建分支 git branch new_branch_name 切换分支 git checkout target_branch_name 删除分支 -D target_branch_name推送到远程分支 git push origin local_branch_name:remote_branch_name合并分支 git merge source_branch标记 git tag xxx","tags":[{"name":"git","slug":"git","permalink":"http://seniorzhai.github.io/tags/git/"}]},{"title":"购物车效果","date":"2014-09-23T05:40:55.000Z","path":"2014/09/23/购物车效果/","text":"主界面12345678910111213141516171819202122232425262728&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;ListView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/product_list\" android:cacheColorHint=\"# 00000000\" /&gt; &lt;RelativeLayout android:id=\"@+id/shopping_cart\" android:layout_width=\"wrap_content\" android:layout_height=\"70dp\" android:layout_alignParentBottom=\"true\" android:layout_marginLeft=\"20dp\" android:paddingBottom=\"22dp\" android:gravity=\"center_vertical\"&gt; &lt;ImageView android:id=\"@+id/shopping_img_cart\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:padding=\"1dp\" android:layout_alignParentLeft=\"true\" android:scaleType=\"centerInside\" android:src=\"@drawable/shopping_cart\"/&gt; &lt;/RelativeLayour&gt;&lt;/RelativeLayout&gt; item项12345678910111213141516171819202122232425&lt;RlativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"48dp\"&gt; &lt;Button android:id=\"@+id/product_buy_btn\" android:layout_width=\"40dp\" android:layout_height=\"48dp\" android:layout_alignParentRight=\"true\" android:layout_gravity=\"center_vertical\" android:layout_margin=\"10dp\" android:text=\"购买\" android:textColor=\"# F8720D\" android:textSize=\"12sp\" /&gt; &lt;TextView android:id=\"@+id/name\" android:layout_width=\"match_parent\" android:layout_height=\"48dp\" android:paddingLeft=\"10dp\" android:text=\"商品\" android:textSize=\"18sp\" android:gravity=\"center_vertical\" android:layout_toLeftOf=\"@id/product_buy_btn\" /&gt;&lt;/RlativeLayout&gt; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class MainActivity extends Activity &#123; private ListView mListView; private ImageView shopCart; private ImageView buyImg; private ViewGroup anim_mask_layout;//动画层 private Context mContext; private ProductAdapter productAdapter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mContext = this; initView(); &#125; private void initView() &#123; shopCart = (ImageView) findViewById(R.id.shopping_img_cart); mListView = (ListView) findViewById(R.id.product_list); productAdapter = new ProductAdapter(); mListView.setAdapter(productAdapter); &#125; private class ProductAdapter extends BaseAdapter &#123; public ProductAdapter() &#123; &#125; @Override public int getCount() &#123; return 20; &#125; @Override public String getItem(int position) &#123; return \"商品\" + (position + 1); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, final ViewGroup parent) &#123; String name = getItem(position); ViewHolder holder = null; if (convertView == null) &#123; convertView = LayoutInflater.from(mContext).inflate( R.layout.item, null); holder = new ViewHolder(); holder.nameTxt = (TextView) convertView.findViewById(R.id.name); holder.buyBtn = (Button) convertView .findViewById(R.id.product_buy_btn); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.nameTxt.setText(name); holder.buyBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; int[] start_location = new int[2]; v.getLocationInWindow(start_location); buyImg = new ImageView(mContext); buyImg.setImageResource(R.drawable.sign); setAnim(buyImg, start_location); &#125; &#125;); return convertView; &#125; class ViewHolder &#123; TextView nameTxt; Button buyBtn; &#125; &#125; private ViewGroup createAnimLayout() &#123; ViewGroup rootView = (ViewGroup) this.getWindow().getDecorView(); LinearLayout animLayout = new LinearLayout(this); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); animLayout.setLayoutParams(lp); animLayout.setId(Integer.MAX_VALUE); animLayout.setBackgroundResource(android.R.color.transparent); rootView.addView(animLayout); return animLayout; &#125; private View addViewToAnimLayout(final ViewGroup vg, final View view, int[] location) &#123; int x = location[0]; int y = location[1]; LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT); lp.leftMargin = x; lp.topMargin = y; view.setLayoutParams(lp); return view; &#125; private void setAnim(final View v, int[] start_location) &#123; anim_mask_layout = null; anim_mask_layout = createAnimLayout(); anim_mask_layout.addView(v);//把动画小球添加到动画层 final View view = addViewToAnimLayout(anim_mask_layout, v, start_location); int[] end_location = new int[2];// 这是用来存储动画结束位置的X、Y坐标 shopCart.getLocationInWindow(end_location);// shopCart是那个购物车 // 计算位移 int endX = 0 - start_location[0] + 40; int endY = end_location[1] - start_location[1]; Log.d(\"---\", endX+\"\"+endY); TranslateAnimation translateAnimationX = new TranslateAnimation(0, endX, 0, 0); translateAnimationX.setInterpolator(new LinearInterpolator()); translateAnimationX.setRepeatCount(0);// 动画重复执行的次数 translateAnimationX.setFillAfter(true); TranslateAnimation translateAnimationY = new TranslateAnimation(0, 0, 0, endY); translateAnimationY.setInterpolator(new AccelerateInterpolator()); translateAnimationY.setRepeatCount(0);// 动画重复执行的次数 translateAnimationX.setFillAfter(true); AnimationSet set = new AnimationSet(false); set.setFillAfter(false); set.addAnimation(translateAnimationY); set.addAnimation(translateAnimationX); set.setDuration(Math.abs(endY/1));// 动画的执行时间 v.startAnimation(set); set.setAnimationListener(new AnimationListener() &#123; // 动画的开始 @Override public void onAnimationStart(Animation animation) &#123; v.setVisibility(View.VISIBLE); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; // TODO Auto-generated method stub &#125; // 动画的结束 @Override public void onAnimationEnd(Animation animation) &#123; v.setVisibility(View.GONE); &#125; &#125;); &#125;&#125; 例子 https://github.com/SeniorZhai/ShoppingAnimation","tags":[{"name":"Animation","slug":"Animation","permalink":"http://seniorzhai.github.io/tags/Animation/"}]},{"title":"ListView特殊属性","date":"2014-09-23T03:39:12.000Z","path":"2014/09/23/ListView特殊属性/","text":"一些ListView的特殊属性 stackFromBottom 显示列表的最下面true或false transciptMode 最新的条目可以自动滚动到可视范围内alwayScroll cacheColorHint 拖动时颜色，自定义了背景最好指定透明# 00000000 divider 设置间隔线 fadingEdge 上下边的黑色阴影，none为没有阴影 scrollbars 是否隐藏滚动条 feadScrollbars 是否会自动隐藏滚动条","tags":[{"name":"ListView","slug":"ListView","permalink":"http://seniorzhai.github.io/tags/ListView/"}]},{"title":"穿越封锁线","date":"2014-09-23T02:27:58.000Z","path":"2014/09/23/穿越封锁线/","text":"对于广大码农来说，翻墙的主要目的就是Google一下，广大的Android Dev们更是需要SDK(为什么天朝连SDK都不让下)，下面推介一个简单易用的好办法。 Windows 请先退出所有杀毒软件 使用管理员身份运行 使用及更新: fuckGFW-64.exe(64位) / fuckGFW-32.exe(32位)双击运行*nix/OS X在终端运行$ curl http://tx.txthinking.com/fuckGFW.py | sudo python使用注意点 防止google本地化重定向: 访问https://www.google.com/ncr 请使用https替代http访问","tags":[{"name":"host","slug":"host","permalink":"http://seniorzhai.github.io/tags/host/"},{"name":"google","slug":"google","permalink":"http://seniorzhai.github.io/tags/google/"},{"name":"翻墙","slug":"翻墙","permalink":"http://seniorzhai.github.io/tags/翻墙/"}]},{"title":"iOS网络请求","date":"2014-09-22T07:14:26.000Z","path":"2014/09/22/iOS网络请求/","text":"iOS中的基本网络请求如下 同步同步访问网络不考虑延迟问题12345678910111213141516171819202122232425262728293031// 同步GetNSString *urlStr = [NSString stringWithFormat:@&quot;%@&quot;,@&quot;https://wap.baidu.com&quot;];NSString *newUrlStr = [urlStr stringByAddingPercentEscapesUsing:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:newUrlStr];// 创建网络请求NSURLRequest *request = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];// 创建同步连接NSURLResponse *response = nil;NSError *error = nil;NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error];// 同步PostNSString *urlStr = [NSString stringWithFormat:@&quot;%@&quot;,kVideoURL];NSURL *url = [NSURL URLWithString:urlStr];NSString *parmStr = @&quot;method=album.channel.get&amp;appKey=myKey&amp;format=json&amp;channel=t&amp;pageNo=1&amp;pageSize=10&quot;;NSData *pramData = [parmStr dataUsingEncoding:NSUTF8StringEncoding];// 设置请求体[request setHTTPBody:pramData];// 设置请求方式[request setHTTPMethod:@&quot;POST&quot;];NSData *data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; 异步异步访问网络1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283NSString *urlStr = [NSString stringWithFormat:@&quot;http://image.zcool.com.cn/56/13/1308200901454.jpg&quot;];NSString *newStr = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:newStr];NSURLRequest *requst = [NSURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];//异步链接(形式1,较少用)[NSURLConnection sendAsynchronousRequest:requst queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123;self.imageView.image = [UIImage imageWithData:data];// 解析NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:nil];NSLog(@&quot;%@&quot;, dic);&#125;];// POST请求NSString *urlString = [NSString stringWithFormat:@&quot;%@&quot;,kVideoURL];//创建url对象NSURL *url = [NSURL URLWithString:urlString];//创建请求NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];//创建参数字符串对象NSString *parmStr = [NSString stringWithFormat:@&quot;method=album.channel.get&amp;appKey=myKey&amp;format=json&amp;channel=t&amp;pageNo=1&amp;pageSize=10&quot;];//将字符串转换为NSData对象NSData *data = [parmStr dataUsingEncoding:NSUTF8StringEncoding];[request setHTTPBody:data];[request setHTTPMethod:@&quot;POST&quot;];//创建异步连接（形式二）[NSURLConnection connectionWithRequest:request delegate:self];// 一般的，当创建异步连接时， 很少用到第一种方式，经常使用的是代理方法。关于NSURLConnectionDataDelegate，我们经常使用的协议方法为一下几个：// 服务器接收到请求时- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;&#125;// 当收到服务器返回的数据时触发, 返回的可能是资源片段- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123;&#125;// 当服务器返回所有数据时触发, 数据返回完毕- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123;&#125;// 请求数据失败时触发- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; NSLog(@&quot;%s&quot;, __FUNCTION__);&#125; GET请求和POST请求的区别 GET请求的接口会包含参数部分，参数会作为网址的一部分，服务器地址与参数之间通过 ? 来间隔。POST请求会将服务器地址与参数分开，请求接口中只有服务器地址，而参数会作为请求的一部分，提交后台服务器。 GET请求参数会出现在接口中，不安全。而POST请求相对安全。3.虽然GET请求和POST请求都可以用来请求和提交数据，但是一般的GET多用于从后台请求数据，POST多用于向后台提交数据。 同步和异步的区别 同步链接：主线程去请求数据，当数据请求完毕之前，其他线程一律不响应，会造成程序就假死现象。 异步链接：会单独开一个线程去处理网络请求，主线程依然处于可交互状态,程序运行流畅。","tags":[{"name":"网络请求","slug":"网络请求","permalink":"http://seniorzhai.github.io/tags/网络请求/"},{"name":"POST","slug":"POST","permalink":"http://seniorzhai.github.io/tags/POST/"},{"name":"GET","slug":"GET","permalink":"http://seniorzhai.github.io/tags/GET/"}]},{"title":"Git分支与协作","date":"2014-09-19T08:59:13.000Z","path":"2014/09/19/Git分支与协作/","text":"分支功能是git最为强大的功能之一查看分支：git branch创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout -b name合并某分支到当前分支：git merge name删除分支：git branch -d name 分支管理合并分支时，git默认使用Fast forward模式，这种模式下，删除分支后，会丢弃分支信息。可以使用--no-ff参数禁用，保存分支信息1git merge --no-ff -m &quot;合并信息&quot; dev 查看分支历史1git log --graph --pretty=oneline --abbrev-commit 分支策略master分支应该是非常稳定的，仅用来发布新版本，平时不能再上面干活dev分支时不稳定的，只在某个版本的时候合并到master上干活在dev分支上，每个人在自己的分支上干活，时不时合并就可以 Bug分支在开发中遇到了Bug，急需修复吗，但Dev分支的任务未完成，不能提交，此时可以保存现场(将改动保存，并清空工作空间)123456789101112131415git stash # 保存现场git status # 查看状态，工作区已经干净git checkout master # 切换到主分支git checkoutr -b issue-101 # 创建Bug分支... # 修复Buggit add .git commit -m &quot;fix bug 101&quot;git checkout mastergit merge --no-ff -m &quot;merged bug fix 101&quot; issue-101git branch -d issue-101git checkout devgit stash list # 查看保存内容git stash apply stash@&#123;0&#125; # 恢复到现场git stash drop # 删除现场缓存git stash pop # 恢复并删除 多人协作12git remote # 查看远程库git remote -v # 显示详细信息 推送分支通常只需要推送主分支和dev分支12git push origin mastergit push origin dev 抓取分支12345git clone git@github.com:.... # 克隆git checkout -b dev origin/dev # 创建远程库的dev分支git pull # 抓取git branch --set-upstream dev origin/dev # 指定本地分支和远程分支连接","tags":[{"name":"分支","slug":"分支","permalink":"http://seniorzhai.github.io/tags/分支/"},{"name":"branch","slug":"branch","permalink":"http://seniorzhai.github.io/tags/branch/"},{"name":"git","slug":"git","permalink":"http://seniorzhai.github.io/tags/git/"}]},{"title":"环信SDK(二)","date":"2014-09-19T01:39:50.000Z","path":"2014/09/19/环信SDK(二)/","text":"环信单聊API 登陆123456789101112131415161718EMChatManager.getInstance().login(userName,password,new EMCallBack()&#123; @Override public void onSuccess() &#123; runOnUiTread(new Runnable()&#123; public void run()&#123; // 成功 &#125; &#125;); &#125; @Override public void onProgress(int progress,String status) &#123; &#125; @Override public void onError(int code,String message) &#123; // 失败 &#125;&#125;); 注销1EMChatManager.getInstance().login(); 发送文本消息123456789101112131415// 获取会话EMConversation conversation = EMChatManager.getInstance().getConversation(username);// 创建文本消息EMMessage message = EMMessage.createSendMessage(EMMessage.Type.TXT);// 设置为群聊聊message.setChatType(ChatType.GroupChat);// 设置消息TextMessageBody txtBody = new TextMessageBody(content);message.addBody(txtBody);// 设置接收人message.setReceipt(username);// 把消息加入到会话中conversation.addMessage(message);// 发送消息EMChatManager.getInstance().sendMessage(message,new EMCallBack()); 发送语音消息12345678EMConversation conversation = EMChatManager.getInstance().getConversation(username);EMMessage message = EMMessage.createSendMessage(EMMessage.Type.VOICE);// 设置为群聊VoiceMessageBody body = new VoiceMessageBody(new File(filePath), len);message.addBody(body);message.setReceipt(username);conversation.addMessage(message);EMChatManager.getInstance().sendMessage(message, new EMCallBack()); 发送图片消息1234567891011EMConversation conversation = EMChatManager.getInstance().getConversation(username);EMMessage message = EMMessage.createSendMessage(EMMessage.Type.IMAGE);//如果是群聊，设置chattype,默认是单聊message.setChatType(ChatType.GroupChat);ImageMessageBody body = new ImageMessageBody(new File(filePath));// 默认超过100k的图片会压缩后发给对方，可以设置成发送原图// body.setSendOriginalImage(true);message.addBody(body);message.setReceipt(username);conversation.addMessage(message);EMChatManager.getInstance().sendMessage(message, new EMCallBack()); 发送地理位置消息123456789EMConversation conversation = EMChatManager.getInstance().getConversation(username);EMMessage message = EMMessage.createSendMessage(EMMessage.Type.LOCATION);//如果是群聊，设置chattype,默认是单聊message.setChatType(ChatType.GroupChat);LocationMessageBody locBody = new LocationMessageBody(locationAddress, latitude, longitude);message.addBody(locBody);message.setReceipt(username);conversation.addMessage(message);EMChatManager.getInstance().sendMessage(message, new EMCallBack()); 发送文件消息12345678910111213EMConversation conversation = EMChatManager.getInstance().getConversation(username);// 创建一个文件消息EMMessage message = EMMessage.createSendMessage(EMMessage.Type.FILE);// 如果是群聊，设置chattype,默认是单聊if (chatType == CHATTYPE_GROUP) message.setChatType(ChatType.GroupChat);//设置接收人的usernamemessage.setReceipt(username);// add message bodyNormalFileMessageBody body = new NormalFileMessageBody(new File(filePath));message.addBody(body);conversation.addMessage(message);EMChatManager.getInstance().sendMessage(message, new EMCallBack()); 接收消息123456789101112131415161718192021222324NewMessageBroadcastReceiver msgReceiver = new NewMessageBroadcastReceiver();IntentFilter intentFilter = new IntentFilter(EMChatManager.getInstance().getNewMessageBroadcastAction());intentFilter.setPriority(3);registerReceiver(msgReceiver, intentFilter);private class NewMessageBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //消息id String msgId = intent.getStringExtra(\"msgid\"); //发消息的人的username(userid) String msgFrom = intent.getStringExtra(\"from\"); //消息类型，文本，图片，语音消息等,这里返回的值为msg.type.ordinal()。 //所以消息type实际为是enum类型 int msgType = intent.getIntExtra(\"type\", 0); //消息body，为一个json字符串 String msgBody = intent.getStringExtra(\"body\"); Log.d(\"main\", \"new message id:\" + msgId + \" from:\" + msgFrom + \" type:\" + msgType + \" body:\" + msgBody); //更方便的方法是通过msgId直接获取整个message EMMessage message = EMChatManager.getInstance().getMessage(msgId); &#125;&#125; 获取聊天记录12345678EMConversation conversation = EMChatManager.getInstance().getConversation(username);//获取此会话的所有消息List&lt;EMMessage&gt; messages = conversation.getAllMessages();//sdk初始化加载的聊天记录为20条，到顶时需要去db里获取更多//获取startMsgId之前的pagesize条消息，此方法获取的messages sdk会自动存入到此会话中，app中无需再次把获取到的messages添加到会话中List&lt;EMMessage&gt; messages = conversation.loadMoreMsgFromDB(startMsgId, pagesize);//如果是群聊，调用下面此方法List&lt;EMMessage&gt; messages = conversation.loadMoreGroupMsgFromDB(startMsgId, pagesize); 获取未读消息数量12EMConversation conversation = EMChatManager.getInstance().getConversation(username);conversation.getUnreadMsgCount(); 未读消息清零12EMConversation conversation = EMChatManager.getInstance().getConversation(username);conversation.resetUnsetMsgCount(); 清空会话记录12//清空和某个user的聊天记录，不删除整个会话EMChatManager.getInstance().clearConversation(username); 删除聊天记录12345//删除和某个user的整个的聊天记录EMChatManager.getInstance().deleteConversation(username);//删除当前会话的某条聊天记录EMConversation conversation = EMChatManager.getInstance().getConversation(username);conversation.removeMessage(deleteMsg.msgId); 设置自定义的消息提示App在后台时，新消息会通过notification提示，可以把提示的内容换成自定义的内容，在Application中的onCreate()里设置12345678910111213// 获取到options对象EMChatOptions options = EMChatManager.getInstance().getChatOptions();// 设置自定义的文字提醒options.setNotifyText(new OnMessageNotifyListener() &#123; @Override public String onNewMessageNotify(EMMessage message)&#123; return message.getFrom() + \"发来了一条消息\"; &#125; @Override public String onLatestMessageNotify(EMMessage message,int fromUserNum,int messageNum) &#123; return fromUserNum + \"个好友发来了\" + messgaeNum + \"条消息\"; &#125;&#125;); 设置notification点击跳转的intent1234567891011121314151617EMChatOptions options = EMChatManager.getInstance().getChatOptions();options.setOnNotificationClickListener(new OnNotificationClickListener()&#123; @Override public Intent onNotificationClick(EMMessage message) &#123; Intent intent = new Intent(applicationContext,ChatActivity.class); ChatType chatType = message.getChatType(); if(chatType == ChatType.chat)&#123; intent.putExtra(\"userId\", message.getFrom()); intent.putExtra(\"chatType\", ChatActivity.CHATTYPE_SINGLE); &#125; else &#123; //message.getTo()为群聊id intent.putExtra(\"groupId\", message.getTo()); intent.putExtra(\"chatType\", ChatActivity.CHATTYPE_GROUP); &#125; return intent; &#125;&#125;); 好友列表1List&lt;String&gt; usernames = EMChatManager.getInstance().getContactUesrNames(); 添加好友12//参数为要添加的好友的username和添加理由EMContactManager.getInstance().addContact(toAddUsername, reason); 删除好友1EMContactManager.getInstance().deleteContact(username); 同意好友请求12//同意username的好友请求EMChatManager.getInstance().acceptInvitation(username); 拒绝好友请求1EMChatManager.getInstance().refuseInvitation(username); 监听好友请求12345678910111213141516171819202122232425262728EMContactManager.getInstance().setContactListener(new EMContactListener() &#123; @Override public void onContactAgreed(String username) &#123; //好友请求被同意 &#125; @Override public void onContactRefused(String username) &#123; //好友请求被拒绝 &#125; @Override public void onContactInvited(String username, String reason) &#123; //收到好友邀请 &#125; @Override public void onContactDeleted(List&lt;String&gt; usernameList) &#123; //被删除时回调此方法 &#125; @Override public void onContactAdded(List&lt;String&gt; usernameList) &#123; //增加了联系人时回调此方法 &#125;&#125;); 获取黑名单12//获取黑名单用户的usernamesEMContactManager.getInstance().getBlackListUsernames(); 加入黑名单123//第二个参数如果为true，则把用户加入到黑名单后双方发消息时对方都收不到；false,则//我能给黑名单的中用户发消息，但是对方发给我时我是收不到的EMContactManager.getInstance().addUserToBlackList(username,true); 从黑名单中移除1EMContactManager.getInstance().deleteUserFromBlackList(username); 网络异常监听1234567891011121314151617181920212223242526272829303132333435363738//注册一个监听连接状态的listenerEMChatManager.getInstance().addConnectionListener(new MyConnectionListener());//实现ConnectionListener接口private class MyConnectionListener implements ConnectionListener&#123; @Override public void onConnected() &#123; &#125; @Override public void onDisConnected(String errorString) &#123; if(errorString!=null&amp;&amp;errorString.contains(\"conflict\")) &#123; //收到帐号在其他手机登录 // TODO &#125;else&#123; //\"连接不到聊天服务器\" &#125; &#125; @Override public void onReConnected() &#123; &#125; @Override public void onReConnecting() &#123; &#125; @Override public void onConnecting(String progress) &#123; &#125; &#125;","tags":[{"name":"SDK","slug":"SDK","permalink":"http://seniorzhai.github.io/tags/SDK/"},{"name":"IM","slug":"IM","permalink":"http://seniorzhai.github.io/tags/IM/"},{"name":"环信","slug":"环信","permalink":"http://seniorzhai.github.io/tags/环信/"}]},{"title":"环信SDK(一)","date":"2014-09-18T09:17:32.000Z","path":"2014/09/18/环信SDK(一)/","text":"环信提供了一套IM SDK，可以很方便的在App中集成IM功能 添加权限和App Key1234567891011121314151617&lt;!-- 权限 --&gt;&lt;uses-permission android:name=\"android.permission.VIBRATE\" /&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt; &lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt; &lt;uses-permission android:name=\"android.permission.GET_TASKS\" /&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; &lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;&lt;!-- App Key --&gt;&lt;meta-data android:name=\"EASEMOB_APPKEY\" android:value=\"xxxx# mychatdemo\" /&gt; 初始化在自定义的Application中初始化，确保应用程序一开始就得到运行1234567891011121314public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); EMChat.getInstance().init(this); EMChatOptions options = EMChatManager.getInstance().getChatOptions(); options.setAcceptInvitationAlways(false); // 设置添加好友时，默认不需要验证，改为需要验证 options.setNotificationEnable(flase); // 设置收到消息是否有新消息通知，默认是true options.setNoticeBySound(false); // 设置接收到消息是否声音通知，默认是true options.setNoticedByVibrate(false); // 设置接收到消息是否震动，默认是true options.setUseSpeaker(false); // 设置语音消息播放是否为扬声器播放，默认是true &#125;&#125; 注册12String appkey = EMChatConfig.getInstance().APPKEY;EMChatManager.getInstance().createAccountOnServer(appkey + \"_\" + username, pwd); //注意用户名不能有大写字母 登陆1234567891011121314EMChatManager.getInstance().login(username,password,new EMCallBack() &#123; @Override public void onSuccess() &#123; &#125; @Override public void onProgress(int progress,String status) &#123; &#125; @Override public void onError(int code,String message) &#123; &#125;&#125;); 监听消息接收聊天消息，回执消息，好友同意，好友请求等 聊天信息 1234msgReceiver = new NewMessageBroadcastReceiver();IntentFilter intentFilter = new IntentFilter(EMChatManager.getInstance().getNewMessageBroadcastReceiver());intentFilter.setPriorty(3);registerReceiver(msgReceiver,intentFilter); 回执消息 123IntentFilter ackMessageIntentFilter = new IntentFilter(EMChatManager.getInstance().getAckMessageBroadcastAction());ackMessageIntentFilter.setPriority(3);registerReceiver(ackMessageReceiver, ackMessageIntentFilter); 好友同意、好友请求 12IntentFilter inviteIntentFilter = new IntentFilter(EMChatManager.getInstance().getContactInviteEventBroadcastAction());registerReceiver(contactInviteReceiver, inviteIntentFilter); 联系人变化 1EMContactManager.getInstance().setContactListener(new MyContactListener()); 连接状态 1EMChatManager.getInstance().addConnectionListener(new MyConnectionListener()); 发送消息123456789101112// 创建一个消息EMMessage msg = EMMessage.createSendMessage(EMMessage.Type.TXT);// 设置消息的接受方msg.setReceipt(username);TextMessageBody body = new TextMessageBody(tvMsg.getText().toString());msg.addBody(body);try &#123; //发送消息 EMChatManager.getInstance().sendMessage(msg);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 接收消息12345678910111213private class NewMessageBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //消息id String msgId = intent.getStringExtra(\"msgid\"); ...... ...... ...... //注销广播，否则在ChatActivity中会收到这个广播 abortBroadcast(); &#125;&#125; 消息回执123456789101112private BroadcastReceiver ackMessageReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; //消息id String msgId = intent.getStringExtra(\"msgid\"); ...... ...... ...... abortBroadcast(); &#125;&#125;; 联系人变化12345678private class MyContactListener implements EMContactListener&#123; @Override public void onContactAdded(List&lt;String&gt; usernameList) &#123; &#125; @Override public void onContactDeleted(List&lt;String&gt; usernameList) &#123; &#125;&#125; 连接状态123456789101112131415161718192021222324private class MyConnectionListener implements ConnectionListener&#123; @Override public void onConnected() &#123; &#125; @Override public void onDisConnected(String errorString) &#123; if(errorString!=null&amp;&amp;errorString.contains(\"conflict\")) &#123; //收到帐号在其他手机登录 // TODO &#125;else&#123; //\"连接不到聊天服务器\" &#125; &#125; @Override public void onReConnected() &#123; &#125; @Override public void onReConnecting() &#123; &#125; @Override public void onConnecting(String progress) &#123; &#125;&#125; 退出登陆123456@Overrideprotected void onPause() &#123; super.onPause(); //登出聊天服务器 EMChatManager.getInstance().logout();&#125; 设置昵称1EMChatManager.getInstance().updateCurrentUserNick(nickname); 例子ChatDemo","tags":[{"name":"SDK","slug":"SDK","permalink":"http://seniorzhai.github.io/tags/SDK/"},{"name":"IM","slug":"IM","permalink":"http://seniorzhai.github.io/tags/IM/"},{"name":"环信","slug":"环信","permalink":"http://seniorzhai.github.io/tags/环信/"}]},{"title":"IntentService","date":"2014-09-17T07:22:47.000Z","path":"2014/09/17/IntentService/","text":"IntentService是简单后台任务操作的理想选择。 不可以直接和UI做交互，为了显示他执行的结果，需要发送给Activity 工作任务队列是顺序执行的，如果一个任务正在IntentService中执行，此时发送的请求，会等到上一个任务执行完毕 正在执行的任务无法打断创建IntentService定义一个类继承IntentService1234567public class RSSPullService extends IntentService &#123; @Ovrride protected void onHandleIntent(Intent workIntent) &#123; String dataString = workIntent.getDataString(); // ... &#125;&#125; 注：在IntentService中要避免重载onStartCommand()等回调方法 在Manifest文件中定义IntentService123456789&lt;application android:icon=\"@drawable/icon\" android:label=\"@string/app_name\"&gt; ... &lt;service android:name=\".RSSPullService\" android:exported=\"false\"/&gt; ...&lt;application/&gt; 发送任务到IntentService可以在Activity或者Fragment的任何时间点执行Intent，触发IntentService执行任务12345// 创建一个显式的Intent来启动IntentServicemServiceIntent = new Intent(getActivity(),RSSPullService.class);mServiceIetent.setData(Uri.parse(dataUrl));// 执行getActivity().startService(mServiceIntent); 一旦执行了startSevice()，IntentService在自己本身onHandleIntent()方法里面开始执行任务 报告后台执行状态推荐使用LocalBroadcastManager(只在自己的App中执行传递的Brocadcast)123456789public final class Constans &#123; public static final String BROADCAST_ACTION = \"com.example.android.threadsample.BROADCAST\"; public static final String EXTENDED_DATA_STATUS = \"com.example.android.threadsamlpe.STATUS\";&#125;public class RSSPullService extends IntentService &#123; ... Intent localIntent = new Intent(Constans.BROADCAST_ACTION).putExtra(Constans.EXTENDED_DATA_STATUS,status); LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent);&#125; 接收数据123456789private class ResponseReceiver extends BroadcastReceiver &#123; private DownloadStateReceiver() &#123; &#125; @Ovrride public void onReceive(Context context,Intent intent) &#123; // &#125;&#125; 1234567public class DisplayActivity extends FragmentActivity &#123; public void onCreate(Bundle stateBundle) &#123; super.onCreate(stateBundle); IntentFilter mStatesIntentFilter = new IntentFilter(Constants.BROADCAST_ACTION); mStatusIntentFilter.addDataScheme(\"http\"); &#125;&#125;","tags":[{"name":"IntentService","slug":"IntentService","permalink":"http://seniorzhai.github.io/tags/IntentService/"}]},{"title":"我眼中的REST客户端(二)","date":"2014-09-17T03:13:59.000Z","path":"2014/09/17/我眼中的REST客户端(二)/","text":"通过一个示例项目，了解如何实现REST客户端 界面实现根据原型设计(上图)最后实现的效果如下： activity_mian.xml 主界面 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/content_frame\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; &lt;FrameLayout android:id=\"@+id/left_drawer\" android:layout_width=\"175dip\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:choiceMode=\"singleChoice\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; fragment_drawer.xml 左侧菜单项 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ListView xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/listView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"# e6000000\" android:choiceMode=\"singleChoice\" android:divider=\"@android:color/transparent\" android:dividerHeight=\"0dp\" android:orientation=\"vertical\" android:paddingTop=\"20dip\" /&gt; fragment_feed.xml 内容显示fragment 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/swipe_refresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;com.zoe.qsbk.view.PulltoRefreshListView android:id=\"@+id/listView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:choiceMode=\"singleChoice\" android:divider=\"@android:color/transparent\" android:dividerHeight=\"15dip\" android:drawSelectorOnTop=\"true\" android:fastScrollEnabled=\"true\" android:footerDividersEnabled=\"true\" android:headerDividersEnabled=\"true\" android:paddingLeft=\"15dip\" android:paddingRight=\"15dip\" android:scrollbarStyle=\"outsideOverlay\" android:scrollingCache=\"true\" android:smoothScrollbar=\"true\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt;","tags":[{"name":"REST","slug":"REST","permalink":"http://seniorzhai.github.io/tags/REST/"}]},{"title":"BroadCastReceiver","date":"2014-09-16T07:22:30.000Z","path":"2014/09/16/BroadCastReceiver/","text":"在Android中，Broadcast是一种广泛运用在应用程序之间传输信息的机制，而BroadcastReceiver是对发送出来的Broadcast进行过滤接收并响应的一类组件 注册BroadcastReceiver在AndroidManifest.xml中用标签注册 静态注册过滤器 12345&lt;receiver android:name=\"myRecevice\"&gt; &lt;intent-filer&gt; &lt;action android:name=\"com.zoe.net\"/&gt; &lt;/intent-filer&gt;&lt;/receiver&gt; 动态注册过滤器 123IntentFilter intentFilter = new IntentFilter();intentFilter.addAction(String);registerReceiver(BroadcastReceiver,intentFilter); // 在BroadCastReceiver的onStart中注册，onStop中unregiterReceiver 触发BroadcastReceiver123Intent intent = new Intent(\"com.zoe.net\");intent.putExtra(\"msg\",\"发送消息\");Content.sendBroadcast(intent); 接受到广播消息后会执行onReceive()方法12345678910111213@Override public void onReceive(Context context,Intent intent) &#123; String msg = intent.getStringExtra(\"msg\"); int id = intent.getIntExtra(\"who\",0); if(intent.getAction().equals(\"com.zoe.sendMsg\")) &#123; mn = (NotificationManage)context.getSystemService(Context.NOTIFICATION_SERViCE); notification = new Notification(R.drawable.icon,id+\"发送广播\",System.currentTimeMillis()); Intent it = new Intent(context,Main.class); PendIntent contentIntent = PenIntent.getActivity(context,0,it,0); notification.sendLatesEventInfo(context,\"msg\",\"msg\",contentIntent); mn.notify(0,notification); &#125;&#125;","tags":[{"name":"Broadcast","slug":"Broadcast","permalink":"http://seniorzhai.github.io/tags/Broadcast/"}]},{"title":"我眼中的REST客户端(一)","date":"2014-09-15T08:18:47.000Z","path":"2014/09/15/我眼中的REST客户端(一)/","text":"REST架构是Google I/O 2013年提出大致的模型如下图所示 应用架构Activity复制初始化LoaderManager(加载管理器)和内容加载进程，加载管理器接收ContentProvider的变更通知从而通知Adapter修改ListView的内容。大致分为： 显示部分 加载后台 服务器 网络通信原始的HttpClient开发成本高，且稳定性、安全性、实用性并不高，最高使用先进的网络访问库 Volley Google官方于2013年I/O大会发布 AsyncHttpClient SonaType的一个开源库，移植到Android平台需要进行一些定制 Retrofit 专注于网络请求和数据解析 数据解析Android默认使用JsonObject来解析数据，处理方式比较远(ma)古(fan)，下面的一些开源库可以帮助快速、安全的解析Json数据 Gson Google官方出品，速度快，解析方便 Jackson 小有名气，但是导入的包相对多 Fastjson 阿里主导的开源项目，每个属性都必须具备getter/setter方法 数据存储ContentProvider原本用于跨进程、夸应用的数据访问，提供了清晰的接口来访问数据库，而且可以使用CursorLoader。CursorLoader是目前Activity和Fragment中异步读取ContentProvider的最佳方案。CursorLoader会接到数据变更的通知，可以保证Cursor的数据始终与数据库同步。","tags":[{"name":"REST","slug":"REST","permalink":"http://seniorzhai.github.io/tags/REST/"}]},{"title":"Android生命周期函数","date":"2014-09-15T06:26:01.000Z","path":"2014/09/15/Android生命周期中的小众函数/","text":"onContentChanged不算小众，当Activity的布局改动时，即setContentView()或者addContentView()方法执行完毕时调用该方法，View的findViewById()方法可以放在该方法中。 onPostCreate、onPostResumeonPostCreate方法当onCreate方法彻底执行完毕时回调，onPostResume当onResume方法执行完毕回调。一般不修改，在使用ActionBarDrawerToggle的使用在onPostCreate需要屏幕旋转的时候同步状态12345@Overrideprotected void onPostCreate(Bundle savedInstanceState) &#123; super.onPostCreate(savedInstanceState); mDrawerToggle.syncState();&#125; onPause、onStoponPause为失去焦点时调用，onStop则是整个窗口被完全遮盖时才会被触发 完整生命周期为onCreate方法会在第一次创建被执行，接着执行onState方法，也么被完全遮盖会调用onStop方法，返回的时候执行onRestart-&gt;onStart方法，结束Activity时执行onDestroyonCreate -&gt; onContentChanged -&gt; onState -&gt; onPostCreate -&gt; onResume -&gt; onPostResume -&gt; onPause -&gt; onStop -&gt; onDestroy","tags":[{"name":"生命周期","slug":"生命周期","permalink":"http://seniorzhai.github.io/tags/生命周期/"}]},{"title":"JumpingBeans","date":"2014-09-11T04:38:59.000Z","path":"2014/09/11/JumpingBeans/","text":"一个可爱向的自定义控件 使用 将JumpingBeans导入项目，因为使用了ValueAnimator，所以默认使用Android Api 11+。也已可以使用NineOldAndroids 设置TextView动画1234567891011// Append jumping dotsfinal TextView textView1 = (TextView) findViewById(R.id.jumping_text_1);jumpingBeans1 = new JumpingBeans.Builder() .appendJumpingDots(textView1) .build();// Make the first word's letters jumpfinal TextView textView2 = (TextView) findViewById(R.id.jumping_text_2);jumpingBeans2 = new JumpingBeans.Builder() .makeTextJump(textView2, 0, textView2.getText().toString().indexOf(' ')) .build(); 其他Api setIsWave(false) 可以使跳动对象整个一起跳动 setLoopDuration(int) 可以设置动画的时间 setWavePerCharDaley(int) 单个动画之间的延迟 setAnimatedDutyCycle(float) 动画之间的暂停时间","tags":[{"name":"TextView","slug":"TextView","permalink":"http://seniorzhai.github.io/tags/TextView/"},{"name":"自定义控件","slug":"自定义控件","permalink":"http://seniorzhai.github.io/tags/自定义控件/"}]},{"title":"App设计速查表","date":"2014-09-11T02:59:07.000Z","path":"2014/09/11/App设计速查表/","text":"应用设计速查表 Android iOS","tags":[{"name":"app","slug":"app","permalink":"http://seniorzhai.github.io/tags/app/"},{"name":"设计","slug":"设计","permalink":"http://seniorzhai.github.io/tags/设计/"}]},{"title":"SharedPreferce最佳实践","date":"2014-09-11T00:54:08.000Z","path":"2014/09/11/SharedPreferce最佳实践/","text":"SharedPreferce作为Android提供的一种保存数据的解决方案，用于保存键值对形式的数据。一本用于存放应用设置，用户数据等。常用的类包括 SharedPreferces 获取建立存储数据 SharedPreferces.Editor 对数据编辑的接口 SharedPreferces.OnSharedPreferenChangeListener 数据变化的监听器SharedPreferces主要用于创建SharedPreferences对象，通过SharedPreference获取数据。常用API有：1234567// 根据名字创建SharedPreferences preferences = context.getSharedPreferences(\"shared_name\",Context.Mode_PRIVATE);// 获取变量preferences.getBoolean(\"key\",defaultValue);prrferences.get...(\"key\",defaultValue);// 获取整个键值MapMap&lt;String,?&gt; all = preferences.getAll(); EditorSharedPreferences.Editor是用于修改SharedPreferences对象的接口，且Editor做出的修改默认是待处理的，需要使用commit()或者apply()提交修改。 commit()会更快一点常用的Api有：12345678910111213// 获取Editor对象SharedPreferences.Editor editor = preferences.edit();// 添加数据editor.putBoolean(\"key\",value);editor.put...(\"key\",value);// 删除数据editor.remove(\"key\");// 清空数据editor.clear();// 提交数据，返回是否成功booleanresult = editor.commit();// 提交数据，与commit相同，但属于异步操作，无返回值editor.apply(); SharedPreferenChangeListener用于监听SharedPreferences的数据改变，常用API有1234567891011// 注册监听器preferences.registerOnSharedPreferenceChangeListener(mListener);// 注销监听器preferences.unregisterOnSharedPreferenceChangeListener(mListener);// 监听器SharedPreferences.OnSharedPreferenceChangeListener mOnSharedPreferenceChangeListener = new SharedPreferences.OnSharedPreferenceChangeListener() &#123; @Override public void onSharedPreferenceChanged(SharedPreferces sharedPreferences,String key)&#123; // 实现监听 &#125; &#125;; 性能 ShredPreferences是单例对象，第一次打开后，之后获取都无需创建，速度很快。 当第一次获取数据后，数据会被加载到一个缓存的Map中，之后的读取都会非常快。 当由于是XML&lt;-&gt;Map的存储方式，所以，数据越大，操作越慢，get、commit、apply、remove、clear都会受影响，所以尽量把数据按功能拆分成若干份。 App更新后，Preferences不会被移除，在默写情况下，需要创建迁移数据的方案12345678910111213141516171819public class MigrationManager &#123; private final static String KEY_PREDERENCES_VERSION = \"key_preferences_version\"; private final static int PREFERENCES_VERSION = 2; public static void migrate(Context context) &#123; SharedPreferences preferences = context.getSharedPreferences(\"pref\",Context.MODE_PRIVATE); checkPreferences(preferences); &#125; // 根据当前App的Preferences版本号，判断是否更新SharedPreferences private static void checkPreferences(SharedPreferences thePreferences) &#123; final int oldVersion = thePreferences.getInt(KEY_PREFERENCES_VERSION,1); if(oldVersion &lt; PREFERENCES_VERSION) &#123; final SharedPreferences.Editor edit = thePreferences.edit(); edit.clear(); edit.putInt(KEY_PREFERENCES_VERSION, currentVersion); edit.commit(); &#125; &#125;&#125; 存放位置 /data/data/YOUR_PACKAGE_NAME/shared_prefs/YOUR_PREFS_NAME.xml /data/data/YOUR_PACKAGE_NAME/shared_prefs/YOUR_PACKAGE_NAME_preferences.xml示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class PreferencesManager &#123; private static final String PREF_NAME = \"com.example.app.PREF_NAME\"; private static final String KEY_VALUE = \"com.example.app.KEY_VALUE\"; private static PreferencesManager sInstance; private final SharedPreferences mPref; private PreferencesManager(Context context) &#123; mPref = context.getSharedPreferences(PREF_NAME, Context.MODE_PRIVATE); &#125; public static synchronized void initializeInstance(Context context) &#123; if (sInstance == null) &#123; sInstance = new PreferencesManager(context); &#125; &#125; public static synchronized PreferencesManager getInstance() &#123; if (sInstance == null) &#123; throw new IllegalStateException(PreferencesManager.class.getSimpleName() + \" is not initialized, call initializeInstance(..) method first.\"); &#125; return sInstance; &#125; public void setValue(long value) &#123; mPref.edit() .putLong(KEY_VALUE, value) .commit(); &#125; public long getValue() &#123; return mPref.getLong(KEY_VALUE, 0); &#125; public void remove(String key) &#123; mPref.edit() .remove(key) .commit(); &#125; public boolean clear() &#123; return mPref.edit() .clear() .commit(); &#125;&#125;","tags":[{"name":"SharedPreferce","slug":"SharedPreferce","permalink":"http://seniorzhai.github.io/tags/SharedPreferce/"}]},{"title":"Gson解析Json","date":"2014-09-10T07:18:50.000Z","path":"2014/09/10/Gson解析Json/","text":"Gson是Google提供的一个很棒的json解析库。 解析单个对象比如有个一个Person类1234public class Person&#123; public int age; public String name;&#125; 解析时12String json = \"...\"; //json字符串Person person = new Gson().fromJson(json,Person.class); 如果Person中还有一个Date的birth属性12345public class Person&#123; public int age; public String name; public Date birth;&#125; 解析时设定格式12345String json = \"...\"; GsonBuilder gsonBuilder = new GsonBuilder();gsonBuilder.setDateFormat(\"yyyy-MM-dd HH:mm:ss\");Gson gson = gsonBuilder.create();Person person = gson.fromJson(json,Person.class); 命名gson默认需要类的属性名与JSON对应，但也可以通过@SerializeName来修改1234public class Feed &#123; @SerializeName(\"birth\"); public Date birthDay;&#125; 对象的嵌套比如返回如下的数据12345678&#123; \"id\":100, \"name\":\"zoe\" \"sub\":&#123; \"id\":200, \"name\":\"zhai\" &#125;&#125; 对应的对象应该是`12345678910public class Feed &#123; public int id; public String name; public Sub sub; public class Sub&#123; public int id; public String name; &#125;&#125; 对象数组形如下面的对象数组12345678910[&#123; &quot;id&quot;:100, &quot;name&quot;:&quot;name100&quot;&#125;,&#123; &quot;id&quot;:101, &quot;name&quot;:&quot;name101&quot;&#125; //...] 解析方法有两种： 解析成数组 123Sub[] subs = new Gson().fromJson(json,Sub[].class);//转ListList&lt;Sub&gt; subs = Arrays.asList(subs); 解析成List 12Type listType = new TypeToken&lt;ArrayList&lt;Sub&gt;&gt;()&#123;&#125;.getType();ArrayList&lt;Sub&gt; subs = new Gson().fromJson(json,listType);","tags":[{"name":"Gson","slug":"Gson","permalink":"http://seniorzhai.github.io/tags/Gson/"},{"name":"Json","slug":"Json","permalink":"http://seniorzhai.github.io/tags/Json/"}]},{"title":"颜色搭配","date":"2014-09-10T02:06:20.000Z","path":"2014/09/10/颜色搭配/","text":"一些颜色搭配 城市之光 - # 009EFC - # 00B8FB - # 0CD3FA - # F6EEE3 - # F94B42 软软棉花糖 - # 0092C7 - # 9FE0F6 - # F3E59A - # F3B59B - # F29C9C 小小的浪漫 - # 7B7C98 - # 9CB3A9 - # F3C1AA - # E29287 - # E6404E 夏日嬷嬷茶 - # F3FFE4 - # E8B551 - # FF6965 - # C7B7E8 - # CCFAFF 冰淇淋之梦 - # 92CCCA - # 41C2C2 - # BEBB8F - # D3CFA3 - # EBE6AF 深海奇景 - # 0067A6 - # 00ABD8 - # 008972 - # EFC028 - # F2572D","tags":[{"name":"颜色","slug":"颜色","permalink":"http://seniorzhai.github.io/tags/颜色/"},{"name":"color","slug":"color","permalink":"http://seniorzhai.github.io/tags/color/"}]},{"title":"DiskLruCache硬盘缓存","date":"2014-09-09T05:41:48.000Z","path":"2014/09/09/DiskLruCache硬盘缓存/","text":"DiskLruCache是一套非Google官方编写，但是获得官方认证的硬盘缓存解决方案。通常情况下，应用程序的缓存位置为/sdcard/Android/data/&lt;application package&gt;/cache这个路径。当程序被卸载时，此次的数据也会被一并清除。 打开缓存创建一个DiskLruCache的实例需要调用它的open()方法，接口如下1public static DiskLruCache open(File directory,int appVersion,int valueCount,long maxSize) 第一个参数为缓存路径，第二个参数为当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件(基本使用1)，第四个参数指定最多可以缓存多少字节的数据。定义一个方法来获取缓存地址，当SD卡不存在或者SD卡不可被移除的时候，获取内部缓存地址/data/data/&lt;application package&gt;/cache。uniqueName是来指定不同数据的。123456789public File getDiskCacheDir(Context context,String uniqueName)&#123; String cachePath; if(Evrionment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemoveable()) &#123; cachePath = context.getExternalCacheDir().getPath(); &#125; else &#123; cachePath = context.getCacheDir().getPath(); &#125; return new File(cachePath + File.separator + uniqueName);&#125; 获取当前应用程序版本号的方法123456789public int getAppVersion(Context context)&#123; try&#123; PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(),0); return info.versionCode; &#125; catch (NameNotFoundException e) &#123; e.printStackTrace(); &#125; return 1;&#125; 注：每当版本号改变，缓存路径下存储的所有数据都会被清除掉。打开DiskLruCache的方法则为：12345678910DiskLruCache mDiskLruCache = null;try &#123; File cacheDir = getDiskCacheDir(context,\"bitmap\"); if (!cacheDir.exists()) &#123; cacheDir.mkdirs(); &#125; mDiskLruCache = DiskLruCache.open(cacheDir,getAppVersion(context),1,10*1024*1024);&#125;catch(IOException e)&#123; e.printStackTrace();&#125; 写入缓存比如写入一张图片，下载图片的方法123456789101112131415161718192021222324252627282930313233private boolean downloadUrlToStream(String urlString,OutputStream outputStream) &#123; HttpURLConnection urlConnection = null; BufferedOutputStream out = null; BufferedInputStream in = null; try&#123; final URL url = new URL(urlString); urlConnection = (HttpURLConection)url.openConnection(); in = new BufferedInputStream(urlConnection.getInputStream(),8*1024); out = new BufferedOutputStream(outputStream,8*1024); int b; while((b = in.read()) != -1) &#123; out.write(b); &#125; return true; &#125; catch (final IOException) &#123; e.printStackTrace(); &#125; finally &#123; if(urlConnection != null) &#123; urlConnection.disconnect(); &#125; try&#123; if(out != null)&#123; out.close(); &#125; if(in != null)&#123; in.close(); &#125; &#125; catch(final IOException e) &#123; e.printStackTrace(); &#125; &#125; return false;&#125; 写入的操作需要借助DiskLruCache.Editor这个类来完成，获取方法如下1public Editor edit(String key) throws IOException 参数key为缓存文件的文件名，为了使缓存的文件与URL一一对应，可以将URL进行MD5编码，编码后的字符串一定是唯一的。123456789101112131415161718192021public String hashKeyForDisk(String key)&#123; String cacheKey; try&#123; final MessageDigest mDigest = MessageDigest.getInstance(\"MD5\"); mDigest.update(key.getBytes()); cacheKey = bytesToHexString(mDigest.digest()); &#125; catch (NoSuchAlgorithmException e) &#123; cacheKey = String.valueOf(key.hashCode()); &#125; return cacheKey;&#125;private String bytesToHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; bytes.lengeh ; i++ ) &#123; String hex = Integer.toHexString(0xFF &amp; bytes[i]); if(hex.length() == 1)&#123; sb.append('0'); &#125; &#125; return sb.toString();&#125; 获取Editor实例123String imagUrl = \"https://octodex.github.com/grinchtocat\";String key = hashKeyForDisk(imageUrl);DiskLruCache.Editor editor = mDiskLruCache.edit(key); 有了DiskLruCache.Editor实例后，可以调用newOutputStream()方法来创建一个输出流，传入到downloadUrlToStream()中实现下载写入的功能。注意，在写入操作完成之后，需要调用commit()方法提交才能生效，调用abort()方法表示放弃此次写入123456789101112131415161718192021new Thread(new Runnable()&#123; @Override public void run()&#123; try&#123; String imagUrl = &quot;https://octodex.github.com/grinchtocat&quot;; String key = hashKeyForDisk(imageUrl); DiskLruCache.Editor editor = mDiskLruCache.edit(key); if(editor != null)&#123; OutputStream outputStream = editor.newOutputStream(0); //设置了valueCount为1，index传0就可以了 if(downloadUrlToStream(imageUrl,outStream)) &#123; editor.commit(); &#125; else &#123; editor.abort(); &#125; &#125; mDiskLruCache.flush(); &#125; catch(IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;).start(); 读取缓存借助DiskLruCache的get方法可以获取缓存1public synchronized Snapshot get(String key)throws IOException 返回Snapshot对象，只需要getInputStream()方法就可以得到缓存文件的输入流123456789101112try&#123; String imagUrl = \"https://octodex.github.com/grinchtocat\"; String key = hashKeyForDisk(imageUrl); DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key); if (snapShot != null) &#123; InputStream is = snapShot.getInputStream(0); Bitmap bitmap = BitmapFactory.decodeStream(is); mImage.setImageBitmap(bitmap); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 移除缓存通过DiskLruCache的remove()方法实现1public synchronized boolean remove(String key) throws IOException remove需要传入key1234567try&#123; String imagUrl = \"https://octodex.github.com/grinchtocat\"; String key = hashKeyForDisk(imageUrl); mDiskLruCache.remove(key);&#125;catch(IOException e)&#123; e.printStackTrace();&#125; 其他API size()返回当前缓存路径下所有缓存数据的总字节数，以byte为单位 flush()将内存中操作记录同步到日志文件(journal文件)当中，DiskLruCache的正常工作的前提就需要journal文件中的内容，最好在Activity的onPause()方法中调用flush()方法。 close()关闭DiskLruCache和open方法对应。关闭后不能再调用DiskLruCache中任何操作缓存方法，通常在Activity的onDestroy()方法中调用 delete()将所有DiskLruCache的缓存数据删除","tags":[{"name":"cache","slug":"cache","permalink":"http://seniorzhai.github.io/tags/cache/"},{"name":"硬盘缓存","slug":"硬盘缓存","permalink":"http://seniorzhai.github.io/tags/硬盘缓存/"}]},{"title":"Android、iOS大不同(七)","date":"2014-09-07T11:20:13.000Z","path":"2014/09/07/Android、iOS大不同(七)/","text":"项目的文件结构上Android和iOS有很大的区别，注意点是iOS项目的文件是逻辑文件(并不一定和实际存放位置相同) iOS项目文件结构├ *** 项目文件夹 ├ *.m *.h 项目的代码源文件 └ Supporting Files 资源文件夹，包含非源代码和资源文件 ├ ***.plist 属性列表文件，保存iOS应用的各种相关信息 ├ Info.strings 保存各种字符串的文本文件，主要用于程序国际化提供支持 ├ main.m 包含main函数，应用程序的入口 └ ***-Prefix.pch 来自外部框架的头文件，是预编译的头文件。 ├ ***Tests 包含单元测试的相关类和资源 ├ Frameworks 项目依赖的框架或库，也可以包含图像和声音等资源 └ Products 包含项目所生成的应用程序 Android项目文件结构├ *** ├ src 存放代码源文件 ├ lib 库文件 ├ res 资源文件 ├ values 存放字符串、颜色、尺寸等资源文件 ├ layout 布局资源文件 └ drawable 图片资源文件，可以是真实的图片，也可以是xml格式的配置图片 └ AndroidManifest.xml 系统清单文件，控制Android应用的各项配置","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Android、iOS大不同(六)","date":"2014-09-06T01:32:06.000Z","path":"2014/09/06/Android、iOS大不同(六)/","text":"协议或者接口，用于多个类应该遵守的规范。不需要提供实现，不关心内部的状态数据，体现了规范和实现分离的设计哲学。 接口在Java中实现此类设计的方法用接口(interface)123456// 接口的定义[修饰符] interface 接口名 extends 父接口1,父接口2...&#123; 零到多个常量定义... 零到多个抽象方法定义...&#125; 修饰符采用public或缺省，即采用包权限或者外部权限 接口的命名与类相同 一个接口可以有多个直接父类，但接口只能继承接口 在接口中定义的变量默认会被加上static和final成为静态常量，切所有的常量、方法、内部类、枚举类都是public权限 123456public interface Output&#123; int MAX_CACHE = 50; void out(); void getDate(String msg);&#125; 协议在Objective-C中使用协议(protocol)实现该设计需求1234@protocol 协议名 &lt;父协议1,父协议2...&gt;&#123; 零到多个方法定义&#125; 命名规则与类相同 一个协议可以继承多个父协议，但是不能继承类 协议定义的方法不能有方法实现，即可以使类方法，也可以使实例方法123@protocol Output- (void)out;- (void)getDate(NSString* msg); Obejctive-C可以指定关键字@optional、@required限定实现类是否必须实现该方法12345@protocol Output@optional- (void) output;@required- (void) getDate (NSString*) msg;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Android、iOS大不同(五)","date":"2014-09-05T15:01:31.000Z","path":"2014/09/05/Android、iOS大不同(五)/","text":"Objective-C特殊的键指编码(KOC)与监值兼听(KVO) 键值编码(KVC)简直编码用来简化设置对象的属性的方法最基本的KVC由NSKeyValueCode协议提供，最基本的操作属性的方法如下 setValue:value forKey:key 通过属性名来设置值 valueForKey 通过属性名来获取属性值在KVC中，调用以上方法存取属性值时，底层的机制如下： 优先使用setter、getter方法实现 不能实现，则搜索_value属性 不存在，则搜索value属性 都没找到，执行对象的setValue:forUndefinedKey:方法，或者valueforUndefinedKey:方法 默认的setValue:forUndefineKey:方法和valueforUndefinedKey:方法会引发一个异常，这个异常会导致程序因为异常结束 123456789101112@interface Person : NSObject&#123; NSString* name; NSDate* birth; int age;&#125;//mainPerson person = [[Person alloc] init];Í[person setValue:@&quot;Zoe&quot; forKey:@&quot;name&quot;];[person setValue:1 forKey:@&quot;age&quot;];[person setValue:[[NSDate alloc] init] forKey:@&quot;birth&quot;]; 类中存在复合属性，就必须使用Key路径找到属性 setValue: forKeyPath: 根据Key路径设置属性值 valueForKeyPath: 根据Key路径获取属性值123456789@interface Order : NSObject@property(nonatomic,strong) Item* item;@property(nonatomic,strong) NSString* amout;@end//Order* order = [[Order alloc] init];[order setValue:[[Item alloc] init] forKey:@&quot;item&quot;];[order setValue:@&quot;Zoe&quot; forKeyPath:@&quot;item.name&quot;]; 键值监听(KVO)键值监听(Key Value Observing)机制由NSKeyValueObserving协议提供支持，NSObject遵守了该协议。该协议包含如下常用方法可用于注册静听器： addObserver:forKeyPath:optioncontext: 注册一个监听器用于监听指定的key路径 removeObserver:forKeyPath: 为key路径删除指定的监听器 removeObserver:forKeyPath:context: 为key路径删除指定的监听器，只是多一个context参数在MVC模型中，很容易想到让View来监听数据Model的改变，作为监听的视图组建需要重写observeValueForKeyPath:ofObject:context:方法，还方法可以得到最新修改的数据。KVO编程的步骤应该为： 为被监听对象注册监听器 重写监听器的observeValueForKeyPath:ofObject:change:context:方法12345678910111213141516171819202122232425@interface ItemView : NSObject@property(nonatomic,weak) Item* item;@end//@implementation ItemView@synthesize item = _item;- (void)setItem:(Item *)item &#123; self-&gt;_item = item; [self.item addObserver:self forKeyPath:@&quot;name&quot; option:NSKeyValueObservingOptionNew context:nil]; [self.item addObserver:self forKeyPath:@&quot;price&quot; option:NSKeyValueObservingOptionNew context:nil];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object chang:(NSDictionary *)change context:(void *)context&#123; NSLog(@&quot;被修改的KeyPath%@&quot;,keypath); NSLog(@&quot;被修改的对象为%@&quot;,object); NSLog(@&quot;被修改的属性值%@&quot;,[chang objectForKey:@&quot;new&quot;]); NSLog(@&quot;被修改的上下文为%@&quot;,context);&#125;- (void)dealloc&#123; [self.item removeObserver:self forKeyPath:@&quot;name&quot;]; [self.item removeObserver:self forKeyPath:@&quot;price&quot;];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Android、iOS大不同(四)","date":"2014-09-04T11:01:55.000Z","path":"2014/09/04/Android、iOS大不同(四)/","text":"存取方法，Java没有明确限定Class要由固定的存取方法，但是符合JavaBean格式的类，都应该提供setter、getter存取方法。而Objective-C 2.0开始，自动合成setter、getter方法。Java中将成员变量限定为private，提供public的setter、getter存取方法，不再赘述。123456789public class MyClass &#123; private int value; public int getValue()&#123; rerturn value; &#125; public void setValue(value)&#123; this.value = value; &#125;&#125; 在OC中，自动合成setter、getter方法分两步完成 在类接口部分使用@peoperty指令定义属性 在类的实现部分使用@synthesize指令声明该属性以上步骤不但会合成成对的setter和getter方法，还会自动在类中实现一个与getter方法同名的成员变量。 Xcode 4.0编码规范推荐成员变量定义以下画线开头，在类实现部分使用@synthesize property名 [= 成员变量]指定成员变量名，如果没有指定，成员变量默认和property变量同名。 123456789101112131415@interface User : NSObject@property (nonatomic) NSString* name;@property NSString* pass;@property NSDate* birth;@end@implementation User@synthesize name =_name; // 底层默认会实现_name@synthesize pass; @synthesize birth;// 自定义实现一个setter- (void)setName:(NSString *)name&#123; self-&gt;_name = [NSString stringWithFormat:@&quot;+++%@&quot;,name];&#125;@end 在定义property时，可以增加一些指示符 assign 简单赋值，不更改所附值的引用计数，适用于NSInteger等基础类，以及short、float、double、结构体等各种C数据类型 atomic(nonatomic) 是否原子操作，即是否保证线程安全，atomic是默认值 copy 指定被赋值的对象复制一个副本，将副本值赋给变量 getter、setter 自定义存取方法名，比如@property(getter=abc,setter=xyz:)，注setter方法要带参数不要忘记冒号 readonly、readwrite 只提供getter或者同时提供getter和setter retain 在未开启ARC时，保证引用计数 strong、weak strong指定被赋值对象持有强引用，weak表示弱引用，只要强引用指向被赋值的对象，对象就不会被自动回收，若引用则不然 unsafa_unretained 与weak基本相熟，只是unsafa_unretained被回收后不会被赋为nil只要属性完成了存取方法，OC就可以通过点语法来访问属性，本质上是用setter和getter来访问的12User user = [[User alloc] init];user.name = @&quot;zoe&quot;;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Fragment","date":"2014-09-04T05:22:58.000Z","path":"2014/09/04/Fragment/","text":"Fragment用于创建动态的、多窗口的交互体验 创建一个Fragment 必须重写onCreateView()回调方法来定义布局 123456public class ArticleFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Budle savedInstanceState) &#123; return inflater.inflate(R.layout.article_view,container,false); &#125;&#125; 当activity的onPause()方法被调用时，它里面的所有fragment的onPause()方法都会被触发 用XML将fragment添加到Activity frament是可以重用的，每一个Fragment的实例都必须与一个FragmentActivity关联 1234567891011121314151617&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;fragment android:name=\"com.example.android.fragments.HeadlinesFragment\" android:id=\"@+id/headlines_fragment\" android:layout_weight=\"1\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" /&gt; &lt;fragment android:name=\"com.example.android.fragments.ArticleFragment\" android:id=\"@+id/article_fragment\" android:layout_weight=\"2\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt; FragmentActivity是Support Library提供的一个特殊的Activity，用来在API11版本以下的系统处理Fragment，如果版本大于11，可以使用普通的Activity 使用V7 appcompat library时，activity应该改为继承ActionBarActivity 注：使用XML布局的方式将Fragment添加到Activity时，Fragment是不能被动态移除的 动态添加FragmentManager类提供了方法，在Activity运行时能够对Fragment进行添加、移除、替换 为了执行Fragement的增加或移除操作，必须使用FragmentManager创建一个FragmentTransaction对象，它提供了增加、移除、替换以及其他一些操作的APIs 运行Fragment必须有一个容器View，Activity必须提供 1234&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/fragment_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 在Activity中，使用getSupportFragmentManager()方法获取FragmentManage对象，然后调用beginTransaction()方法创建FragmentTransaction对象，然后调用add()方法天剑fragment 使用同一个FragmentTansaction进行多次Fragment事务，完成操作必须调用commit()方法12345678910111213141516public class MainActivity extends FragmentActivity &#123; @Override public void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.news_articles); if(findViewById(R.id.fragment_container) != null)&#123; if (saveInstanceState != null) &#123; return; &#125; &#125; HeadlinesFragment firstFragment = new HeadelinesFragment(); firstFragment.setArguments(getIntent().getExtras()); getSupportFragmentManager().beginTransaction().add(R.id.fragment_container,firstFragment).commit(); &#125;&#125; Fragment替换 使用replace()方法来替换Fragment 为了向后导航与撤销，在FragemntTransaction提交前调用addToBackStack()方法 当移除或替换一个Fragment并把它放回到返回站中时，被移除的Fragment的生命周期是stopped，当用户返回重新恢复这个Fragment，它的生命周期的restarts。如果没有放入返回栈，移除或替换时，它就被destoryed了 1234567ArticleFragement newFragment = new AricleFragment();Bundle args = new Bundle();args.putInt(ArticleFragment.ARG_POSITION,postion);newFragment.setArguments(args);FramentTransaction transaction = getSupportFragmentManager().beginTransacation();transaction.replace(R.id.fragment_container,newFragment);transaction.commit(); addToBackStack()方法提供了一个可选的String参数为事务指定一个唯一的名字，为了使用FragmentManager.BackStackEntryAPIs的一些高级Fragment的操作作准备 Fragment之间的交互为了更好的实现逻辑，Fragmet之间的交互需要通过它们关联的Activity，Fragment之间不能直接交互 定义一个接口 为了让Fragment与Activity交互，可以在Fragment类中定义一个接口，在Activity中实现这个接口，Fragment在透明度生命周期的onAttach方法中捕获接口的实现，通过调用接口方法来与Activity交互12345678910111213141516171819202122public class HeadlinesFragment extends ListFragment &#123; OnHeadlineSelectedListener mCallback; public interface onHeadlineSelectedLinstener &#123; public void onArticleSelected(int position); &#125; @Override public void onAttach(Activity activiy) &#123; super.onAttach(activity); try &#123; mCallback = (OnHeadlineSelectedListener)activity; &#125; catch (ClassCastException e) &#123; throw new ClassCastException(activity.toString() + \" must implement OnHeadlineSelectedListener\"); &#125; &#125; // .... 列表被点击，传递给父Activity @Overrid public void onListItemClick(ListView l,View v,int position,long id) &#123; mCallback.onArticleSelected(position); &#125;&#125; 实现接口12345public class MainActivity extends FragmentActivity implements HeadlinesFragments.onHeadlineSelectedLinstener &#123; public void onAricleSelected(int postion) &#123; // 处理部分 &#125;&#125; 传递消息给Fragment 宿主Activity通过findFragmentById()方法来获取Fragment实例，然后调用Fragment的public方法来向Fragment来传递消息12345678910111213141516171819202122public claa MainActivity extends FragmentActivity implements HeadlinesFragments.onHeadlineSelectedLinstener &#123; //...承接上部分 public void onArticleSelected(int position) &#123; ArticleFragment articleFrag = (ArticleFragment)getSupportFragmentManager().findFragmentById(R.id.article_fragment); if (articleFrag != null) &#123; articleFrag.updateArticleView(position); &#125; else &#123; ArticleFragment newFragment = new ArticleFragment(); Bundle args = new Bundle(); args.putInt(ArticleFragment.ARG_POSITION, position); newFragment.setArguments(args); FragmentTransaction transaction = getSupportFragmentManager().beginTransaction(); transaction.replace(R.id.fragment_container, newFragment); transaction.addToBackStack(null); transaction.commit(); &#125; &#125;&#125;","tags":[{"name":"Fragment","slug":"Fragment","permalink":"http://seniorzhai.github.io/tags/Fragment/"},{"name":"动态交互","slug":"动态交互","permalink":"http://seniorzhai.github.io/tags/动态交互/"}]},{"title":"Android、iOS大不同(三)","date":"2014-09-03T13:54:57.000Z","path":"2014/09/03/Android、iOS大不同(三)/","text":"隐藏和封装封装是面向对象的三大特征(另两个是多态和继承)，封装指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部的信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。其目的是： 隐藏类的实现细节 使用时只能通过事先预定的方法来访问数据，限制不合理的访问，符合设计逻辑 进行数据监测，保证对象信息的完整性 便于修改提高可维护性访问控制符Objective-C提供了4个访问控制符@private、@package、@protected、@public @private(当前类访问权限) 只能在当前类的内部访问，在类的实现部分定义的成员变量默认使用这个访问权限 @oackage(与映像访问权限) 可以在当前类以及当前类实现的同一个映像的任意地方访问 @protected(子类访问权限) 可以在当前类和当前类的子类的任意地方访问，在类的接口部分定义的成员变量默认使用这种访问权限 @public(公共访问权限) 可以在任意地方访问1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@interface Person : NSObejct&#123; @private NSString* _name; int _age;&#125;- (void)setName:(NSString *)name;- (NSString *)getName;- (void)setAge:(int)age;- (int)getAge;@end@implementation Person- (void)setName:(NSString *)name&#123; if([name length] &gt; 6 || [name length] &lt; 2) &#123; return; &#125; else &#123; _name = name; &#125;&#125;- (NSSting *)getName&#123; return _name;&#125;- (void) setAge:(int)age&#123; if(age != _age) &#123; if(age &gt; 100 || age &lt; 0) &#123; return; &#125; else &#123; _age = age; &#125; &#125;&#125;- (int) getAge&#123; return _age;&#125;@end Java中也提供了4个访问控制符private、default、protected、public private 提供了类内部的访问权限 dufault 是默认的权限，同一包中和类内部可以访问 protected 提供了同类，同包和子类的访问权限 public 提供了外部访问权限，即可再任意地方访问12345678910111213141516171819202122232425public class Person&#123; private String name; private int age; public void setName(String name)&#123; if(name.length() &gt;6 || name.lenth()&lt;2)&#123; return; &#125;else&#123; this.name = name; &#125; &#125; public String getName()&#123; return this.name; &#125; public void setAge(int age)&#123; if(age &gt; 100 || age &lt; 0)&#123; return; &#125;else&#123; this.age = age; &#125; &#125; public getAge()&#123; return age; &#125;&#125; 隐藏的目的是为了封装类，达到程序的模块化，实现高内聚(功能实现细节在模块内部完成，不允许外部干预)，低耦合(尽量少地暴露方法给外部使用)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Android、iOS大不同(二)","date":"2014-09-01T11:04:07.000Z","path":"2014/09/01/Android、iOS大不同(二)/","text":"面向对象的一些知识点 代表对象自己的Java使用this表示对象自己12this.age = 10;this.run(); 而Objective-C使用self代表12self-&gt;age = 10;[self run]; 通用类型JAVA中，所有类都默认继承Object，所以可以用Object代表所有对象的类型。Objective-C中，所有对象都继承NSObejct，而且Objective-C提供了一个id类型，可以代表所有对象的类型。当通过id类型的变量来跟踪对象的所属的类，它会在运行时判断该对象所属的类，并在运行时确定需要的动态调用方法。12id p = [[Person alloc] init];[p say:@&quot;你好!&quot;]; 方法Obejective-C和Java中，类是一等公民，所有的方法都不能独立存在，方法必须属于类或者对象。在Java中，被static限定的就是类方法;Objective-C中，类方法用+标识。 方法只能在类中定义，不能单独存在 方法要么属于类本身，要么属于类的一个对象 永远不能单独执行方法，执行方法必须使用类或者对象作为调用者 参数可变的方法在java中，最后一个参数的变量类型后增加...即可表示方法接受可变参数参数可以视为一个数组处理123456789public int add(int x,int... args)&#123; int sum = x; for(int i = 0; i &lt; args.length ; i ++) &#123; sum += args[i]; &#125; return sum;&#125; 在Obejctive-C中，最后一个形参后增加,...(逗号三点)表示方法可接受对个参数值为了获取可变形参，可以使用如下关键字 va_list 类型，定义可变参数列表的指针变量 va_start 函数，该函数指定开始处理可变形参的列表，并让指针变量指向可变形参列表的第一个参数 va_end 函数，结束处理，释放指针变量 var_arg 函数，返回获取指针指向的参数的值，并一定指针到下一个参数1234567891011121314151617181920@interface VarArgs : NSObject- (void)test:(NSString *) name ,...;@end@implementation VarArgs- (void)test:(NSString *) name ,...&#123; va_list argList; if(name) &#123; va_start(argList,name); NSString* arg = va_arg(argList,id); while(arg)&#123; NSLog(@&quot;%@&quot;,arg); arg = va_(argList,id); &#125; va_end(argList); &#125;&#125;@end 类变量Java中类定义时，使用static限定的变量，就是类变量Objective-C不支持真正意义上的泪变量，一般通过内部全局变量来模拟变量123456789101112static NSString* nation = nil;+(NSString*) nation&#123; return nation;&#125;+(void)setNation:(NSString*)newNation&#123; if(![nation isEqualToString: newNation]) &#123; nation = newNation; &#125; &#125; 单例模式如果一个类只能创建一个类型，则这个类被称为单例类在Java中使用private隐藏构造方法，只暴露getInstance()方法来获取对象1234567891011121314public class Singletion &#123; private static Singleton uniqueInstance = null; private Singletion() &#123; &#125; public static Singleton getInstance() &#123; if(uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; Objective-C通过static全局变量定义单例指针123456789101112131415@interface Singleton : NSObject+(id) instance;@end// .mstatic id instance = nil;@implementation Singleton+ (id) instance&#123; if(!instance) &#123; instance = [[super alloc] init]; &#125; return instance;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"Serializable和Parcelable实现序列化","date":"2014-09-01T02:48:40.000Z","path":"2014/09/01/Serializable和Parcelable实现序列化/","text":"序列化是为了将对象转换成字节序列保存到本地或者在网络中、进程或Activity间传递对象。Android中自定义的对象序列化可以选择Parcelable或者Serializable来解决。 区别 在使用内存时，Parcelable比Serializable的性能高 Serializable在序列化的过程中产生大量的临时变量，从而引起频繁的GC Parceable不能使用在数据存储在磁盘的情况 Serialzable接口是Java SE支持的，Parcelable是Android特有的功能 实现 Serializable的实现与使用 123456789101112131415161718192021222324252627public class Box implements Serializable&#123; private int width; private int height; public void setWidth(int width)&#123; this.width = width; &#125; public void setHeight(int height)&#123; this.height = height; &#125; public static void main(String[] args)&#123; Box box = new Box(); box.setWidth(50); box.setHeight(30); try&#123; FileOutputStream fs = new FileOutputStream(\"foo.ser\"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(myBox); os.close(); &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; Parcelable实现Parcelable接口的实例，可以将自身的数据信息写入一个Parcel对象，也可以从Parcel中恢复到对象的状态。Parcel提供了一系列的方法帮助写入数据与读取数据 obtain()：在池中获取一个新的Parcel dataSize()：得到当前Parcel对象的实际存储空间 dataPosition()：获取当前Parcel对象的偏移量 setDataPosition()：设置当前Parcel对象的偏移量 recyle()：清空、回收当前Parcel对象的内存 writeXxx()：向当前Parcel对象写入数据，具有多种重载 readXxx()：从当前Parcel对象读取数据，具有多种重载简而言之，Parcelable通过writeToParcel()方法，对复杂对象的数据写入Parcel的方法进行对象序列化，需要的时候，通过定义的静态属性CREATOR.createFromParcel()进行反序列化的操作。Parcelable对Parcel进行包装，其内部就是通过Parcel进行序列化与反序列化 实现Parcelable接口Parcelable必须要实现的抽象方法： abstract int describeContents():返回一个位掩码，表示一组特殊对象类型的Parcelable，一般返回0即可 abstract void writeToParcel(Parcel dest,int flags):实现对象的序列化，通过Parcel的一系列writeXxx()方法序列化对象 abstract T createFromParcel(Parcel source):通过source对象，根据writeToParcel()方法序列化的数据，反序列化一个Parcelable对象 abstract T[] newArray(int size):创建一个新的Parcelable对象的数组类中定义一个名为CREATOR类型为Parcelable.Create的泛型静态属性，实现对象的反序列化123456789101112131415161718192021222324@Overridepublic int describeContents() &#123; return 0;&#125;@Overridepublic void writeToParcel(Parcel dest,int flags) &#123; // 序列化 dest.writeInt(id); dest.writeString(msgText); dest.writeString(fromName); dest.writeString(fromName); dest.writeString(date);&#125;@Overridepublic static final Parcelable.Creator&lt;Message&gt; CREATOR = new Creator&lt;Message&gt;() &#123;@Overridepublic Message[] new Array(int size)&#123; return new Message[size];&#125;@Overridepublic Message createFromParcel(Parcel source)&#123; // 反序列化 顺序要与序列化时相同 return new Message(source.readInt(),source.readString(),source.readString()source.readString());&#125;","tags":[{"name":"Serializable","slug":"Serializable","permalink":"http://seniorzhai.github.io/tags/Serializable/"},{"name":"Parcelable","slug":"Parcelable","permalink":"http://seniorzhai.github.io/tags/Parcelable/"},{"name":"序列化","slug":"序列化","permalink":"http://seniorzhai.github.io/tags/序列化/"}]},{"title":"git回退","date":"2014-08-30T16:30:11.000Z","path":"2014/08/31/git回退/","text":"git回退功能使用git log查看提交日志使用git git reset –hard HEAD^ 退回到上一次提交使用git reset –hard 3628164退回到指定版本","tags":[{"name":"git","slug":"git","permalink":"http://seniorzhai.github.io/tags/git/"}]},{"title":"Android动画","date":"2014-08-29T03:30:11.000Z","path":"2014/08/29/Android动画/","text":"Android 3.0之后的动画框架 分类 Property Animation 属性动画几乎可以让任何对象动起来，它使一个框架，在一个时间内，使用指定的内插技术来影响任何对象的属性 View Animation Tween Animation 补间动画 应用于View可以定义一系列位置、大小、旋转和透明度的改变 Frame Animation 帧动画 基于单元格的动画，每一帧显示一个不同的Drawable。帧动画可以在一个View中显示，并使用它的Canvas作为投影屏幕 Property Animation在Android 3.0(API level 11)引入，通过一个属性动画生成器，在一个给定时间内使用设定的差值算法将属性从一个值转换到另一个值。属性动画设定了规定时间内修改对象的属性，比如背景色和alpha值等，从简单的View效果，如移动、缩放、View的淡入淡出，到复杂的动画，如运行时的布局改变、曲线变换。可以用xml定义，存放路径为：res/animator/filename.xml可以通过资源的形式引用：R.animator.filename(in java)、@[package:]animator/file常用的java类包括：ValueAnimator,ObjectAnimator,AnimatorSet XML文件格式：1234567891011121314151617181920&lt;!-- together为同时播放 sequenttially为按顺序播放 --&gt;&lt;set android:ordering=[\"together\"|\"sequentially\"]&gt; &lt;objectAnimator android:propertyName=\"String\" android:duration=\"int\" android:valueFrom=\"float|int|color\" android:valueTo=\"float|int|color\" android:startOffset=\"int\" android:repeatCount=\"int\" android:repeatMode=[\"repeat\"|\"reverse\"] android:valueType=[\"intType\"|\"floatType\"]/&gt; &lt;animator android:duration=\"int\" android:valueFrom=\"float|int|color\" android:valueTo=\"float|int|color\" android:startOffset=\"int\" android:repeatCount=\"int\" android:repeatMode=[\"repeat\"|\"reverse\"] android:valueType=[\"intType\"|\"floatType\"]/&gt;&lt;/set&gt; 创建属性动画最简单的方法为使用ObjectAnimator类，这个类包含有offFloat、ofInt和ofObejct静态方法，可以将目标对象的特定属性在制定的值之间进行转换：1234String propertyName = \"alpaha\";float from = 1f;float to 0f;ObjectAnimator anim = ObjectAnimator.ofFloat(targetObject,propertyName,from,to); 该对象必须包含getter/setter方法，所以上面实例targetObject必须有getAlpha和setAlpha方法，返回和接受一个浮点型数值作于与非整数和非浮点数类型的属性时，对象要求提供一个TypeEvaluator类的实现，实现evaluate方法以返回一个对象，该对象是当动画为开始对象和结束对象之间动画的制定部分时应该返回的对象1234567891011TypeEvaluator&lt;MyClass&gt; evaluator = new TypeEvaluator&lt;MyClass&gt;() &#123; public MyClass evaluate(float fraction,MyClass startValue,MyClass endValue)&#123; MyClass result = new MyClass(); // 修改心对象，使之代表开始值和结束值之间的给定部分 return result; &#125; &#125;;//ValueAnimator oa = ObjectAnimator.ofObject(evaluator,myClassFromInstance,myClassToInstance);oa.setTarget(myClassInstance);oa.start(); 默认情况下，每个动画只运行300ms并且只运行一次。使用setDuration方法改变用来完成一次转换的差值器的总时间，使用setRepeatCount(ValueAnimator.INFINITE)制定运行次数，使用setRepeatMode(ValueAnimator.REVERSE)设置重复模式。通过XML设置动画1234567&lt;objectAnimator xmlns=android=\"http://schemas.android.com/apk/res/android\" android:valueTo=\"0\" android:propertyName=\"alpha\" android:duration=\"500\" android:valueType=\"floatType\" android:repeatConut=\"-1\" android:repeatMode=\"reverse\"/&gt; 通过XML载入动画123AnimatorSet set = (AnimatorSet)AnimatorInflater.loadAnimator(myContext,R.anim.property_animator);set.setTarget(myObject);set.start(); 创建属性动画集Android包含有AnimatorSet类，用来创建复杂、互相关联的动画想要向一个动画集中添加一个新的动画，可以使用play方法，这个方法返回一个AnimatorSet.Builder对象，通过它可以指定相对于其他动画何时播放指定的动画 1234AnimatorSet mySet = new AnimatorSet();mySet.play(firstAnimation).before(concurrentAnim1);mySet.play(concurent1Anim1).with(concurrentAnim2);mySet.play(lastAnim).after(concurrentAnim2); 使用动画监听器通过Animator.AnimationListener类可以创建事件处理程序 1234567Animator.AnimatorListener l = new AnimatorListener() &#123; public void onAnimationStart(Animator animation)&#123;&#125; public void onAnimationRepeat(Animator animation)&#123;&#125; public void onAnimationEnd(Animator animation)&#123;&#125; public void onAnimationCancel(Animator animation)&#123;&#125;&#125;anim.addListener(l); 插值器默认情况下，在每个动画开始和结束值之间中所用的差值器是一个非线性的插值器AccelerateDecelerateInterpolator提供了开始加速和结束时减速的效果，SDK提供的插值器有： AccelerateDecelerateInterpolator 开始和结束时结束变化较慢，在中间的时候加速 AccelerateInterpolator 开始的时候向后，然后再向前急冲 AnticipateInterpolator 开始的时候向后，然后再向前急冲一定的值后，最后回到最终的值 BouceInterpolator 动画结束时弹回 DecelerateInterpolator 开始时速度变化较快，然后减速 LinearInterpolator 速度的变化是一个常量 OvershootInterpolator 开始时向前急冲，超过最终的值，然后再回来通过setInterpolator()方法设置插值器，也可以实现TimeInterpolator类来指定一个自定义的差值算法。View AnimationView Animation包含了Tween Animation、Freme AnimationTween Animation 存放路径：res/anim/filename.xml 引用：R.anim.filename(in java)、@[package:]anim/file 应用： Activity间的转换 Activity内布局间的转换 相同View中不同内容间的转换 为了用户提供反馈，例如提示进度、通过晃动输入框来说明错误或无效的数据输入补间动画可以对View实现一系列的转换，比如：移动、渐变、伸缩、旋转Tween Animation只能作用于View对象，只支持一部分属性，比如不支持背景颜色的改变。而且并不改变View对象本身，只是绘制的属性改变了，例如Button改变了位置，但是点击区域仍然不变。 创建补间动画补间动画使用Animation类来创建，可用的类型有 AlphaAnimation 可以改变View的透明度 RotateAnimation 可以在XY平面上旋转选中的View Canvas ScaleAnimation 允许缩放选中的View TraslateAnimation 在屏幕中移动选中的View(但只能在它原始边界范围内显示)在xml中的定义格式如下：12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" android:interpolator=\"@[package:]anim/interpolator_resouce\" android:shareInterpolator=[\"true\"|\"false\"]&gt; &lt;alpha android:fromAlpha=\"float\" android:toAlpha=\"float\"/&gt; &lt;scale android:formXScale=\"float\" android:toXScale=\"float\" android:formYScale=\"float\" android:toYScale=\"float\" android:pivotX=\"float\" android:pivotY=\"float\"/&gt; &lt;translate android:fromXDelta=\"float\" android:toXDelta=\"float\" android:fromYDelta=\"float\" android:toYDelta=\"float\"/&gt; &lt;rotate android:fromDegress=\"float\" android:toDegress=\"float\" android:pivotX=\"float\" android:pivotY=\"float\"/&gt;&lt;/set&gt; 使用补间动画通过startAnimation方法可以将动画应用到任意View中，只要传递给这个方法应用的动画或动画集合即可 12345ImageView image = (ImageView)findViewById(R.id.image);Animation hyperspcaJump = AnimationUtils.loadAnimation(this,R.anim.hyperspace_jump);iamge.setRepeatMode(Animation.RESTART); // 循环 REVERSE为反向运行image.setRepeatCount(Animaion.INFINITE); // 重复image.startAnimation(hyperspaceJump); 使用动画监听器AnimationLister可以用于创建一个事件处理程序，当动画开始或结束的时候触发它，监听对象为Animation 1234567891011myAnimationListener(new AnimationListener()&#123; public void onAnimationEnd(Animation animation)&#123; // 动画执行完成调用 &#125; public void onAnimationStart(Animation animation)&#123; // 动画开始执行调用 &#125; public void onAnimationRepeat(Animation animation)&#123; // 在动画重复的时候调用 &#125;&#125;); 为布局和ViewGroup添加动画LayoutAnimation可以用来为ViewGroup添加动画，并按照预定的顺序把一个动画(或者动画集合)应用到ViewGroup的每一个子View中。 LayoutAniamationController 可以选择每一个View的开始偏移时间(以毫秒为单位)，以及把动画应用到每一个子View中的顺序和起始时间(正向、反向、随机) GridLayoutAnimationController 使用由行和列所映射的网格来向子View分配动画序列示例：创建布局动画12345&lt;layoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"0.5\" android:animationOrder=\"random\" android:animation=\"anim/popin\"/&gt; 使用布局动画使用代码或者布局XML资源将其应用到一个ViewGroup中 在XML中使用andorid:layoutAnimation来完成使用 在JAVA代码中使用setLayoutAnimation传递动画123456789// 载入动画Animation set = AnimationUtils.loadAnimation(this, R.anim.pop_in);// 创建LayoutAnimation LayoutAnimationController controller = new LayoutAnimationController( set);// 设置属性controller.setOrder(LayoutAnimationController.ORDER_REVERSE);//设置控件显示间隔时间；controller.setDelay(1); 通常情况动画会在ViewGroup第一次进行布局的时候执行一次，可以调用scheduleLayoutAnimation来强制动画再次执行，在View Grop下次布局的时候这个动画就会再次执行。布局动画也支持动画监听12345aViewGroup.setLayoutAnimationListener(new AnimationListener() &#123; public void onAnimationEnd(Animation _animation)&#123;&#125; public void onAnimationRepeat(Animation _animation)&#123;&#125; public void onAnimationStart(Animation _animation)&#123;&#125;&#125;); Frame animation帧动画是一系列的图片按顺序显示 文件路径res/drawable/filename.xml 引用：R.drawable.filename(in java)、@[package:]drawable/file xml文件格式123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=[\"true\" | \"false\"] &gt; &lt;item android:drawable=\"@[package:]drawable/drawable_resource_name\" android:duration=\"integer\" /&gt;&lt;/animation-list&gt; 使用1234ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image); rocketImage.setBackgroundResource(R.drawable.rocket_thrust); rocketAnimation = (AnimationDrawable) rocketImage.getBackground(); rocketAnimation.start(); 注意点：start()不能再onCreat()中调用","tags":[{"name":"动画","slug":"动画","permalink":"http://seniorzhai.github.io/tags/动画/"},{"name":"Animation","slug":"Animation","permalink":"http://seniorzhai.github.io/tags/Animation/"}]},{"title":"无线调试","date":"2014-08-28T05:45:47.000Z","path":"2014/08/28/无线调试/","text":"无需任何其他不相关的工具，便可无线调试程序 环境条件 确保设备与电脑运行在同一个wifi环境 Linux、OSX系统或者在windows上有可运行shell的软件(msysgit或Cygwin)，windows安装git时默认会安装gitbash也可以。 第一次运行需要用USB连接手机 确保配置了adb环境 Shell脚本1234567891011121314151617181920212223242526272829303132333435# !/bin/bash # Modify this with your IP rangeMY_IP_RANGE=&quot;192\\.168\\.1&quot;# You usually wouldn&apos;t have to modify thisPORT_BASE=5555# List the devices on the screen for your viewing pleasureadb devicesecho# Find USB devices only (no emulators, genymotion or connected devicesdeclare -a deviceArray=(`adb devices -l | grep -v emulator | grep -v vbox | grep -v &quot;$&#123;MY_IP_RANGE&#125;&quot; | grep &quot; device &quot; | awk &apos;&#123;print $1&#125;&apos;`) echo &quot;found $&#123;# deviceArray[@]&#125; device(s)&quot;echofor index in $&#123;!deviceArray[*]&#125;doecho &quot;finding IP address for device $&#123;deviceArray[index]&#125;&quot;IP_ADDRESS=$(adb -s $&#123;deviceArray[index]&#125; shell ifconfig wlan0 | awk &apos;&#123;print $3&#125;&apos;)echo &quot;IP address found : $IP_ADDRESS &quot;echo &quot;Connecting...&quot;adb -s $&#123;deviceArray[index]&#125; tcpip $(($PORT_BASE + $index))adb -s $&#123;deviceArray[index]&#125; connect &quot;$IP_ADDRESS:$(($PORT_BASE + $index))&quot;echoechodoneadb devices -l# exit 使用 USB连接手机 打开命令行，运行shell(windows右击gitbash运行) 出现以下画面变成功了","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"调试","slug":"调试","permalink":"http://seniorzhai.github.io/tags/调试/"},{"name":"adb","slug":"adb","permalink":"http://seniorzhai.github.io/tags/adb/"},{"name":"wifi","slug":"wifi","permalink":"http://seniorzhai.github.io/tags/wifi/"}]},{"title":"Indicator","date":"2014-08-28T03:00:21.000Z","path":"2014/08/28/Indicator/","text":"提供了一个水平滚动的Indicatorviewflow 绑定在java中绑定监听123viewFlow.setAdapter(new ImageAdapter(this),5);CircleFlowIndicator indic = (CircleFlowIndicator) findViewById(R.id.viewflowindic);viewFlow.setFlowIndicator(indic); 自定义属性 activeColor 选中的颜色 inactiveColor 未选中的颜色 activeType 选中模式(fill填充 or stroke描边) inactiveType 选中模式(fill填充 or stroke描边) fadeOut 淡出时间(0为不淡出) radius 半径123456789&lt;...CircleFlowIndicator ... app:fadeOut=1000 app:radius=\"5dp\" app:activeType=\"fill\" app:activeColor=\"@color/blue\" app:inactiveType=\"stroke\" app:inactiveColor=\"@color/white\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Indicator","slug":"Indicator","permalink":"http://seniorzhai.github.io/tags/Indicator/"}]},{"title":"单选ListView","date":"2014-08-27T10:51:44.000Z","path":"2014/08/27/单选ListView/","text":"实现单选必须要设置ListView为CHOICE_MODE_SINGLE(listView.setChoiceMode(ListView.CHOICE_MODE_SINGLE)或android:choiceMode=”singleChoice”)1234567891011121314private int cur_pos = 0;// 当前显示的一行private String[] items_text = &#123; \"选项一\", \"选项二\", \"选项三\", \"选项四\", \"选项五\" &#125;; ... final Mydapter dapter = new Mydapter(this); ListView listview = (ListView) findViewById(R.id.listView); listview.setAdapter(dapter); listview.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int position, long id) &#123; cur_pos = position;// 更新当前行 dapter.notifyDataSetChanged(); &#125; &#125;); 1234567891011121314151617181920212223242526272829303132333435public class Mydapter extends BaseAdapter &#123; private LayoutInflater inflater; public Mydapter(Context context) &#123; inflater = (LayoutInflater) context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); &#125; @Override public int getCount() &#123; return items_text.length; &#125; @Override public Object getItem(int position) &#123; return items_text[position]; &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; Log.e(\"TEST\", \"refresh once\"); convertView = inflater.inflate(R.layout.item, null, false); TextView tv = (TextView) convertView.findViewById(R.id.tv);// 显示文字 tv.setText(items_text[position]); if (position == cur_pos) &#123;// 如果当前的行就是ListView中选中的一行，就更改显示样式 convertView.setBackgroundColor(R.drawable.channel_list_item_bg_selected);// 更改整行的背景色 &#125; return convertView; &#125; &#125; 例子","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"常用git命令","date":"2014-08-27T00:36:56.000Z","path":"2014/08/27/常用git命令/","text":"常用配置123456789--- system # 系统级别--- global # 用户全局--local # 单独一个项目git config --global user.name &quot;xxx&quot; # 用户名git config --global user.email &quot;xxx@xxx.com&quot; # 邮箱git config --global core.editor vim # 编辑器git config --global alias.st status # 配置别名git config -l 列举所有配置 Git中3中状态的一些操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 将工作区的修改提交到暂存区git add &lt;file&gt;git add . # ------------------------------------------# 将暂存区的内容提交到版本库git commit &lt;file&gt;git commit .git commit -a # 包括git add/ git rm /git commint 这三个操作，所有一般在操作工作区的时候，直接删除了文件，而不是使用git rm的，最后提交是可以用这个，如下 # git commit -am &quot;提交信息&quot;git commit -amend # 修改最后一次提交的信息# 抛弃工作区修改(使用当前暂存区的内容状态去覆盖工作区，从而达到抛弃工作区修改的作用)git checkout &lt;file&gt; git checkout . # ------------------------------------------# 改变暂存区的修改（其实是重置HEAD，将指定版本库的内容状态去覆盖暂存区，从而达到暂存区的改变）git reset &lt;file&gt; # 从暂存区恢复到工作区（不指定版本id，则默认为最后一次提交的版本id）git reset . # 从暂存区恢复到工作区git reset $id # 恢复到指定的提交版本，该$id之后的版本提交都恢复到工作区git reset --hard $id # 恢复到指定的提交版本，该$id之后的版本提交全部会被抛弃，将不出现在工作区# 注：如果不小心使用了错误的HEAD重置，会发现HEAD指向了重置的版本id，该版本之后的版本提交都不见了，使用git log也无法找到，需要使用下面的命令git reflog show master | head # 会显示所有版本纪录git reset --hard $id # 重新重置，至于--hard，根据将改变的内容放到工作区还是直接抛弃进行选择# ------------------------------------------# 恢复某次提交（某次提交的回滚操作，不影响其他的提交，所产生的效果创建一个新的版本提交去回滚指定的提交）git revert &lt;$id&gt;git revert HEAD# revert和reset的差异：git reset是把HEAD向后移动了以下，而git revert是HEAD继续前进，只是新的内容和revert的内容正好相反# ------------------------------------------# 删除文件# 1.在工作区删除rm your_file # 直接在工作区删除文件git add -u . # 将有改动的都提交到暂存区（包括修改的，删除的等操作）。git 2.0后不加-u也可以git commit -m &quot;message&quot; # 提交到版本库# 2.同样在工作区删除rm your_filegit commit -am &quot;message&quot; # -a包括了 git add/git rm/git commit三个操作# 3.使用git rmgit rm &lt;file&gt; # 不仅在工作区删除文件，同时将删除操作提交到暂存区git commit -m &quot;message&quot; # 提交到版本库# git rm其他补充git rm --cached &lt;file&gt; # 从暂存区中去除该文件，git将不再跟踪该文件的变更，但仍然在工作区内 文件直接比较差异Diff123456git diffgit diff &lt;file&gt; # 比较工作区与暂存区文件的差异git diff --cached # 比较暂存区和版本库差异git diff &lt;$id2&gt;&lt;$id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 比较两个分支之间的差异 分支123456789101112131415git branch -r # 查看远程分支git branch new_branch_name # 新建一个分支git branch --merged # 查看未被合并到当前分支的分支git checkout branch_name # 切换分支git checkout -b branch_name # 创建分支并切换git branch -d branch_name # 删除分支git branch -D branch_name # 强制删除分支git push origin :branch_name # 删除远程分支（现在本地删除该分支），原理是把一个空分支push到server上，相对于删除该分支# 从远程clone项目，虽然远程上项目有分支，但是clone下来只有master分支，解决git checkout -b not_master_branch origin/not_master_branch # 本地创建一个分支，指向对应的远程分支git pull origin not_master_branch # 将远程的not_master_branch分支pull下来git push origin not_master_branch # 将修改后的not_master_branch分支push到远程的not_master_branch分支 远程12345git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@github.com:robin/robbin # 修改远程仓库地址git remote rm # 删除远程仓库地址 从远程拉取内容、提交内容12345678910git fetch # 拉取git merge # 合并git pull # git fetch + git mergegit push # push所有分支git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程（如果远程无主分支则创建，用于初始化远程仓库）git push origin &lt;local_brabch&gt; # 创建远程分支，origin是远程仓库名git push origin &lt;local_brabch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; # 先删除本地分支，然后再push删除远程分支 暂存管理12345git stash # 将工作区做的修改暂存到一个git栈中git stash list # 查看栈中所有暂存git stach apply &lt;暂存编号&gt; # 恢复对应编号暂存到工作区，如果不指定编号为栈顶，操作中这些暂缓还在栈中git stach pop # 将栈顶的暂存恢复到工作区，并从栈中弹出git stach clear # 清空暂存区 创建远程库12git clone --bare git_url_path # clone的时候，将其创建成远程仓库git --bare init # 初始化项目的时候，创建成远程仓库","tags":[{"name":"git","slug":"git","permalink":"http://seniorzhai.github.io/tags/git/"}]},{"title":"Android ViewFinder","date":"2014-08-26T06:09:32.000Z","path":"2014/08/26/Android-ViewFinder/","text":"在基类BaseActivity中加入如下函数12345678public final &lt;E extends View&gt; E getView (int id) &#123; try &#123; return (E) findViewById(id); &#125; catch (ClassCastException ex) &#123; Log.e(TAG,\"Could not cast View to concrete class.\",ex); throw ex; &#125;&#125; 使用ViewFinder类，封装了常用的方法。可以在Activity或View中调用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class ViewFinder &#123; private static interface FindWrapper &#123; View findViewById(int id); Resources getResources(); &#125; private static class WindowWrapper implements FindWapper &#123; private final Window window; WidowWrapper(final Window window) &#123; this.window = window; &#125; public View findViewById(final int id) &#123; return window.findViewById(id); &#125; public Resources getResources() &#123; return window.getContext().getResouces(); &#125; &#125; private static class ViewWrapper implements FindWrapper &#123; private final View view; ViewWrapper(final View view) &#123; this.view = view; &#125; public View findViewById(int id) &#123; return view.findViewById(id); &#125; public Resources getResources() &#123; return view.getResources(); &#125; &#125; private final FindWrapper wrapper; public ViewFinder(final View view) &#123; wrapper = new ViewWrapper(view); &#125; public ViewFinder(final Window window) &#123; wrapper = new WindowWrapper(window); &#125; public ViewFinder(final Activity activity) &#123; this(activity.getWindow()); &#125; public &lt;V extends View&gt; V find (final int id) &#123; return (V) wrapper.findViewById(id); &#125; public ImageView imageView(final int id) &#123; return find(id); &#125; public CompoundButton commpoudButton(final int id) &#123; return find(id); &#125; public TextView textView(final int id) &#123; return find(id); &#125; public TextView setText(final int id, final CharSequence content) &#123; final TextView text = find(id); text.setText(content); return text; &#125; public TextView setText(final int id, final int content) &#123; return setText(id, wrapper.getResources().getString(content)); &#125; public View onClick(final int id, final Runnable runnable) &#123; return onClick(id, new OnClickListener() &#123; public void onClick(View v) &#123; runnable.run(); &#125; &#125;); &#125; public void onClick(final OnClickListener listener, final int... ids) &#123; for (int id : ids) find(id).setOnClickListener(listener); &#125; public void onClick(final Runnable runnable, final int... ids) &#123; onClick(new OnClickListener() &#123; public void onClick(View v) &#123; runnable.run(); &#125; &#125;, ids); &#125; public ImageView setDrawable(final int id, final int drawable) &#123; ImageView image = imageView(id); image.setImageDrawable(image.getResources().getDrawable(drawable)); return image; &#125; public CompoundButton onCheck(final int id, final OnCheckedChangeListener listener) &#123; CompoundButton checkable = find(id); checkable.setOnCheckedChangeListener(listener); return checkable; &#125; public CompoundButton onCheck(final int id, final Runnable runnable) &#123; return onCheck(id, new OnCheckedChangeListener() &#123; public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; runnable.run(); &#125; &#125;); &#125; public void onCheck(final OnCheckedChangeListener listener, final int... ids) &#123; for (int id : ids) compoundButton(id).setOnCheckedChangeListener(listener); &#125; public void onCheck(final Runnable runnable, final int... ids) &#123; onCheck(new OnCheckedChangeListener() &#123; public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; runnable.run(); &#125; &#125;, ids); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Eclipse一些设置","date":"2014-08-26T05:53:22.000Z","path":"2014/08/26/Eclipse一些设置/","text":"显示行号General -&gt; Editors -&gt; Text Editors -&gt; Show line numbers 使用快捷键新建Android工程General -&gt; Keys -&gt; Command 在其中找到New(Android Application Project) 设置为 Ctrl+Alt+A 默认编码设置为UTF-8General -&gt; Workspace -&gt; Text file encoding XML代码保存后自动格式化Android –&gt; Editors –&gt; Always remove empty lines between elements：不要勾选，以确保个元素之间都有一个空行；Format on Save：勾选。 Java代码保存时自动格式化：Java –&gt; Editor –&gt; Save Actions –&gt; Perform the selected actions on save–&gt; 勾选 Format source code（如果是一个人写代码，可以勾选Format all lines；如果需要通过SVN/Git等与他人合作，一定不能勾选Format all lines而是勾选Format edited lines） Java代码中键入分号“;”、花括号“}”时自动调整位置：Java –&gt; Editor –&gt; Typing –&gt; Automatically insert at correct position 勾选Semicolons(分号)，Braces(花括号) 安装color themeHelp→Install New Software -&gt; Add 添加 http://eclipse-color-theme.github.com/update 然后下一步下一步就好安装完成 Window→Preferences→General→Appereance→Color Theme 选择自己喜欢的theme换上即可","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"悲剧的开始","date":"2014-08-26T02:01:30.000Z","path":"2014/08/26/悲剧的开始/","text":"之前的blog是使用gitpress，方便简单，只需要维护本地的一个工程就好。但是连续跪了两次了，毕竟是个小众的blog，个人开发者维护跟不上，决定转移到hexo上了。GitHub page + hexo 确实是个不错的方案，模板也比较多，遂，投奔。","tags":[{"name":"杂文","slug":"杂文","permalink":"http://seniorzhai.github.io/tags/杂文/"}]},{"title":"Anroid Studio开发工具新特性[Google IO 2014 Session]","date":"2014-08-23T06:09:03.000Z","path":"2014/08/23/Anroid-Studio开发工具新特性[Google-IO-2014-Session]/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"android imageview scaletype属性","date":"2014-08-21T06:07:47.000Z","path":"2014/08/21/android-imageview-scaletype属性/","text":"scaletype决定了图片在View上显示的方式，可以通过xml中定义android:scale=或者代码中调用imageView.setScaleType() 示例的原图128*128 640*428 CENTER按图片的原来size居中显示，当图片长/宽超过View的长/宽，则截取图片的居中部分显示 CENTER_CROP按比例扩大图片的size居中显示，使得图片长(宽)等于或大于view的长(宽) CENTER_INSIDE将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长/宽等于或小于View的长/宽 FIT_CENTER把图片按比例扩大/缩小到View的宽度，居中显示 FIT_START, FIT_END图片缩放效果上与FIT_CENTER一样，只是显示的位置不同，FIT_START是置于顶部，FIT_CENTER居中，FIT_END置于底部。 FIT_XY不按比例缩放图片，目标是把图片塞满整个View。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"注释头","date":"2014-08-21T02:37:19.000Z","path":"2014/08/21/注释头/","text":"123456789101112131415161718192021222324252627//// _oo0oo_// o8888888o// 88\" . \"88// (| -_- |)// 0\\ = /0// ___/`---'\\___// .' \\\\| |// '.// / \\\\||| : |||// \\// / _||||| -:- |||||- \\// | | \\\\\\ - /// | |// | \\_| ''\\---/'' |_/ |// \\ .-\\__ '-' ___/-. /// ___'. .' /--.--\\ `. .'___// .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;' \"\".// | | : `- \\`.;`\\ _ /`;.`/ - ` : | |// \\ \\ `_. \\_ __\\ /__ _/ .-` / /// =====`-.____`.___ \\_____/___.-`___.-'=====// `=---='////// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//// 佛祖保佑 永无BUG////// 神兽1234567891011121314151617181920/*code is far away from bug with the animal protecting * ┏┓ ┏┓ *┏┛┻━━━┛┻┓ *┃ ┃ *┃ ━ ┃ *┃ ┳┛ ┗┳ ┃ *┃ ┃ *┃ ┻ ┃ *┃ ┃ *┗━┓ ┏━┛ * ┃ ┃神兽保佑 * ┃ ┃代码无BUG！ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ * */ 1234567891011//// █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗// ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝// ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗// ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║// ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝// ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝// ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░// ░ ░ ░░░ ░ ░ ░ ░ ░░ ░// ░ ░ ░ ░ ░// ░ 12345678910111213141516171819 //// .::::.// .::::::::.// :::::::::::// ..:::::::::::'// '::::::::::::'// .::::::::::// '::::::::::::::..// ..::::::::::::.// ``::::::::::::::::// ::::``:::::::::' .:::.// ::::' ':::::' .::::::::.// .::::' :::: .:::::::'::::.// .:::' ::::: .:::::::::' ':::::.// .::' :::::.:::::::::' ':::::.// .::' ::::::::::::::' ``::::.// ...::: ::::::::::::' ``::.// ```` ':. ':::::::::' ::::..// '.:::::' ':'````..","tags":[{"name":"Prose","slug":"Prose","permalink":"http://seniorzhai.github.io/tags/Prose/"}]},{"title":"SwipeView","date":"2014-08-20T06:06:59.000Z","path":"2014/08/20/SwipeView/","text":"SwipeView提供了同级屏幕中的横向导航。适配器1234567891011121314151617181920212223public class DemoCollectionPagerAdapter extends FragmentStatePagerAdapter&#123; public DemoCollectionPagerAdapter(FragmentManager fm) &#123; super(fm); &#125; @Override public Fragment getItem(int i) &#123; Fragment fragment = new DemoObjectFragment(); Bundle args = new Bundle(); // 我们的对象只是一个整数 :-P args.putInt(DemoObjectFragment.ARG_OBJECT, i + 1); fragment.setArguments(args); return fragment; &#125; @Override public int getCount() &#123; return 100; &#125; @Override public CharSequence getPageTitle(int position) &#123; return \"OBJECT \" + (position + 1); &#125;&#125; 布局文件123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.view.ViewPager xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/pager\"&gt; &lt;android.support.v4.view.PagerTabStrip android:id=\"@+id/pager_title_strip\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"top\" android:background=\"# 33b5e5\" android:textColor=\"# fff\" android:paddingTop=\"4dp\" android:paddingBottom=\"4dp\" /&gt;&lt;/android.support.v4.view.ViewPager&gt; Fragment123456789101112131415public class DemoObjectFragment extends Fragment &#123; public static final String ARG_OBJECT = \"object\"; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; // 最后两个参数保证LayoutParam能被正确填充 View rootView = inflater.inflate(R.layout.fragment_collection_object, container, false); Bundle args = getArguments(); ((TextView) rootView.findViewById(R.id.textView1)).setText(Integer .toString(args.getInt(ARG_OBJECT))); return rootView; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android Activity Fragment生命周期","date":"2014-08-19T06:06:38.000Z","path":"2014/08/19/Android-Activity-Fragment生命周期/","text":"","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Box2D","date":"2014-08-19T03:31:33.000Z","path":"2014/08/19/Box2D/","text":"一款功能强大、性能强劲的物理引擎。它能都维持在一个独立的运行空间。 概述Box2D引擎创建的物体都属于理想的刚体，即它内部之间的距离永不改变。Box2D创建的物理世界具备以下三个特点。 物理世界存在一个重力（可以为0） 物理世界可以是一个存在边界的范围 在世界中加入静态和动态物体（具有质量和位置），它们被用来模拟现实的运动规律概念 物理世界（World)一个物理世界就是由各种刚体、框架、形状互相作用的集合。 刚体(Rigid Bodies)理想刚体是一个有限尺寸、可以忽略形变的物体。不论是否感受到作用力，在刚体内部，点与点之间的距离都不会改变，可以认为是一个连续质量分布体。 在Box2D物理世界中，所有物体都是刚体，这些物体一旦被创建出来后，其形状就不会改变。 形状(Shapes)2D平面几何结构，主要用于世界里的物理碰撞的检测。 框架(Fixtures)框架代表物理世界中物体的固定物质形态，是连接物体和形状之间的框架，一个物体可以有多个框架，没个框架可以连接一个形状、它本身存储着物体的质量、密度、摩擦系数，同时包含碰撞标志、用户数据和是否使用碰撞检测器的标志。他存在的目的主要是为了物理引擎的运算考虑。 关节(Joins)关节的作用是将两个有一定运动自由度(水平、数组、转动)的物体连接起来，同时约束连接的物体。Box2D引擎支持的关节类型有旋转、棱柱、距离等等，通常具备两个共同属性：限制(Limits)和马达(Motors) (1) 关节限制(joint limit) 限定了一个关节的运动范围。 (2) 关节马达(joint motor) 能依照关节的自由度来驱动所连接的物体。模块Box2D引擎由三个模块组成：公共(Common)、碰撞(Collision)和动态(Dynamics)。(1) Common核心模块包含了内存分配、数学计算和配置(2) Collision模块定义了形状(shape)、broad-phase检测盒碰撞功能/查询(collision functions/queries)(3) Dynamics模块提供对世界(world)、刚体(bodies)、框架(fixtures)和关节(joint)模拟数据单位Box2D引擎使用浮点数进行计算，所以为看保证它的正常工作，必须使用一些公差来保证它的正常工作。引擎能够良好的处理0.1~10米之间的移动物体。用户数据12345678// 创建一个精灵CCSprite* actor = CCSprite::node();// 物体的定义b2BodyDef bodyDef;// 指定数据bodyDef.userData = actor;// 创建物体actor-&gt;body = box2Dworld-&gt;CreateBody(&amp;bodyDef); 用户数据是可选的，并且能放入任何东西，为了保持一致性，通常保存精灵对象的指针。 物理世界World创建一个世界12345b2Vec2 gravity; // 重力gravity.Set(0.0f,-10.0f); world = new b2World(gravity);world-&gt;SetAllowSleeping(true); // 设置允许物体进入休眠状态world-&gt;SetContinuonsPhysics(true); // 设置使用连续物理检测 销毁世界12delete world;world = NULL; 世界运转起来物理世界类中用于驱动模拟的函数为Step，调用它时，需要指定一个时间步和一个速度及位置的迭代次数。12345678910111213float32 timeStep = 1.0f/60.0f; // 时间步，频率int32 velocityIterations = 10; // 速度迭代int32 positionIterations = 8; // 位置迭代次数myWorld-&gt;Step(timeStep,velocityIterations,positionIterations); // 驱动函数``` 在物理引擎执行一次时间步之后，最好是清除任何施加在物体上的力。可以使用`b2World::ClearForces`完成，可以去除力的持续作用效果。## 探索世界物理世界中存在创建工厂，工厂则会创建物体、框架和关节对象，同时世界也是容器，它会容纳工厂创建出来的所有对象。可以通过遍历的方式来获取世界中所有物体、框架和关节。```c++for (b2Body* b = myWorld()-&gt;GetBodyList();b;b = b-&gt;GetNext())&#123; b-&gt;WakeUp(); // 唤醒物体&#125; AABB查询Box2D引擎当中提供了AABB查询的方式，需要得出一个区域内所有对象时的解决方法。为此专门使用broad-phase的数据结构，它提供了一个log(N)复杂度的快速查询方法。123456789101112131415class MyQueryCallback : public b2QueryCallback&#123;public: bool ReportFixture(b2Fixture* fixture) &#123; b2Body* body = fixture-&gt;GetBody(); body-&gt;WakeUp(); return ture; // 继续查询 &#125;&#125;b2AABB aabb;aabb.lowerBound.Set(-1.0f,-1.0f); // 设置AABB的上边界aabb.upperBound.Set(1.0f,1.0f); // 设置AABB的下边界myWorld-&gt;Query(&amp;callback,aabb); 光线投射(Ray Casts)1234567891011121314151617181920212223242526272829303132class MyRayCastCallBack : public b2RayCastCallback&#123;public: MyRayCastCallback() &#123; m_fixture = NULL; &#125; float32 ReportFixture(b2Fixture* fixture,const b2Vec2&amp; point,const b2Vec2&amp; normal,float32 fraction) &#123; // 保存框架 m_fixture = fixture; // 保存交点 m_point = point; // 保存法向量 m_normal = normal; // 保存光线通过的分数距离 m_fraction = fraction; return fraction; &#125; b2xFixture* m_fixture; b2Vec2 m_point; b2Vec2 m_normal; float32 m_fraction;&#125;;// 回调函数MyRayCastCallback callback;// 光线投射的起始点b2Vec2 point(-1.0f,0.0f);// 光线投射的结束点b2Vec2 point(3.0f,1.0f);// 开始光线的投射myWorld-&gt;RayCast(&amp;callback,point1,point2); 形状Shapes形状是物体的包围盒，描述了可相互碰撞的几何对象的外形，它通常会是一个几何图形。被Shape是形状的基类，Box2D引擎中各种形状类都是继承自这个基类。此基类定义了几个常用函数： 判断一个点与形状是否有重叠 在形状上执行光线投射 计算形状的AABB 计算形状的质量所有形状都有两个成员变量：类型(type)和半径(radius)，引擎存在两种类型的形状：圆形和多边形。圆形(Circle Shapes)圆形形状(b2CircleShape)是一个由位置和半径表示的集合图形。圆形形状都是实心的，主要的参数就是半径。123b2CircleShape circle;// 创建圆形形状的对象circle.m_p.Set(1.0f,2.0f,3.0f);// 设置位置circle.m_radius = 0.5f;// 设置半径 多边形(Polygon Shape)多边形(b2PolygonShape)是实现的凸(Convex)多边形。数学的定义：在多边形内部任意选择两点，作一线段，如果所有线段都跟多边形的边不想交，这个多边形就是凸多边形。在Box2D引擎中一个多边形形状是通过顶点来描述的。12345b2PolygonDef triangleDef;triangleDef.vertexCont = 3;triangleDef.vertices[0].Set(-1.0f,0.0f);triangleDef.vertices[1].Set(1.0f,0.0f);triangleDef.vertices[2].Set(0.0f,2.0f); 在创建多边形时，顶点必须是逆时针排列。创建多边形时，顶点的数据可以通过数组来传递，数组中的顶点数最大值是核心模块中定义的b2maxPolygonVertices，默认情况下此数值是8。123456789b2Vec2 vertices[4];vertices[0].Set(0.0f,0.0f);vertices[1].Set(1.0f,0.0f);vertices[2].Set(0.0f,1.0f);vertices[3].Set(1.0f,1.0f);int32 count = 4;b2PolygonShape polygon;polygon.Set(vertices,count); 为了使用方便引擎还提供了一些定义好的初始化函数来创建固定的多边形形状：箱子(box)和边缘(edge，就是线段)123void SetAsbox(float32 hx,float32 hy);void SetAsBox(float32 hx,float32 hy,const b2Vec2&amp; center,float32 angle);void SetAsEdge(const b2Vec2&amp; v1,const b2Vec&amp; v2); 框架FixturesFixture是动态模块中重要的概念，用来物理模拟。动态模块包含的内容： 框架(Fixtures) 物体(Bodies) 接触(Contacts) 关节(Joints) 世界(World) 监听器(Listener)框架主要用于建立形状与物体之间的连接和进行物理模拟。密度(Density)框架的密度用来计算物体的质量属性，密度可以为零或者其他整数。摩擦(Friction)Box2D支持静态摩擦和动态摩擦，两者都使用的相同的摩擦系数作为参数。摩擦的强度与正交力成正比。摩擦系数经常会设置为0到1之间，0意味着没有摩擦，1会产生强摩擦。当计算两个形状之间的摩擦时，引擎必须计算两个形状的摩擦参数。12float32 friction;friction = sqrtf(shape1-&gt;friction * shape2-&gt;friction); 恢复(Resitution)为反弹的参数，它可以使对象弹起。恢复的值通常设置在0到1之间。恢复就是一个物体碰撞后反弹大小的参数，其值为0表示小球不会弹起，这称为非弹性碰撞。值为1表示小球的速度大小一样，只是方向相反，这称为完全弹性碰撞。12float32 resitution;restitution = b2Max(shape1-&gt;resitution,shape2-&gt;resitution); 帅选(Filtering)用来设置某些游戏对象相互碰撞的关系。Box2D支持最多十六个种群进行筛选。在引擎中碰撞筛选是通过掩码来完成的。1234playerFixtureDef.filter.categoryBits = 0x0002;playerFixtureDef.filter.maskBits = 0x0004;monsterFixturDef.filter.categoryBits = 0x0004;monsterFixturDef.filter.maskBits = 0x0002; 还可以进行分组，可以让同一组内的所有框架总是互相碰撞(正索引)或者永不碰撞(负索引)1234fixture1Def.filter.groupIndex = 2;fixture2Def.filter.groupIndex = 2;fixture3Def.filter.groupIndex = -8;fixture4Def.filter.groupIndex = -8; 静态物体上的框架永远不会与两一个静态物体上的框架发生碰撞，因为静态物体根本不会移动 同一个物体上的框架永远不会相互碰撞 如果物体用关节连接起来了，物体上的框架可以选择启用或禁止它们之间相互碰撞。感应器(Sensors)感应器是用来检测两个框架是否相交的对象。可以将任何一个框架对象设置为感应器，感应器可以是静态或者动态的。感应器发生碰撞时，是不会生成接触点的。12b2Contact::IsTouching // 这个函数可以得到感应器是否接触b2ContactListener::BeginContact和EndContact // 开始接触点和结束接触点 物体BodiesBox2D的物体均为刚体，它具有质量和惯性，运动状态由重心和受力决定，动态速度由线速度和角速度控制，可分为三类 静态物体(b2_staticBody)质量为0，在模拟时，静态不可移动，不过可以手动设置移动。速度为零。另外它不会和其他静态、平台物体碰撞。 平台物体(b2_kinematicBody)是按照固定轨迹在运动的物体，其质量也为零，可以预设一个速度，它也不会和其他的静态或平台物体相互碰撞。 动态物体(b2_dynamicBody)具有质量、速度、摩擦等，它将会参与引擎中的碰撞检测与物理模拟。可以与物理世界中任何对象发生碰撞。上述物体都可以被施加外力(forces)、扭矩(torques)、冲量(impulses)位置和角度(Position and Angle)是物体的最基本的属性，也就是物理世界都不会缺少这两个属性。物体的两个主要有两个属性是最最主要的： 第一个是物体的原点 第二个是物体的知心，可以显式地通过b2MassData来设置。12bodyDef.position.Set(0.0f,2.0f); // body的原点bodyDef.angle = 0.25f * b2_pi; // 弧度制下body的角 在引擎运转过程中，物体的位置和角度也会随时地改变。也可以通过物体类中的函数来改变。1void SetTransform(const b2Vec2&amp; position,float32 angle); 阻尼(Damping)用于表示减小物体的世界中的速度的数值。阻尼和摩擦有所不同，摩擦仅在物体有接触的时候才会发生，而阻尼却时时刻刻阻碍着物体运动，比如空气阻力。阻尼参数的数值范围可以是从零到无穷大。通常来说阻尼的值应该在0~0.1之间。12bodyDef.linearDamping = 0.0f;bodyDef.angularDamping = 0.01f; 休眠参数(Sleep Parameters)确定一个物体已经停止了移动时，物体就会进入休眠状态，休眠物体只消耗很小的CPU开销。接触到一个醒着的物体，物体就会被唤醒，物体上艹关节或触点被销毁的时候，也会醒来。12bodyDef.allowSleep = true; // 可以休眠bodyDef.awake = ture; // 休眠物体 固定旋转(Fixed Rotation)通过bodyDef.fixedRotation = ture物体的转动惯量设置成零，物体会保持初始化的角度，而不会发生旋转。 子弹(Bullets)子弹通常指一类速度很快而尺寸较小的物体，容易击穿其他物体。bodyDef.bullet = true 活动状态(Activation)一个非活动状态的物体，将完全地与世隔绝，不会参与物理模拟和碰撞检测，关节也不会被迷你。bodyDef.active = true 用户数据(User Data)一个存放用户数据的void指针，通常保存精灵对象12b2BodyDef bodyDef;bodyDef.userData = &amp;myActor; 关节(Joints)关节是将两个或两个以上物体连接在一起的对象，主要有三个作用 用于连接物体 用于限制物体的移动，是一种约束 它本身是一个能够活动的对象关节的定义(JointDef)关节包含一个用户数据的void指针，可以指定游戏元素，希望关节上的两个物体也能够发生碰撞，可以设置collideConnected布尔值来允许连接的物体之间进行碰撞。","tags":[{"name":"Box2D","slug":"Box2D","permalink":"http://seniorzhai.github.io/tags/Box2D/"},{"name":"物理引擎","slug":"物理引擎","permalink":"http://seniorzhai.github.io/tags/物理引擎/"}]},{"title":"AndroidStudio使用指南","date":"2014-08-18T06:05:31.000Z","path":"2014/08/18/AndroidStudio使用指南/","text":"界面界面简介 菜单和工具条管理Android Studio的显示窗口按下ctrl+shift+a（mac为command+shift+a）会触发一个命令提示框，输入想要执行的命令的前缀，可以找到自己的命令 更改常用操作的快捷键在设置中烧到keymap，可以选择为eclipse的快捷键","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Sprite精灵类","date":"2014-08-18T03:38:05.000Z","path":"2014/08/18/Sprite精灵类/","text":"常用创建方法123456789101112131415161718192021222324252627282930313233bool MyScene::init()&#123; Size size = Director::getInstance()-&gt;getWinSize(); Sprite *sp1 = Sprite::create(\"icon.png\"); sp1-&gt;setPosition(Vec2(size.with*0.2,size.height*0.7)); this-&gt;addChild(sp1); Sprite *sp2 = Sprite::create(\"icon.png\",Rect(10,30,28,28)); sp2-&gt;setPosition(Vec2(size.width*0.4,size.height*0.7)); this-&gt;addChild(sp2); // 创建纹理 Texture2D *texture = TextureCache::sharedTextureCache()-&gt;addImage(\"icon.png\"); Sprite *sp3 = Sprite::createWithTexture(texture); sp3-&gt;setPosition(Vec2(size.width*0.6,size.height*0.7)); this.addChild(sp3); Sprite *sp4 = Sprite::createWithTexture(texture,Rect(0,0,40,40)); sp4-&gt;setPosition(Vec2(size.width*0.8,size.height*0.7)); this.addChild(sp4); SpriteFrame *frame = SpriteFrame::create(\"icon.png\",Rect(0,0,57,57)); Sprite *sp5 = Sprite::createWithSpriteFrame(frame); sp5-&gt;setPosition(Vec2(size.width*0.3,size.height*0.3)); this.addChild(sp5); Sprite *sp6 = Sprite::createWithSpriteFrame(\"icon.png\"); sp6-&gt;setPosition(Vec2(size.width*0.3,size.height*0.3)); this-&gt;addChild(sp6); return true;&#125; 常用的类方法： setScale(float fScale) 缩放 setRotation(float fRotation) 旋转 setSkew(float s) 倾斜 setAnchorPoint(const Point&amp; another) 设置锚点 setVisible(bool bvisible) 是否可见 setColor(const cccolor3B&amp; color3) 设置颜色 setOpacity(Glubvte Opacity) 透明度设置 0-255 0表示完全透明，255表示不透明 setTexture(CCTexture2D *texture) 更改图片","tags":[{"name":"精灵","slug":"精灵","permalink":"http://seniorzhai.github.io/tags/精灵/"},{"name":"Sprite","slug":"Sprite","permalink":"http://seniorzhai.github.io/tags/Sprite/"}]},{"title":"Edify语言","date":"2014-08-17T06:05:00.000Z","path":"2014/08/17/Edify语言/","text":"ui_print(msg1,…,msgN) 用于在Recovery界面输出字符串，不定参数。 run_program(prog,arg1,…,argN) 用于执行程序，其中prog参数表示执行的程序文件(要写完整路径)，arg1,…argN表示执行程序的参数，prog是必须的，arg是可选的 delete(file1,…fileN) 用于删除一个或多个文件 package)extract_dir(package_path,desination_path) 用于提取刷机包中的pack_path指定的目录。其中package_path参数表示刷机包中的目录，destination_path表示目标目录 set_perm(uid,gid,mode,file1,file2,…fileN) 用于设置一个或多个文件的权限，其中uid参数表示用户ID，gid表示用户组ID。如果想让文件的用户和用户组都是root，uid和gid需要都为0。mode参数表示设置的权限，与chmod命令类似。 mount(fs_type,partion_type,location,mount_point) 挂载分区 unmount(mount_point) 用于解除挂载，mount_point参数表示文件系统","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"ArcMenu","date":"2014-08-15T06:04:00.000Z","path":"2014/08/15/ArcMenu/","text":"仿Path带动画效果的扇形菜单 用法123456789ArcMenu menu = (ArcMenu) findViewById(R.id.arc_menu);final int itemCount = ITEM_DRAWABLES.length;for (int i = 0; i &lt; itemCount; i++) &#123; ImageView item = new ImageView(this); item.setImageResource(ITEM_DRAWABLES[i]); menu.addItem(item,new OnClick(View v)&#123; Toast.makeText(MainActivity.this, \"position:\" + position, Toast.LENGTH_SHORT).show(); &#125;);&#125; 改变外观可以在xml中123custom:childSize=\"50px\"custom:fromDegrees=\"0.0\"custom:toDegrees=\"300.0\" 或者在java中12arcLayout.setChildSize(50);arcLayout.setArc(0.0f,300.0f); ArcMenu","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"NiftyDialogEffects","date":"2014-08-15T05:57:55.000Z","path":"2014/08/15/NiftyDialogEffects/","text":"一个拥有丰富动画的对话框 使用123456789101112131415161718192021222324252627// 获取一个对话框对象NiftyDialogBuilder dialogBuilder = NiftyDialogBuilder.getInstance(this);dialogBuilder.withTitle(\"弹出框\") // 标题 .withTitleColor(\"# FFFFFF\") // 标题的颜色 .withDividerColor(\"# 11000000\") // 分隔栏的颜色 .withMessage(\"这是信息文本。\") // 文本信息 .withMessageColor(\"# FFFFFF\") // 文本信息的颜色 .withIcon(getResources().getDrawable(R.drawable.icon)) // 标题栏的图标 .isCancelableOnTouchOutside(true) // 外部点击退出 .withDuration(500) // 动画延迟 .withEffect(effect) // 动画类别 .withButton1Text(\"确定\") // 按钮1的文本 .withButton2Text(\"取消\") // 按钮2的文本 .setCustomView(R.layout.custom_view, v.getContext()) // 设置自定义view .setButton1Click(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(v.getContext(), \"确定\", Toast.LENGTH_SHORT).show(); &#125; &#125;).setButton2Click(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(v.getContext(), \"取消\", Toast.LENGTH_SHORT).show(); &#125; &#125;).show(); 自定义内容NiftyDialogEffects的color文件内可以修改对话框的颜色1234567&lt;color name=\"text_color\"&gt;# FFFFFF&lt;/color&gt; &lt;color name=\"divider_color\"&gt;# 11000000&lt;/color&gt; &lt;color name=\"msg_color\"&gt;# FFFFFFFF&lt;/color&gt; &lt;color name=\"dialog_bg\"&gt;# FF4FC1E9&lt;/color&gt; &lt;color name=\"btn_press_color\"&gt;# FF4FC1E9&lt;/color&gt; &lt;color name=\"btn_unpress_color\"&gt;# FF3BAFDA&lt;/color&gt; ===NiftyDialogEffects","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"TabBarView","date":"2014-08-14T05:57:03.000Z","path":"2014/08/14/TabBarView/","text":"使用1234567891011LayoutInflater inflator = (LayoutInflater) this.getSystemService(Context.LAYOUT_INFLATER_SERVICE);View v = inflator.inflate(R.layout.custom_ab,null);tabBarView = (TabBarView) v.findViewById(R.id.tab_bar);getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_SUSTOM);getActionBar().setCustomView(v);mSectionsPagerAdapter = new SectionsPagerAdapter(getFramentManager());mViewPager = (ViewPager) findViewById(R.id.pager);tabBarView.setViewPager(mViewPager); 实现一个adapter12345678910111213141516171819202122232425262728293031public class SectionsPagerAdapter extends FragmentPagerAdapter implements IconTabProvider &#123; private intp[] tab_icons = &#123;R.drawable.ic_tab1,R.drawable.ic_tab2,R.drawable.ic_tab3&#125;; public SectionsPagerAdapter(FragmentManager fm)&#123; super(fm); &#125; @Override public Fragment getItem(int position) &#123; return PlaceholderFragment.newInstance(position + 1); &#125; @Override public int getCount() &#123; return tab_icons.length; &#125; @Override public CharSequence getPageTitle(int position) &#123; Locale l = Locale.getDefault(); switch (position) &#123; case 0: return getString(R.string.title_section1).toUpperCase(l); case 1: return getString(R.string.title_section2).toUpperCase(l); case 2: return getString(R.string.title_section3).toUpperCase(l); &#125; return null; &#125;&#125; ===TabBarView","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"相机功能","date":"2014-08-14T05:56:39.000Z","path":"2014/08/14/相机功能/","text":"测光与聚焦区域如果设备支持自动对焦，可以使用setFocusMode方法传入一个Camera.Parameters.FOCUS_MODE_*常量来指定对焦模式。根据不同设备的支持，使用getSupportedFocusMode方法找到可用的对焦模式。使用自动对焦可以使用AutoFocusCallback回调。12345678910Camera.Parameters parameters = camera.getParameters();if(parameters.getSupportedFocusModes().contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE))&#123;parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);camer.autoFocus(new AutoFocusCallback()&#123; public void onAutoFocus(boolean success,Camera camera)&#123; // &#125;&#125;);&#125; getMaxNumFocusAreas方法来确定涉笔是否支持定义对焦区域。getMaxNumMeteringAreas来确定摄像头是否支持测光区域。1234567891011if(params.getMaxNumMeteringAreas() &gt; 0) &#123; // 检查是否支持测光区域 List&lt;Camera.Area&gt; meteringAreas = new ArrayList&lt;Camera.Area&gt;(); Rect areaRect1 = new Rect(-100,-100,100,100); // 在图像的中心指定一个区域 meteringAreas.add(new Camera.Area(areaRect1,600)); // 设置宽度待60% Rect areaRect2 = new Rect(800,-1000,1000,-800); // 在图像的右上角指定一个区域 meteringAreas.add(new Camera.Area(areaRect2,400)); // 设置宽度为40% params.setMeteringAreas(meteringAreas);&#125;mCamera.setParameters(params); Camera.Area对象包含两个参数：一个Rect对象指定了相机视图中的一个区域，还有一个宽度，告诉相机在测光或聚焦计算中此区域的重要程度。Camera.Area对象的Rect描述了一个矩形区域在一个2000*2000个单元格组成的区域中的映射位置。坐标-1000，-1000表示左上角，1000,1000表示右下角。不会随变焦大小改变。 人脸识别调用getMaxNumDetectedFaces()来检测是否支持面部检测特性12345678class MyFaceDetectionoListener implements Camera.FaceDetectionListener &#123; @Override public void onFaceDetection(Face[] faces,Camera camera) &#123; if (faces.length &gt; 0) &#123; Log.d(\"FaceDetection\",\"face detected:\" + faces.length + \"face 1 Location x:\" + faces[0].rect.centerX() + \"Y:\" + faces[0].rect.centerY()); &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"控制相机硬件","date":"2014-08-13T05:56:06.000Z","path":"2014/08/13/控制相机硬件/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Preview extends ViewGroup implements SurfaceHolder.Callback &#123; SurfaceView mSurfaceView; SurfaceHolder mHolder; Perview(Context context)&#123; super(context); mSurfaceView = new SurfaceView(context); addView(mSurfaceView); mHolder = mSurfaceView.getHolder(); mHolder.addCallback(this); mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); &#125;&#125;public void setCamera(Camera camera) &#123; if (mCamera == camera) &#123; return; &#125; stopPreviewAndFreeCamera(); mCamera = camera; if (mCamera != null) &#123; List&lt;Size&gt; localSizes = mCamera.getParameters().getSupportedPreviewSizes(); mSupportedPreviewSizes = localSizes; requestLayout(); try &#123; mCamera.setPreviewDisplay(mHolder); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; mCamera.startPreview(); &#125;&#125;// 修改相机设置public void surfaceChanged(SurfaceHolder holder,int format,int w,int h) &#123; Camera.Parameters parameters = mCamera.getParameters(); parameters.setPreviewSize(mPreviewSize.with,mPreviewSize.height); requestLayout(); mCamera.setParameters(parameters); mCamera.startPreview();&#125;// 设置预览方向 setCameraDisplayOrientation()方法 Android Api level 14之前 必须先体质预览// 拍摄照片Camera.takePicture()拍下图片创建Camera.PictureCallback与Camera.ShutterCallback 对象并传递到Camera.takePocture()中如果想做连拍动作，可以创建一个Camera.PreviewCallback并实现onPerviewFrame()// 停止预览并释放相机public void surfaceDestroyed(SurfaceHolder holder) &#123; if (mCamera != null) &#123; mCamera.stopPreview(); &#125;&#125;public void stopPreviewAndFreeCamera() &#123; if (mCamera != null) &#123; mCamera.stopPreview(); mCamera.release(); mCamera = null; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Cocos2d-X 常用的数学函数、常用宏","date":"2014-08-12T09:30:59.000Z","path":"2014/08/12/Cocos2d-X-常用的数学函数、常用宏/","text":"ccp(x,y) 创建一个向量 ccpFromSize(s) 以size s的width为x，height为y创建一个向量 ccpAdd(v1,v2) 向量之间的加法 ccpSub(v1,v2) 向量之间的减法 ccpNeg(v) 向量取反 ccpMult(v,s) 数乘，等价于ccp(v.xs,v.ys) s是一个浮点数 ccpMidpoint(v1,v2) 取中点 ccpDot(v1,v2) 点乘 等价于 v1.xv2.x + v1.yv2.y ccpCross(v1,v2) 叉乘 等价于 v1.xv2.y - v1.yv2.x ccpProject(v1,v2) 返回向量v1在向量v2的投影向量 ccpLength(v) 返回向量v的长度 ccpLengthSQ(v) 返回向量v的长度的平方 ccpDistance(v1,v2) 返回点v1到v2的距离 cppDistanceSQ(v1,v2) 返回点v1到v2距离的平方 ccpNormalize(v) 返回v的标准化向量，就是长度为1 ccpRotate(v1,v2) 向量v1旋转过向量v2的角度并且乘上向量v2的长度。当v2是一个长度为1的标准向量时就是正常的旋转了，可以配套地用ccpForAngle ccpPerp(v) 等价于 ccp(-v.y, v.x); （因为opengl坐标系是左下角为原点，所以向量v是逆时针旋转90度） ccpRPerp(v) 等价于 ccp(v.y, -v.x); 顺时针旋转90度 ccpForAngle(a) 返回一个角度为弧度a的标准向量 ccpToAngle(v) 返回向量v的弧度 ccpAngle(a, b) 返回a，b向量指示角度的差的弧度值 ccpRotateByAngle(v, pivot, angle) 返回向量v以pivot为旋转轴点，按逆时针方向旋转angle弧度 CC_RADIANS_TO_DEGREES(a) 弧度转角度 CC_DEGREES_TO_RADIANS(a) 角度转弧度 CCRANDOM_MINUS1_1() 产生-1到1之间的随机浮点数 CCRANDOM_0_1() 产生0到1之间的随机浮点数 CCAssert(cond,msg) 断言表达式cond为真，如果不为真，则显示字符串msg信息 1234567891011121314151617CCArray* _array; CCObject* _object; // 用来遍历数组的临时变量 CCARRAY_FOREACH(_array, _object) // 正向遍历 &#123; // todo with _object.... &#125; CCARRAY_FOREACH_REVERSE(_array, _object) // 反向遍历 &#123; // todo with _object.... &#125; CCDictionary* _dict; CCDictElement* _elmt; // 遍历表的临时变量 CCDICT_FOREACH(_dict, _elmt) &#123; // todo with elmt; &#125; CREATE_FUNC() 创建构造函数12345678910111213141516# define CREATE_FUNC(__TYPE__)static __TYPE__* create()&#123; __TYPE__ *pRet = new __TYPE__(); if (pRet &amp;&amp; pRet-&gt;init()) &#123; pRet-&gt;autorelease(); return pRet; &#125; else &#123; delete pRet; pRet = NULL; return NULL; &#125;&#125;","tags":[{"name":"Cocos2d-X","slug":"Cocos2d-X","permalink":"http://seniorzhai.github.io/tags/Cocos2d-X/"},{"name":"数学，宏","slug":"数学，宏","permalink":"http://seniorzhai.github.io/tags/数学，宏/"}]},{"title":"看着舒服发12种界面颜色","date":"2014-08-11T05:55:31.000Z","path":"2014/08/11/看着舒服发12种界面颜色/","text":"GRAPEFRUIT # ED5565,# DA4453 BITTERSWEET # FC6E51,# E9573F SUNFLOWER # FFCE54,# F6BB42 GRASS # A0D468,# 8CC152 MINT # 48CFAD,# 37BC9B AQUA # 4FC1E9,# 3BAFDA BLUE JEANS # 5D9CEC,# 4A89DC LAVANDER # AC92EC,# 967ADC PINK ROSE # EC87C0,# D770AD LIGHT GRAY # F5F7FA,# E6E9ED MEDIUM GRAY # CCD1D9,# AAB2BD DARK GRAY # 656D78,# 434A54 不透明度16进制值 不透明度 16进制值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"颜色","slug":"颜色","permalink":"http://seniorzhai.github.io/tags/颜色/"}]},{"title":"selector背景选择器","date":"2014-08-11T05:54:57.000Z","path":"2014/08/11/selector背景选择器/","text":"listview的item可选的背景 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;!-- 默认时的背景背景 --&gt; &lt;item android:drawable=\"@drawable/pic1\" /&gt; &lt;!-- 没有焦点时的背景图片 --&gt; &lt;item android:state_window_focused=\"false\" android:drawable=\"@drawable/pic1\" /&gt; &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt; &lt;item android:state_focused=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/pic2\" /&gt; &lt;!-- 触摸模式下单击时的背景图片 --&gt; &lt;item android:state_focused=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/pic3\" /&gt; &lt;!-- 选中时的图片背景 --&gt; &lt;item android:state_selected=\"true\" android:drawable=\"@drawable/pic4\" /&gt; &lt;!-- 获得焦点时的图片背景 --&gt; &lt;item android:state_focused=\"true\" android:drawable=\"@drawable/pic5\" /&gt; 在listView中配置android:listSelector=&quot;@drawable/list_item_bg&quot;或者在item中添加android:background=&quot;@drawable/list_item_bg&quot;即可实现，或者在java代码中使用Drawable drawable = getResources().getDrawable(R.drawable.list_item_bg);,listView.setSelector(drawable);。可能出现列表出现黑的情况，加上android:cacheColorHint=&quot;@android:color/transparent&quot;。 button的可选背景 android:state_selected 为选中 android:state_focused 获得焦点 android:state_pressed 点击 android:state_enable 是否响应事件，指所有事件&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_selected=\"true\" android:color=\"# FFF\" /&gt; &lt;item android:state_focused=\"true\" android:color=\"FFF\" /&gt; &lt;item android:state_pressed=\"true\" android:color=\"# FFF\" /&gt; &lt;item android:color=\"# 000\" /&gt; &lt;/selector&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android、iOS大不同(一)","date":"2014-08-09T05:54:07.000Z","path":"2014/08/09/Android、iOS大不同(一)/","text":"长夜漫漫，无心睡眠，定一个小目标吧，写一下自己对android、iOS开发区别的见解。 Java、OC大不同本人先会的Java，所以比较都会以Java、Android入手开始比较。 1. 类的定义OC的类定义比较特殊分为两个部分，接口部分和实现部分比如一个MyClass类，有岁数和名字两个成员变量，一个实例方法jump和一个类方法runjava是这么定义的123456789101112131415public class Person &#123; public int age; public String name; private long tmp; public Person(int age,String name)&#123; this.age = age; this.name = name; &#125; public void jump(String str)&#123; // &#125; public static void run()&#123; // &#125; &#125; OC的定义需要两个部分MyaClass.h和MyClass.m 12345678910# import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObejct&#123; int _age; NString* _name;&#125;- (void)jump:(NSString*)str;+ (void)run;@end 123456789101112131415# import &quot;MyClass.h&quot;@implementation MyClass&#123; long _tmp; // 只能在实现部分使用，相当于private的变量 &#125;- (void)jump:(NSString *)str&#123; //&#125;+ (void)run&#123; //&#125;@end 2.新建对象和使用如果java中的对象是这样的12345public class MyClass&#123; public void run()&#123; System.out.println(\"I'm running!!!\"); &#125;&#125; 它的新建就是MyClass a = new MyClass()，Java帮助它实现了默认的一个构造函数。使用run方法时则是a.run()。OC则是这样的 1234567891011// MyClass.h...@interface MyClass : NSObject- (void)run;@end// MyClass.m@implementation MyClass- (void)run&#123; NSLog(@&quot;I&apos;m running!!!&quot;);&#125; 使用时MyClass a = [[MyClass alloc] init]，OC同样帮助它实现了一个默认的构造函数。使用run方法时则是[a run]。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://seniorzhai.github.io/tags/Java/"},{"name":"Objective-C","slug":"Objective-C","permalink":"http://seniorzhai.github.io/tags/Objective-C/"},{"name":"大不同","slug":"大不同","permalink":"http://seniorzhai.github.io/tags/大不同/"}]},{"title":"PixelUtils","date":"2014-08-08T05:52:49.000Z","path":"2014/08/08/PixelUtils/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class PixelUtils &#123; private static Context mContext = MyApplication.getInstance(); // dp-&gt;px public static int dp2px(float value) &#123; final float scale = mContext.getResources().getDisplayMetrics().densityDpi; return (int) (value * (scale / 160) + 0.5f); &#125; // dp-&gt;px public static int dp2px(float value, Context context) &#123; final float scale = context.getResources().getDisplayMetrics().densityDpi; return (int) (value * (scale / 160) + 0.5f); &#125; // px-&gt;dp public static int px2dp(float value) &#123; final float scale = mContext.getResources().getDisplayMetrics().densityDpi; return (int) ((value * 160) / scale + 0.5f); &#125; // px-&gt;dp public static int px2dp(float value, Context context) &#123; final float scale = context.getResources().getDisplayMetrics().densityDpi; return (int) ((value * 160) / scale + 0.5f); &#125; // sp-&gt;px public static int sp2px(float value) &#123; Resources r; if (mContext == null) &#123; r = Resources.getSystem(); &#125; else &#123; r = mContext.getResources(); &#125; float spvalue = value * r.getDisplayMetrics().scaledDensity; return (int) (spvalue + 0.5f); &#125; // sp-&gt;px public static int sp2px(float value, Context context) &#123; Resources r; if (context == null) &#123; r = Resources.getSystem(); &#125; else &#123; r = context.getResources(); &#125; float spvalue = value * r.getDisplayMetrics().scaledDensity; return (int) (spvalue + 0.5f); &#125; // px-&gt;sp public static int px2sp(float value) &#123; final float scale = mContext.getResources().getDisplayMetrics().scaledDensity; return (int) (value / scale + 0.5f); &#125; // px-&gt;sp public static int px2sp(float value, Context context) &#123; final float scale = context.getResources().getDisplayMetrics().scaledDensity; return (int) (value / scale + 0.5f); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"PreferencesUtils","date":"2014-08-08T05:52:12.000Z","path":"2014/08/08/PreferencesUtils/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class PerferencesUtils &#123; public static String PREFERENCE_NAME = \"MYPERFERENCERS\"; public static boolean putString(Context context,String key,String value) &#123; SharedPreferces settings = context.getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE); SharedPreferces.Editor = settings.edit(); editor.putString(key,value); return editor.commit(); &#125; public static String getString(Context context,String key) &#123; return getString(context,key,null); &#125; public static String getString(Context context,String key,String defaultValue) &#123; SharedPreferces settings = context.getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE); return settings.getString(key,defaultValue); &#125; public static boolean putInt(Context context,String key,int value) &#123; SharedPreferces settings = context.getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE); SharedPreferces.Editor = settings.edit(); editor.putInt(key,value); return editor.commit(); &#125; public static int getInt(Context context,String key) &#123; return getInt(context,key,-1); &#125; public static int getInt(Context context,String key,int defaultValue) &#123; SharedPreferences settings = context.getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE); return settings.getInt(key,defaultValue); &#125; public static putLong(Context context,String key,long value) &#123; SharedPreferences settings = context.getSharedPreferences(PREFERENCE_NAME,Context.MODE_PRIVATE); SharedPreferences.Editor editor = settings.edit(); editor.putLong(key,value); return editor.commit(); &#125; public static long getLong(Context context, String key) &#123; return getLong(context, key, -1); &#125; public static long getLong(Context context, String key, long defaultValue) &#123; SharedPreferences settings = context.getSharedPreferences( PREFERENCE_NAME, Context.MODE_PRIVATE); return settings.getLong(key, defaultValue); &#125; public static boolean putFloat(Context context, String key, float value) &#123; SharedPreferences settings = context.getSharedPreferences( PREFERENCE_NAME, Context.MODE_PRIVATE); SharedPreferences.Editor editor = settings.edit(); editor.putFloat(key, value); return editor.commit(); &#125; public static float getFloat(Context context, String key) &#123; return getFloat(context, key, -1); &#125; public static float getFloat(Context context, String key, float defaultValue) &#123; SharedPreferences settings = context.getSharedPreferences( PREFERENCE_NAME, Context.MODE_PRIVATE); return settings.getFloat(key, defaultValue); &#125; public static boolean putBoolean(Context context, String key, boolean value) &#123; SharedPreferences settings = context.getSharedPreferences( PREFERENCE_NAME, Context.MODE_PRIVATE); SharedPreferences.Editor editor = settings.edit(); editor.putBoolean(key, value); return editor.commit(); &#125; public static boolean getBoolean(Context context, String key) &#123; return getBoolean(context, key, false); &#125; public static boolean getBoolean(Context context, String key, boolean defaultValue) &#123; SharedPreferences settings = context.getSharedPreferences( PREFERENCE_NAME, Context.MODE_PRIVATE); return settings.getBoolean(key, defaultValue); &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"RandomUtils随机工具类","date":"2014-08-08T05:51:27.000Z","path":"2014/08/08/RandomUtils随机工具类/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class RandomUtils &#123; // 制定字符串范围的因子 public static final String NUMBERS_AND_LETTERS = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; public static final String NUMBERS = \"0123456789\"; public static final String LETTERS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"; public static final String CAPITAL_LETTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; public static final String LOWER_CASE_LETTERS = \"abcdefghijklmnopqrstuvwxyz\"; // 获取随机数字、字母字符串 public static String getRandomNumbersAndLetters(int length) &#123; return getRandom(NUMBERS_AND_LETTERS, length); &#125; // 获取随机数字字符串 public static String getRandomNumbers(int length) &#123; return getRandom(NUMBERS, length); &#125; // 获取英文字母组成的随机字符串 public static String getRandomLetters(int length) &#123; return getRandom(LETTERS, length); &#125; // 获取大写字母组成的随机字符串 public static String getRandomCapitalLetters(int length) &#123; return getRandom(CAPITAL_LETTERS, length); &#125; // 获取小写字母组成的随机字符串 public static String getRandomLowerCaseLetters(int length) &#123; return getRandom(LOWER_CASE_LETTERS, length); &#125; // 获取制定字符串和长度的随机字符串 public static String getRandom(String source, int length) &#123; return TextUtils.isEmpty(source) ? null : getRandom( source.toCharArray(), length); &#125; // 获取制定字符数组和长度的随机字符串 public static String getRandom(char[] sourceChar, int length) &#123; if (sourceChar == null || sourceChar.length == 0 || length &lt; 0) &#123; return null; &#125; StringBuilder str = new StringBuilder(length); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; str.append(sourceChar[random.nextInt(sourceChar.length)]); &#125; return str.toString(); &#125; // 获取0~max范围的随机int public static int getRandom(int max) &#123; return getRandom(0, max); &#125; // 获取min~max范围的随机int public static int getRandom(int min, int max) &#123; if (min &gt; max) &#123; return 0; &#125; if (min == max) &#123; return min; &#125; return min + new Random().nextInt(max - min); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"工具类","slug":"工具类","permalink":"http://seniorzhai.github.io/tags/工具类/"},{"name":"Random","slug":"Random","permalink":"http://seniorzhai.github.io/tags/Random/"},{"name":"随机","slug":"随机","permalink":"http://seniorzhai.github.io/tags/随机/"}]},{"title":"SerializeUtils","date":"2014-08-08T05:50:45.000Z","path":"2014/08/08/SerializeUtils/","text":"序列化工具类，用于序列化对象对文件或从文件反序列化对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Serialization(String filePath) &#123; public static Object deserialization(String filePath)&#123; ObjectInputStream in = null; try &#123; in = new ObjectInputStream(new FileInputStream(filePath)); Object o = in.readOject(); in.close(); return o; &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(\"FileNotFoundException occurred. \", e); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(\"ClassNotFoundException occurred. \", e); &#125; catch (IOException e) &#123; throw new RuntimeException(\"IOException occurred. \", e); &#125; finally &#123; if (in != null) &#123; try &#123; in.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(\"IOException occurred. \", e); &#125; &#125; &#125; &#125; public static void serialization(String filePath,Object obj) &#123; ObjectOutputStream out = null; try &#123; out = new ObjectOutputStream(new fileOutputStream(filePath)); out.writeObject(obj); out.close(); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(\"FileNotFoundException occurred. \", e); &#125; catch (IOException e) &#123; throw new RuntimeException(\"IOException occurred. \", e); &#125; finally &#123; if (out != null) &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(\"IOException occurred. \", e); &#125; &#125; &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"ResourceUtils","date":"2014-08-08T05:50:06.000Z","path":"2014/08/08/ResourceUtils/","text":"工具类，用于读取资源目录下的内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ResourceUtils &#123; // 读取assets目录下某个文件内容 public static String getFileFromAssets(Context context,String fileName)&#123; if(context == null || TextUils.isEmpty(fileName)) &#123; return null; &#125; StringBuilder s = new StringBuilder(\"\"); try &#123; InputStreamReader in = new InputStreamReader(context.getResources().getAssets().open(fileName)); BufferedReader br = new BufferedReader(in); String line; while ((line = br.readLine()) != null)&#123; s.append(line); &#125; return s.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; // 读取raw目录下某个文件内容 public static String getFileFromRaw(Context context,int resId) &#123; if (context == null) &#123; return null; &#125; StringBuilder s = new StringBuilder(); try &#123; InputStreamRead in = new InputStreamReader(context.getResources().openRawResource(resId)); BufferedReader br = new BufferedReader(in); String line; while ((line = br.readLine() != null))&#123; s.append(line); &#125; return s.toString(); &#125; catch (IOException e) &#123; e.printStatckTrace(); return null; &#125; &#125; public static List&lt;String&gt; getFileToListFromAssets(Context context,String fileName) &#123; if (context == null || TextUtils.isEmpty(fileName)) &#123; return null; &#125; List&lt;String&gt; fileContent = new ArrayList&lt;String&gt;(); try &#123; InputStreamReader in = new InputStreamReader(context.getResouces().getAssets().open(fileName)); BufferedReader br = new BufferedReader(in); String line; while((line = br.readLine() != null)) &#123; fileContent.add(line); &#125; br.close(); return fileContent; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125; public static List&lt;String&gt; getFileToListFromRaw(Context context,int resId) &#123; if (context == null) &#123; return null; &#125; List&lt;String&gt; fileContent = new ArrayList&lt;String&gt; (); BufferedReader reader = null; try &#123; InputStreamReader in = new InputStreamReader(context.getResouces().openRawResource(resId)); reader = new BufferedReader(in); String line = null; while((line = reader.readLine()) != null)&#123; fileContent.add(line); &#125; reader.close(); return fileContent; &#125; catch (IOException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"SockMonitor和小米助手配合抓包","date":"2014-08-08T05:49:32.000Z","path":"2014/08/08/SockMonitor和小米助手配合抓包/","text":"SockMonitor可以捕捉PC上进程的网络访问，小米助手可以为小米手机USB共享网络提供，其实可以设置IP代理的方法，但是直接这样太方便了。 设置连接手机后设置共享网络，注意断开手机的3G、wifi信号在防火墙中-&gt;允许程序或功能通过Windows防火墙-&gt;将ScockMonitor添加到其中 过滤在ScockMoniter中设置过滤器通过限制MiPoneManager这个进程就可以只抓取手机网络访问数据在限定IP即可抓取指定IP的数据","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"CursorLoader","date":"2014-08-07T05:48:36.000Z","path":"2014/08/07/CursorLoader/","text":"从ContentProvider查询数据比较耗时，在UI线程中查询可能会ANR，通过CursorLoader来实现，异步查询数据。 使用CursorLoader依靠ContentProvider在后台执行一个异步的查询操作，并且返回数据给调用它的Activity或者Fragment。 定义使用CursorLoader的Activity必须实现LoaderCallbacks接口，CursorLoader会触发这些回调方法。 123public class OtherFragment extends FragmentActivity implements LoaderManager.LoaderCallback&lt;Cursor&gt;&#123; ...&#125; 初始化查询为了初始化查询，需要执行LoaderManager.initLoader()初始化后台任务。可以在onCreate()或者onCreateView()中触发这个方法。 1getLoaderManager().initLoader(1,null,this); // 第一个参数为标志 第二个为可选的参数供Loader构造 第三个为Loader接口 注：getLoaderManager()只能在Fragment类中调用，在FragmentActicity中应该使用getSupportLoaderManager() 开始查询一旦初始化完成，它会回调onCreateLoader()方法。为了启动查询任务，在这个方法需要返回CursorLoader12345678910@Overridepublic Loader&lt;Cursor&gt; onCreateLoader(int loaderId,Bundle bundle)&#123; switch(loaderID) &#123; case URL_LOADER: // 设置的标示符 return cursorLoader; break; default: return null; &#125;&#125; 一旦获取查询任务的Loader对象，就会开始在后台查询任务，当查询完成之后，就会执行onLoadFinished()回调函数。 处理查询onLoadFinished()参数之一是Cursor，包含了查询的数据12345@Overridepublic void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; // 通知Adapter更改数据 mAdapter.changeCursor(data);&#125; 在Cursor失效时，CursorLoader会被重置，通常会发生在Cursor相关的数据改变的时候，在重新执行查询操作之前，系统会执行onLoaderReset()方法。在这个方法中，应该删除当前Cursor上的所有数据，避免发生内存泄露。12345@Overridepublic void onLoaderReset(Loader&lt;Cursor&gt; loader) &#123; // mAdapter.changeCursor(null);&#125;","tags":[{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://seniorzhai.github.io/tags/ContentProvider/"},{"name":"CursorLoader","slug":"CursorLoader","permalink":"http://seniorzhai.github.io/tags/CursorLoader/"}]},{"title":"加密工具类","date":"2014-08-06T05:48:01.000Z","path":"2014/08/06/加密工具类/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class CipherUtil &#123; private final static String[] hexDigits = &#123;\"0\", \"1\", \"2\", \"3\", \"4\",\"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"&#125;; public static String generatePassword(String inputString)&#123; return encodeByMD5(inputString); &#125; // 判断是否与处理后的加密码匹配 public static boolean validatePassword(String password,String inputString)&#123; if(password.equals(encodeByMD5(inputString))&#123; return true; &#125; else &#123; return false; &#125; &#125; private static String encodeByMD5(String originString)&#123; if (originString != null) &#123; try&#123; // 创建指定算法获取信息摘要 MessageDigest md = MessageDigest.getInstance(\"MD5\"); // 获取字符串的照耀 byte[] results = md.digest(originString.getBytes()); String resultString = byteArrayToHexString(result); return resultString.toUpperCase(); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; // byte[] -&gt; String private static String byteArrayToHexString(byte[] b) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++)&#123; resultSb.append(byteToHexString(b[i])); &#125; return resultSb.toString(); &#125; // byte -&gt; String private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n = 256 + n; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"工具类","slug":"工具类","permalink":"http://seniorzhai.github.io/tags/工具类/"},{"name":"加密","slug":"加密","permalink":"http://seniorzhai.github.io/tags/加密/"}]},{"title":"Camera","date":"2014-08-06T05:47:24.000Z","path":"2014/08/06/Camera/","text":"自定义Camera需要添加CAMERA权限 1&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt; 通过Camera静态open方法访问摄像头 1Camera camera = Camera.open(); 使用完成后调用release方法来释放它1camera.release(); 摄像头属性通过Camera对象的getParameters方法可以得到Camera.Parameters对象来对摄像头进行设置Anroid 2.2引入getFocalLength和get[Horizontal/Vertical]方法分别可以得到焦距和相关水平和垂直视角Android 2.3引入getFocusDistances方法，用于估算镜头和当前被对焦的物体之间的距离，该方法并不返回值，而是填充一个与近、远和最佳距离对应的浮点数组，对焦中最清晰的物体位于最佳位置1234567float[] focusDistances = new float[3];paramerters.getFocusDistance(focusDistance);float near = focusDistances[Camera.Parameters.FOCUS_DISTANCE_NEAR_INDEX];float far = focusDistance[Camera.Parameters.FOCUS_DISTANCE_FAR_INDEX];float optimal = focusDistance[Camera.Parameters.FOCUS_DISTANCE_OPTIMAL_INDEX]; 通过使用set*方法来修改Parameters参数 [get/set]SceneMode 使用一个SCENE_MODE_*的常量设置所拍摄场景的类型。 [get/set]FlashMode 使用一个FLASH_MODE_*常量设置闪光模式（通常为“打开”、“关闭”、“红眼消除”、“闪光灯”模式） [get/set]WhiteBalance 使用一个WHITE_BALANCE_*常量设置白平衡校正来校正场景。在设置白平衡之前，可以使用getSupportedWhiteBalance方法来确认哪些设置可用 [get/set]AutoWhiteBalanceLock Android 4.0引入，使用自动白平衡算法，会暂停颜色校正算法。使用isAutoWhiteBalancLockSupported方法确认设备是否支持这种功能 [get/set]ColorEffect 使用EEFECT_*常量舍hi特殊颜色效果，使用getColorEffect可以找到可用的颜色效果 [get/set]FocusMode 使用FOCUSMODE*常量设置摄像头尝试对焦的方式（连续自动对焦在Android 4.0中引入）使用getSupportedFocusModes方法可以找出可用的模式。 [get/set]Antibanding 使用ANTIBANDING_*常量设置降低条带效果的屏幕刷新频率。 JPEG和缩略图质量 使用setJpegQuality和setJpegThumbnailQuality方法，并传入0到100之间的证书设置图像质量 图像、预览和缩略图大小 分别使用setPictureSize、setPreviewSize和setJpegThumbnailSize方法制定图像、预览和缩略图的高度和宽度。使用getSupportedPictureSize、getSupportedPreviewSizes和getSupportededJpegThumbnailSize方法来确定有效值，返回Camera.Size对象的列表。 图像和预览像素格式 使用PixelFormat类的静态常量调用setPictyreFormat和setPreviewFormat设置图像的格式。在使用getSupportedPictureFormats和getSupportedPreviewFormats方法返回支持的格式的一个列表。 预览帧速率 setPreviewFpsRange方法取代了弃用的setPreviewFpsRangeFrameRate（Android 2.3）指定预览的首选帧率范围。使用getSupportedPreviewFpsRange方法可以找出支持的最低和最高帧率。 控制自动对焦、对焦区域和测光区域123456789Camera.Parameters parameters = camera.getParameters();if(parameters.getSupportedFocusModes().contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) &#123; parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE); camera.autoFocus(new Auto FocusCallback()&#123; public void onAutoFocus(boolean success,Camera camera)&#123; // &#125; &#125;)；&#125; Android 4.0引入两个对焦的API，用于在对焦图像或者确定场景的白平衡和亮度时指定对焦区域和侧光区域。使用getMaxNumFocusAreas方法来确定设备是否支持该功能，返回值为检测到的最大对焦区域，如果为0，表示设备不支持定义对焦区域。定义对焦区域使用setFocusAreas方法，传入一个Camera.Area对象的了表。使用setMeteringAreas以同样的方式设置侧光区域。 使用摄像头预览不显示一个预览，食物无法使用Camera对象拍摄照片的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class CameraActivity extends Activity implements SufaceHolder.Callback &#123; private static final String TAG = \"CameraActivity\"; private Camera camera; @Override public void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.main); SufaceView surface = (SurfaceView)findViewById(R.id.surfaceView); SufaceHolder holder = surface.getHolder(); holder.addCallback(this); holder.setType(SurfaceHolder.SUREFACE_TYPE_PUSH_BUFFERS); holder.setFixed(400,300); &#125; public void surfaceCreated(SurfaceHolder holder)&#123; try&#123; camera.setPreviewDisplay(holder); camera.startPreview(); &#125; catch (IOException e) &#123; // &#125; &#125; public void surfaceDestroyed(SurfaceHolder holder)&#123; camera.stopPreview(); &#125; public void surfaceChanged(SurfaceHolder holder,int format,int width,int height) &#123; &#125; @Override protected void onPaues()&#123; super.onPause(); camera.release(); &#125; @Override protected void onResume()&#123; super.onResume(); camera = Camera.open(); &#125;&#125; 调用camera的setPreviewCallback方法传入PreviewCallback，监听每个预览帧12345678910camera.setPreviewCallback(new PreviewCallback()&#123; public void onPreviewFrame(byte[] data,Camera camera) &#123; int quality = 60; Size[] previewSize = camera.getParameters().getPreviewSize(); YuvImage iamge = new YuvImage(data,ImageFormat.NV21,previewSize.width,previewSize.height,null); ByteArrayOutStream outputStream = new ByteArrayOutStream(); image.compressToJpeg(new Rect(0,0,previewSize.width,previewSize.height),quality,outputStream); &#125;&#125;);","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Loader机制","date":"2014-08-04T05:46:59.000Z","path":"2014/08/04/Loader机制/","text":"LoaderManager 一个与Activity和Fragment有关联的抽象类，用于管理一个或多个Loader实例。每个Activity或Fragment只能有一个LoaderManager。 LoaderManager.LoaderCallbacks 提供了客户端的一个callback接口，用于和LoaderManager进行交互。 AsyncTaskLoader 一个抽象Loader，提供了一个AsyncTask进行工作 CursorLoader AsyncTaskLoader的子类，用于向ContentResover请求，返回一个Cursor。 使用LoaderManagerCallbacksLoaderManager.LoaderCallbacks是callback接口，包含三个方法： onCreateLoader() — 实例化和返回一个新创建的给定ID的loader onLoadFinished() — 当一个创建好的loader完成了load,调用此函数 onLoaderReset() — 当一个创建好的loader要被reset时，调用此函数","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"友盟用户反馈","date":"2014-08-04T05:46:16.000Z","path":"2014/08/04/友盟用户反馈/","text":"添加jar包及资源文件下载SDK，将jar包添加到libs目录下，res文件合并到自己的目录下。 配置AndroidManifest.xml打开AndroidManifest.xml, 在标签中添加Activity, APPKEY, 和权限 12345678910111213141516&lt;manifest……&gt; &lt;application ……&gt; &lt;activity android:name=\"com.umeng.fb.ConversationActivity\" android:theme=\"@android:style/Theme.NoTitleBar\"/&gt; &lt;activity android:name=\"com.umeng.fb.ContactActivity\" android:theme=\"@android:style/Theme.NoTitleBar\"/&gt; &lt;meta-data android:value=\"YOUR_APP_KEY\" android:name=\"UMENG_APPKEY\"&gt;&lt;/meta-data&gt; &lt;meta-data android:value=\"Channel ID\" android:name=\"UMENG_CHANNEL\"/&gt; &lt;/application&gt; &lt;uses-sdk android:minSdkVersion=\"4\"&gt;&lt;/uses-sdk&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;/manifest&gt; 调用代码 12FeedbackAgent agent = new FeedbackAgent(context); agent.startFeedbackActivity();","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"GsonRequest","date":"2014-08-03T05:45:25.000Z","path":"2014/08/03/GsonRequest/","text":"利用Gson和Volley实现URL读取JSON数据转model类1234567891011121314151617181920212223242526272829303132333435GsonRequest&lt;T&gt; extends Request&lt;T&gt; &#123; private final GSON gson = new Gson(); private final Class&lt;T&gt; clazz; private final Map&lt;String,String&gt; headers; private final Listener&lt;T&gt; listener; public GsonRequest(String url,Class&lt;T&gt; clazz,Map&lt;String,String&gt; headers,Listener&lt;T&gt; listener,ErrorListener errorListener)&#123; super(Method.GET,url,errorListener); this.clazz = clazz; this.headers headers; this.listener = listener; &#125; @Override public Map&lt;String,String&gt; getHeaders() throws AuthFailureError &#123; return headers != null ? headers : super.getHeaders(); &#125; @Override protected void deliverResponse(T response) &#123; listener.onResponse(response); &#125; @Override protected Response&lt;T&gt; parseNetworkResponse(NetWorkResponse response) &#123; try &#123; String json = new String(response.data,HttpHeaderParser.parseCharset(response.headers)); return Response.success(gson.fromJson(json,clazz),HttpHeaderParser.parseCacheHeaders(response)); &#125; catch (UnsupportedEncodingException e) &#123; return Response.error(new ParseError(e)); &#125; catch (JsonSyntaxException e) &#123; return Response.error(new ParseError(e)); &#125; &#125;&#125; 使用 创建executeRequest方法 123void executeRequest(Request request) &#123; RequestManager.addRequest(request, this);&#125; 调用请求 1executeRequest(new GsonRequest&lt;Model&gt;(url,Model.class,null,listener,errorListner); 在listener中处理数据 123456new Listner&lt;Moderl&gt;()&#123; @Override public void onResponse(final Model requestData) &#123; // &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"友盟自动更新","date":"2014-08-01T05:44:56.000Z","path":"2014/08/01/友盟自动更新/","text":"1.导入SDK所需jar包下载SDK的自拍包，将libs中的文件添加到libs中 2.添加资源将SDK包中的res文件夹中的资源添加到res目录中，友盟的资源文件全以umeng_开头 3.配置AndroidManifest.xml在&lt;manifest&gt;标签下添加权限12345678&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\"&gt;&lt;/uses-permission&gt;``` 在`&lt;application&gt;`标签下添加`APPKEY`，其中Channel为推广渠道```xml&lt;meta-data android:value=\"YOUR APP KEY\" android:name=\"UMENG_APPKEY\"/&gt;&lt;meta-data android:value=\"Channel ID\" android:name=\"UMENG_CHANNEL\"/&gt; 在&lt;application&gt;标签下添加Service和Activity12345678&lt;service android:name=\"com.umeng.update.net.DownloadingService\" android:process=\":DownloadingService\" &gt;&lt;/service&gt;&lt;activity android:name=\"com.umeng.update.UpdateDialogActivity\" android:theme=\"@android:style/Theme.Translucent.NoTitleBar\" &gt;&lt;/activity&gt; 4.调用更新接口1234public void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); UmengUpdateAgent.update(this);&#125; 默认只在wifi条件下弹出更新，调用UmengUpdateAgent.setUpdateOnlyWifi(false)关闭。 5. 上传最新的APK上传位置：登录友盟开发者后台，在左上角选择应用后，右边可以看到统计分析、组件、管理三部分。点击组件，左侧就会出现自动更新条目。请点击进入，即可找到上传的入口。友盟根据客户端的版本号来判断新旧(VersionCode)。 6. 集成检测v2.4版本以后的SDK中默认开启了集成检测功能，在调用任意的更新接口后，我们将替您自动检查上述集成过程中2、3两个步骤是否被正确完成。 如果正确完成不会出现任何提示，否则会以如下的toast提示您。你可以通过调用UmengUpdateAgent.setUpdateCheckConfig(false)来禁用此功能。 toast的含义如下：“Please copy all resources (res/) from SDK to your project!”：请检查是不是把res文件夹下所有的资源文件都放到了工程中。“Please add Permission in AndroidManifest!”：请检查上述步骤3.1中的相关权限是否正确添加。“Please add Activity in AndroidManifest!”：请检查上述步骤3.3中的Activity是否正确添加。“Please add Service in AndroidManifest!”：请检查上述步骤3.3中的Service是否正确添加。“Please set umeng appkey!”：请检查上述步骤3.2中的APPKEY是否正确添加。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Markdown小技巧","date":"2014-08-01T02:46:30.000Z","path":"2014/08/01/Markdown小技巧/","text":"Markdown删除线和插入视频和音乐的方法 删除线使用~~包括文本，使得文本有删除线的效果这是错误的文本 视频嵌入视频的方法和音乐类似，视频网站每个视频页面都会有一个『分享』或『转帖』按钮，点击可以查看代码。1&lt;embed src=\"http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"&gt;&lt;/embed&gt; ## 音乐以『虾米音乐』为例，歌曲页面有个『转帖』选项，将html代码或javascript代码复制到文中即可。1&lt;embed src=\"http://www.xiami.com/widget/0_1773340641/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"&gt;&lt;/embed&gt;","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://seniorzhai.github.io/tags/Markdown/"}]},{"title":"MD小技巧","date":"2014-08-01T02:46:30.000Z","path":"2014/08/01/MD小技巧/","text":"音乐以『虾米音乐』为例，歌曲页面有个『转帖』选项，将html代码或javascript代码复制到文中即可。1&lt;embed src=\"http://www.xiami.com/widget/0_1773340641/singlePlayer.swf\" type=\"application/x-shockwave-flash\" width=\"257\" height=\"33\" wmode=\"transparent\"&gt;&lt;/embed&gt; 视频嵌入视频的方法和音乐类似，视频网站每个视频页面都会有一个『分享』或『转帖』按钮，点击可以查看代码。1&lt;embed src=\"http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"&gt;&lt;/embed&gt;","tags":[{"name":"Prose","slug":"Prose","permalink":"http://seniorzhai.github.io/tags/Prose/"}]},{"title":"Action Bar选项","date":"2014-07-30T05:44:23.000Z","path":"2014/07/30/Action-Bar选项/","text":"showAsAction always:一直显示在Action Bar上 isRoom:如果有足够空间，这个值就会显示在Action Bar上 nerver:永远不会出现在Action Bar上 withText:起显示文本标题 collapse:声明了这个操作视窗应该被折叠到一个按钮中，当用户选择这个按钮时，这个操作视窗展开。否则，这个操作视窗在默认的情况下是可见的，并且即便在用于不适用的时候，也要占据操作栏的有效空间。一般要配合ifRoom一起使用才会有效果。隐藏域显示12actionBar.hide();actionBar.show(); Action 下拉导航、视窗导航、标签导航 下拉导航 初始化一个SpinnerAdapter 1SpinnerAdapter mSpinnerAdapter = ArrayAdapter.createFromResource(this,R.array.action_list,android.R.layout.simple_spinner_dropdown_item); 生成一个OnNavigationListener来响应ActionBar的菜单项点击操作 1234567891011121314151617181920212223OnNavigationListener mOnNavigationListener = new OnNavigationListener() &#123; @Override public boolean onNavigationItemSelected(int position, long itemId) &#123; Fragment newFragment = null; switch (position) &#123; case 0: newFragment = new Fragment1(); break; case 1: newFragment = new Fragment2(); break; case 2: newFragment = new Fragment3(); break; default: break; &#125; getSupportFragmentManager().beginTransaction() .replace(R.id.container, newFragment, strings[position]) .commit(); return true; &#125; &#125;; 绑定适配器和监听器到ActionBar 1234actionBar = getActionBar(); actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);//导航模式必须设为NAVIGATION_MODE_LIST actionBar.setListNavigationCallbacks(mSpinnerAdapter, mOnNavigationListener); 视窗模式 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;item android:id=\"@+id/menu_search\" android:actionViewClass=\"android.widget.SearchView\" android:icon=\"@drawable/ic_menu_search\" android:showAsAction=\"ifroom\" android:title=\"搜索\"/&gt; &lt;item android:id=\"@+id/menu_share\" android:actionProviderClass=\"android.widget.ShareActionProvider\" android:showAsAction=\"never\" android:title=\"分享\"/&gt; &lt;item android:id=\"@+id/menu_setting\" android:actionProviderClass=\"com.example.tabdemo.MyActionProvider\" android:showAsAction=\"never\" android:title=\"设置\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/menu_theme\" android:actionProviderClass=\"com.example.tabdemo.MyActionProvider\" android:showAsAction=\"always|withText\" android:title=\"更换主题\"/&gt; &lt;item android:id=\"@+id/menu_system\" android:actionProviderClass=\"com.example.tabdemo.MyActionProvider\" android:showAsAction=\"always|withText\" android:title=\"系统设置\"/&gt; &lt;/menu&gt; &lt;/item&gt; &lt;/menu&gt; actionProviderClass:指定一个构建视图所使用的布局资源，还可以使用actionLayout或者actionViewClass。 1234567891011121314151617getMenuInflater().inflate(R.menu.options, menu); //搜索视窗，因为showAsAction=\"ifRoom\"，所以图三中出现了搜索按钮 SearchView searchView = (SearchView) menu.findItem(R.id.menu_search) .getActionView(); //分享视窗，因为showAsAction=\"never\"，所以只能在溢出菜单中才看见到 ShareActionProvider mShareActionProvider = (ShareActionProvider) menu .findItem(R.id.menu_share).getActionProvider(); Intent shareIntent = new Intent(Intent.ACTION_SEND); shareIntent.setType(\"image/*\"); mShareActionProvider.setShareIntent(shareIntent); //设置视窗，MyActionProvider就是我们自定义的ActionProvider MyActionProvider myactionprovider = (MyActionProvider) menu.findItem( R.id.menu_setting).getActionProvider(); return super.onCreateOptionsMenu(menu); 实现自定义MyActionProvider123456789101112131415161718192021222324252627282930public class MyActionProvider extends ActionProvider&#123; private Context context; private LayoutInflater inflater; private View view; private ImageView button; public MyActionProvider(Context context) &#123; super(context); // TODO Auto-generated constructor stub this.context = context; inflater = LayoutInflater.from(context); view = inflater.inflate(R.layout.myactionprovider, null); &#125; @Override public View onCreateActionView() &#123; // TODO Auto-generated method stub button = (ImageView) view.findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Toast.makeText(context, \"是我，没错\", Toast.LENGTH_SHORT).show(); &#125; &#125;); return view; &#125; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"判断ListView是否在顶端或者在底部","date":"2014-07-30T05:43:44.000Z","path":"2014/07/30/判断ListView是否在顶端或者在底部/","text":"12345678910111213141516listView.setOnScrollListener(new OnScrollListener()&#123; @Override public void onScrollStateChanged(AbsListView view,int scrollState)&#123; &#125; @Override public void onScoll(AbsListView view,int firstVisibleItem,int visibleItemCount,int totallItemCout)&#123; if(firstVisibleItem == 0)&#123; // 滑到顶部 &#125; if(visibleItemCount+firstVisibleItem == totalItemCount) &#123; // 滑到底部 &#125; &#125;&#125;)","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android Animation","date":"2014-07-21T05:42:57.000Z","path":"2014/07/21/Android-Animation/","text":"Android 3.0(Honeycomb)之前，Android支持两种动画tween animation,frame animation，3.0引入了一个新的动画————property animation。可通过NineOldAndroids实现对低版本的支持。 View Animation(Tween Animation)补间动画给出两个关键帧，通过一些算法将给定属性值在给定的时间内在两个关键帧间渐变。View Animation只能应用于View对象，而且只支持一部分属性，如支持缩放旋转不支持背景颜色的改变。ViewAnimation就是一系列View形状的变换，如大小的缩放、透明度的改变、位置的改变，动画的定义既可以用代码定义也可以使用XML定义。用XML定义的动画在/res/anim/文件夹内，XML文件的根元素可以是,,,和,。默认情况下，所有动画是同时进行的，可以通过startOffset属性设置哥哥动画的开始偏移量来达到动画顺序播放的效果。可以设置属性改变动画的渐变效果，如AccelerateInterpolator，开始时慢，然后逐渐加快。12Animation hyperspaceJumpAnimation=AnimationUtils.loadAnimation(this, R.anim.hyperspace_jump);spaceshipImage.startAnimation(hyperspaceJumpAnimation); Drawable Animation(Frame Animation)Drawable Animation(Frame Animation)帧动画，通过一系列Drawable依次显示来模拟动画123456&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"true\"&gt; &lt;item android:drawable=\"@drawable/rocket_thrust1\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/rocket_thrust2\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/rocket_thrust3\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; 必须以为根元素，以表示要轮换显示的图片，duration属性表示各项显示的时间，XML文件要放在/res/drawable/目录下。12345imageView.setBackgroundResource(R.drawable.drawable_anim);anim = (AnimationDrawable) imageView.getBackground();anim.stop()anim.start() Property Animation属性动画 Duration:动画的持续时间 TimeInterpolation:属性值的计算方式，比如先快后慢 TypeEvaluator:根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值。 Repeat Count and behavoir:重复次数与方式，比如播放3次、5次、无限循环，可以一直重复或播放完再反向播发 Animation Sets:动画集合，即可以同时对一个对象应用几个动画，这些动画可以同时播放也可以对不同动画设置不同时间开始偏移 Frame refreash delay:多少时间刷新一次，即每隔多少时间计算一次属性值，默认是10ms，最终刷新时间还受到系统进程调度与硬件的影响 Property Animation的工作方式这面的动画该对象在40ms在x轴移动40pixel。默认10ms刷新一次，这个对象移动了4次，每次移动40/4=10pixel 也可以改变属性值的改变方法，设置不同的interpolation，比如下图运动的速度逐渐增大后再逐渐减小 下图显示了与上述动画相关的关键对象 ValueAnimator表示一个动画，包含动画的开始值、结束值、持续时间等属性ValueAnimator封装了一个TimeInterpolator，定义了属性在开始值与结束值之间的插值计算方法ValueAnimator还封装了一个TypeAnimator，根据开始值、结束值与TimeIniterpolator计算得到的值计算出属性值ValueAnimator根据动画已进行的时间跟动画总时间（duration）的比计算出一个时间因子（0~1），然后根据TimeInterpolator计算出另一个因子，最后TypeAnimator通过这个因子计算出属性值，如上例中10ms时：首先计算出时间因子，即经过的时间百分比：t=10ms/40ms=0.25经插值计算(inteplator)后的插值因子:大约为0.15，上述例子中用了AccelerateDecelerateInterpolator，计算公式为（input即为时间因子）：1(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f; 最后根据TypeEvaluator计算出在10ms时的属性值：0.15*（40-0）=6pixel。上例中TypeEvaluator为FloatEvaluator，计算方法为 ：1234public Float evaluate(float fraction, Number startValue, Number endValue) &#123; float startFloat = startValue.floatValue(); return startFloat + fraction * (endValue.floatValue() - startFloat);&#125; ValueAnimatorValueAnimator包含Property Animation动画的所有核心功能，如动画时间，开始、结束属性值，相应时间属性值计算方法等。应用Property Animation有两个步聚： 计算属性值 根据属性值执行相应的动作，如改变对象的某一属性。 ValuAnimiator只完成了第一步工作，如果要完成第二步，需要实现ValueAnimator.onUpdateListener接口，这个接口只有一个函数onAnimationUpdate()，在这个函数中会传入ValueAnimator对象做为参数，通过这个ValueAnimator对象的getAnimatedValue()函数可以得到当前的属性值如：12345678910ValueAnimator animation = ValueAnimator.ofFloat(0f,1f);animation.setDuration(1000);animation.addUpdateListener(new AnimatorUpdateListener()&#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; Log.i(\"update\",((Float)animation.getAnimatedValue()).toString()); &#125;&#125;);animation.setInterpolator(new CycleInterpolator(3));animation.start(); onAnimationUpdate()通过监听这个事件的值更新时执行的操作，对ValueAnimation一般要监听此事件执行相应的动作，不然则没有意义。ObjectAnimator中会自动更新属性，如无必要不必监听。在函数中会传递一个ValueAnimator参数，通过此参数的getAnimatedValue()取得当前动画属性值。AnimatorListener用于监听动画的执行过程，有如下一些回调方法1234onAnimationStart()onAnimationEnd()onAnimationRepeat()onAnimationCancel() 可以继承AnimatorListenerAdapter而不是实现AnimatorListener接口来简化操作，这个类对AnimatorListener中的函数都定义了一个空函数体，这样我们就只用定义想监听的事件而不用实现每个函数却只定义一空函数体。12345678ObjectAnimator oa = ObjectAnimator.ofFloat(tv,\"alpha\",0f,1f);oa.setDuration(3000);oa.addListener(new AnimatorListenerAdapter()&#123; public void on AnimationEnd(Animator animation)&#123; Log.i(\"Animation\",\"end\"); &#125;&#125;);oa.start(); ObjectAnimator继承自ValueAnimator，要指定一个对象即带对象的一个属性，当属性值计算完成时，自动设置为该对象的相应属性。使用ObjectAnimator，需要满足下面条件 对象应该有一个setter函数 创建时，使用工厂方法，第一个参数是对象名，第二个为属相名，后面的参数为可变参数，只设置一个值为目的值，属性值的变化范围为当前值到目的值，为了获得当前值，对象必须有相应的getter方法 getter方法与其setter方法返回类型一致12345678910tv=(TextView)findViewById(R.id.textview1);btn=(Button)findViewById(R.id.button1);btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; ObjectAnimator oa=ObjectAnimator.ofFloat(tv, \"alpha\", 0f, 1f); oa.setDuration(3000); oa.start(); &#125;&#125;); View对象属性： translationX和translationY:增量位置，View从它布局容器的左上角坐标开始的位置 rotation、rotationX和ratationY:这三个属性控制View对象围绕支点进行2D和3D的旋转。 scaleX、scaleY:控制对象围绕其支点进行2D缩放 pivotX、pivotY:控制支点的位置，默认为View对象的中心点 x、y:控制View对象在它容器中的最终位置 alpha:View对象的透明度，默认为1(不偷明)，0代表完全透明通过AnimationSet应用多个动画AnimationSet提供一个把多个动画组合成一个组合的机制，并可以设置组中动画的时序关系。1234567// anim1播发完，同时播发anim2、anim3、anim4，之后播发anim5AnimationSet bouncer = new AnimatorSet();bouncer.play(anim1).before(anim2);bouncer.play(anim2).with(anim3);bouncer.play(anim2).with(anim4);bouncer.play(anim4).with(anim2);bouncer.start(); TypeEvalutors根据属性的开始值、结束值与TimeInterpolation计算出的计算因子计算出当前时间的属性值，Android提供方了以下几个evalutor： IntEvaluator:属性的值为int FloatEvaluator：属性的值为float ArgbEvaluator:属性值为十六进制颜色值 TypeEvaluator:一个接口，可以通过实现该接口自定义Evaluator自定义TypeEvalutor很简单，只需要实现一个方法123456public class FloatEvaluator implements TypeEvaluator &#123; public Object evaluate(float fraction,Object startValue,Object endValue) &#123; float startFloat = ((Number)startValue).floatValue(); return startFloat + fraction * (((Number) endValue).floatValue() - startFloat(); &#125;&#125; TimeInterplatorTime interplator定义了属性值变化的方式，在Property Animation中是TimeInterplator，在View Animation中是Interplator，这两个是一样的，在3.0之前只有Interplator，3.0之后实现代码转移至了TimeInterplator。Interplator继承自TimeInterplator，内部没有任何其他代码。 AccelerateInterpolator 加速，开始时慢中间加速 DecelerateInterpolator 减速，开始时快然后减速 AccelerateDecelerateInterolator 先加速后减速，开始结束时慢，中间加速 AnticipateInterpolator 反向 ，先向相反方向改变一段再加速播放 AnticipateOvershootInterpolator 反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值 BounceInterpolator 跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100 CycleIinterpolator 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 mCycles Math.PI * input) LinearInterpolator 线性，线性均匀改变 OvershottInterpolator 回弹，最后超出目的值然后缓慢改变到目的值 TimeInterpolator 一个接口，允许你自定义interpolator，以上几个都是实现了这个接口Layout改变时应用动画ViewGroup中的子元素可以通过setVisibility使其Visible、Invisible或Gone，当有子元素可见性改变时(VISIBLE、GONE)，可以向其应用动画，通过LayoutTransition类应用此类动画：1transition.setAnimator(LayoutTransition.DISAPPEARING,customDisappearingAnim); 通过setAnimator应用动画，第一个参数表示应用环境，第二个参数是一个动画，环境可以是以下4种: APPEARING 当一个元素在其父元素中变为Visible时对这个元素应用动画 CHANGE_APPEARING 当一个元素在其父类中变为Visible时，因系统要重新布局有一些元素需要移动，对这些要移动的元素应用动画 DISAPPEARING 当一个元素在其父元素中变为GONE时对其应用动画 CHANGE_DISAPPEARING 当一个元素在其父元素中变为GONE时，因系统要重新布局有一些元素需要移动，这些要移动的元素应用动画1mTransitioner.setStagger(LayoutTransition.CHANGE_APPEARING, 30); 此函数设置动画延迟时间，参数分别为类型与时间。 KeyframeskeyFrame是一个时间/值对，通过它可以定义一个在特定时间的特定状态，即关键帧，而且在两个keyFrame之间可以定义不同的Interpolator，就像多个动画的拼接，第一个动画的结束点是第二个动画的开始点，KeyFrame是一个抽象类，要通过ofInt()、ofFloat()、ofObject()获得适当的KeyFrame，然后通过PropertyValuesHolder.ofKeyframe获得PropertyValueHolder对象，如下例子：12345678Keyframe kf0 = Keyframe.ofInt(0, 400);Keyframe kf1 = Keyframe.ofInt(0.25f, 200);Keyframe kf2 = Keyframe.ofInt(0.5f, 400);Keyframe kf4 = Keyframe.ofInt(0.75f, 100);Keyframe kf3 = Keyframe.ofInt(1f, 500);PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(\"width\", kf0, kf1, kf2, kf4, kf3);ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn2, pvhRotation);rotationAnim.setDuration(2000); 上述代码设置了btn对象的width属性值： 开始动画时，width=400 开始动画1/4时，width=200 开始动画1/2时，width=400 开始动画3/4时，width=100 结束动画时,width=500第一个参数是时间百分比，第二个参数是在第一个参数时间点的属性值定义了一些Keyframe后，通过PropertyValuesHolder类的方法ofKeyframe一个PropertyValuesHolder对象，然后通过ObjectAnimator.ofPropertyValuesHolder获得一个Animator对象。用下面的代码可以实现同样的效果（上述代码时间值是线性，变化均匀）：123ObjectAnimator oa = ObjectAnimator.ofInt(btn2,\"width\",400,200,400,100,500);oa.setDuration(2000);oa.start(); Animating Views","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"RelativeLayout常见属性介绍","date":"2014-07-17T05:41:25.000Z","path":"2014/07/17/RelativeLayout常见属性介绍/","text":"第一类:属性值为true或false 属性 说明 android:layout_centerHrizontal 水平居中 android:layout_centerVertical 垂直居中 android:layout_centerInparent 相对于父元素完全居中 android:layout_alignParentBottom 贴紧父元素的下边缘 android:layout_alignParentLeft 贴紧父元素的左边缘 android:layout_alignParentRight 贴紧父元素的右边缘 android:layout_alignParentTop 贴紧父元素的上边缘 android:layout_alignWithParentIfMissing 如果对应的兄弟元素找不到的话就以父元素做参照物 第二类：属性值必须为id的引用名“@id/id-name” 属性 说明 android:layout_below 在某元素的下方 android:layout_above 在某元素的的上方 android:layout_toLeftOf 在某元素的左边 android:layout_toRightOf 在某元素的右边 android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐 android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐 android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐 android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐 第三类：属性值为具体的像素值，如30dip，40px 属性 说明 android:layout_marginBottom 离某元素底边缘的距离 android:layout_marginLeft 离某元素左边缘的距离 android:layout_marginRight 离某元素右边缘的距离 android:layout_marginTop 离某元素上边缘的距离","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Handler","date":"2014-07-17T05:40:50.000Z","path":"2014/07/17/Handler/","text":"Handler直接继承Object，一个Handler允许发送和处理一个Message或者Runnable对象，并且会关联到主线程的MessageQueue中。没个Handler具有一个单独的线程，并且关联到一个消息对象的线程，就是说一个Handler有一个固定的消息队列。Handler主要有两个作用： 在工作线程中发送消息 在UI线程中获取、处理消息 Handler把压入消息队列分为Post和sendMessage: Post：Post运行把一个Runnable对象压入消息队列，它的方法有：post(Runnable)、postAtTime(Runnable,long)、postDelayed(Runnable,long)。 sendMessage:sendMessage允许把一个包含消息数据的Message对象压入到消息队列中，方法有sendEmptyMessage(int)、sendMessage(Message)、sendMessageAtTime(Message,long)、sendMessageDelayed(Message,long)。 Post对于Handler的Post方式来说，它会传递一个Runnable对象到消息队列中，在这个Runnable对象中，重写run()方法。一般在这个run()方法中写入需要在UI线程上的操作。 在Handler中，关于Post方式的方法有： boolean post(Runnable r)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，立即执行。 boolean postAtTime(Runnable r,long uptimeMillis)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，在特定的时间执行。 boolean postDelayed(Runnable r,long delayMillis)：把一个Runnable入队到消息队列中，UI线程从消息队列中取出这个对象后，延迟delayMills秒执行 void removeCallbacks(Runnable r)：从消息队列中移除一个Runnable对象。 MessageMessage是一个final类，所有不可继承，Message封装了线程中传递的消息，对于一般的数据Message提供了getData()和setData()方法来获取与设置数据，其中操作的数据是一个Bundle对象，这个Bundle对象提供了一系列的getXxx()和setXxx()方法用于传递基本数据类型的键值对。对于复杂的数据类型，Bundle提供了两个方法，专门用来传递对象，但是这两个方法也有相应的限制，需要实现特定的接口。 putParcelable(String key,Parcelable value)：需要传递的对象类实现Parcelable接口。 pubSerializable(String key,Serializable value)：需要传递的对象类实现Serializable接口。除此之外Message自带的obj属性也可以用于传值，它是一个Object类型，可以传递任何类型的对象，Message自带的如下几个属性： int arg1:参数一，传递不复杂数据 int arg2：参数二，传递不复杂数据 Object obj：传递任意的对象 int what:定义消息码，一般用于消息的标志 对于Message对象，一般不推介直接使用构造方法创建，而是使用Message.obtain()这个静态方法或者Handler.obtai()获取，此两者都是从消息池中获取，消息的数量是有上限的，为10个。 向Handler发送消息一般分两种：一种是根据Handler对象，使用handler.sendMessage()方法来发送消息，一种是根据Handle获取Message，如handler.obtai()或者Message.obtain(handler)，该Message会有一个属性Target，调用sendToTarget()方法，会发送到创建时的Handler中去。Handler中，与Message发送消息相关的方法有： Message obtainMessage()：获取一个Message对象。 boolean sendMessage()：发送一个Message对象到消息队列中，并在UI线程取到消息后，立即执行。 boolean sendMessageDelayed()：发送一个Message对象到消息队列中，在UI线程取到消息后，延迟执行。 boolean sendEmptyMessage(int what)：发送一个空的Message对象到队列中，并在UI线程取到消息后，立即执行。 boolean sendEmptyMessageDelayed(int what,long delayMillis)：发送一个空Message对象到消息队列中，在UI线程取到消息后，延迟执行。 void removeMessage()：从消息队列中移除一个未响应的消息。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"非常见Android项目文件","date":"2014-07-17T05:40:14.000Z","path":"2014/07/17/非常见Android项目文件/","text":"ids.xml/res/values/ids.xml ids.xml是区别于R文件的一种设置控件ID的方式。使用示例如下： 控件定义时 1234&lt;Button android:id = \"@id/button_ok\" ... /&gt; 在ids文件中添加 1234&lt;resources&gt; &lt;item type=\"id\" name=\"button_ok\"&gt;false&lt;/item&gt; ...&lt;/resources&gt; 3.在调用控件时 12Button bn = new Button(context);bn.setId(R.id.button_ok); // 区别于 bn.setId(context.getResources().getInteger(R.id.button_ok)); 使用ids.xml的优点如下 命名方便，可以先将控件先命名好，在布局时直接命名 使用代码布局时，不需要转换 注意：在ids.xml中的每一项也会生成到R文件中 arrays.xml用于包装数组// 在arrays.xml中定义1234567891011&lt;resources&gt; &lt;string-array name=\"week\"&gt; &lt;item&gt;Sunday&lt;/item&gt; &lt;item&gt;Monday&lt;/item&gt; &lt;item&gt;Tuesday&lt;/item&gt; &lt;item&gt;Wednesday&lt;/item&gt; &lt;item&gt;Thursday&lt;/item&gt; &lt;item&gt;Friday&lt;/item&gt; &lt;item&gt;Saturday&lt;/item&gt; &lt;/string-array&gt;&lt;/resource&gt; 在Java中调用1CharSequence[] items = this.getResources().getStringArray(R.array.reboot_item); attrs.xmlattrs.xml用于设定自定义属性 在res/values文件夹下定义一个attrs.xml文件 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;resources&gt; &lt;declare-styleable name=\"MyView\"&gt; &lt;attr name=\"textColor\" format=\"color\" /&gt; &lt;/declare-styleable&gt;&lt;/resource&gt; 在Java调用自定义属性 12345678910111213141516171819202122232425262728293031public class MyView extends View &#123; private Paint mPaint; private Context mContext; public MyView(Context context) &#123; super(context); mPaint = new Paint(); &#125; public MyView(Context context,AttributeteSet atts)&#123; super(context,attrs); mPaint = new Paint(); TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.MyView); // R.styleable.MyView_textColor是读取attrs中参数名，以\"样式名_参数名\"的形式 // 第二个参数为默认值，如果从xml中获取不到则使用默认值 int textColor = a.getColor(R.styleable.MyView_textColor,0XFFFFFFFF); mPaint.setTextColor(textColor); a.recycle(); &#125; @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); //设置填充 mPaint.setStyle(Style.FILL); //画一个矩形,前俩个是矩形左上角坐标，后面俩个是右下角坐标 canvas.drawRect(new Rect(10, 10, 100, 100), mPaint); mPaint.setColor(Color.BLUE); //绘制文字 canvas.drawText(mString, 10, 110, mPaint); &#125;&#125; 布局时使用属性 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;com.android.tutor.MyView android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" test:textSize=\"20px\" test:textColor=\"# fff\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"自定义ProgressBar","date":"2014-07-14T05:39:21.000Z","path":"2014/07/14/自定义ProgressBar/","text":"anim 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- oneshot=\"false\" 循环播放 --&gt;&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\" &gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_1\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_2\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_3\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_4\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_5\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_6\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_7\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt; &lt;item android:duration=\"60\"&gt; &lt;clip android:clipOrientation=\"horizontal\" android:drawable=\"@drawable/loading_8\" android:gravity=\"left\" &gt; &lt;/clip&gt; &lt;/item&gt;&lt;/animation-list&gt; layout 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;!-- android:indeterminate=\"false\" 不明确滚动的数值 --&gt; &lt;ProgressBar android:id=\"@+id/progressBar\" android:layout_width=\"63dp\" android:layout_height=\"63dp\" android:layout_gravity=\"center\" android:indeterminate=\"false\" android:indeterminateDrawable=\"@anim/progress_bar_anim\" android:scaleType=\"centerInside\" /&gt;&lt;/FrameLayout&gt; 例子","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"AVOS Cloud Android开发指南","date":"2014-07-10T05:38:39.000Z","path":"2014/07/10/AVOS-Cloud-Android开发指南/","text":"模块与SDK包AVOS Cloud基本存储模块 avoscloud- 版本号.jar android-async-http-1.4.4-fix.jar fastjson.jar httpmime-4.2.4.jar AVOS Cloud 推送模块 AVOS Cloud 基础存储模块 avospush- 版本号.jar AVOS Cloud 统计模块 AVOS Cloud 基础存储模块 avosstatistics- 版本号.jar AVOS Cloud SNS 模块 AVOS Cloud 基础存储模块 weibo.sdk.android.sso.jar qq.sdk.1.6.1.jar 简介AVOSCloud提供了一个完整的后端解决方案 应用程序在 AVOS Cloud 平台注册后，您创建的每个应用程序都有其自己的应用程序 ID 和 Key, 在您的应用程序中将凭此 ID 和 Key 使用 AVOS Cloud SDK。您的账户可以创建容纳多个应用程序，这是非常方便和有用的。即使您只有一个应用程序，也可以使用不同的版本进行测试和生产。 对象AVOS Cloud存储的数据是建立在AVObject基础上，每个AVObject包含键(key)-值(value)对的JSON兼容的数据。键必须是字母、数字的字符串，值可以是字符串、数字、布尔值、JSON数组和AVObject对象等。每个AVObject有一个类名，你可以用它来区分各种不同的数据。 保存对象1234567891011121314151617181920 AVObject myObj = new AVObject(\"MyObject\");myObj.put(\"value1\",123); myObj.put(\"value2\",true);myObj.put(\"value3\",\"hello\"); try&#123; myObj.save();&#125; catch (AVException e) &#123; e.getMessage(); &#125; myObj.saveInBackground(new SaveCallback() &#123; @Override public void done(AVException e) &#123; if (e == null) &#123; // 保存成功 &#125; else &#123; // 保存失败 &#125; &#125;&#125;); 检索对象使用AVQuery通过ObjectID检索到一个完整的AVObject1234567891011121314151617AVQuery&lt;AVObject&gt; query = new AVQuery&lt;AVObject&gt;(\"MyObject\");AVObject myObj;try &#123; myObj = query.get(\"51c912bee4b012f89e344ae9\");&#125; catch (AVException e) &#123; // e.getMessage(); &#125;query.getInBackground(\"51c912bee4b012f89e344ae9\", new GetCallback&lt;AVObject&gt;() &#123; @Override public void done(AVObject obj, AVException e) &#123; if (e == null) &#123; // 获取成功 &#125; else &#123; // 获取失败 &#125; &#125;&#125;); 更新对象获取AVObject对象，然后进行修改值后保存数据12345678 AVQuery&lt;AVObject&gt; query = new AVQuery&lt;AVObject&gt;(\"MyObject\");AVObject myObj;try &#123; myObj = query.get(\"51c912bee4b012f89e344ae9\"); myObj.put(\"value3\", \"hello world\");&#125; catch (AVException e) &#123; // e.getMessage();&#125; 计数器12myObj.increment(\"value1\");// myObj.increment(key,amount);方法可以递增递减任意幅度的数字 更新后获取最新值设置fetchWhenSave属性为true会使更新后，AVObject获得最新值12345678myObj.setFetchWhenSave(true);myObj.increment(\"value1\");myObj.saveInBackground(new SavaCallback()&#123; @Override public void done(AVException e)&#123; // &#125;&#125;); 删除对象从服务器删除对象1234567myObj.deleteInBackground();// 删除value3字段myObj.remove(\"value3\");myObj.saveInBackground();// 批量删除对象List&lt;AVObject&gt; objects = ...AVObject.deleteAll(objects); 关联数据对象可以与其他对象相联系，就像数据库中的主外键关系一样，数据表A的某一个字段是数据表B的外键，只有表B中存在的数据才插入进A中的字段。12345678AVObject myWeibo = new AVObject(\"Post\");myWeibo.put(\"content\", \"正文\");AVObject myConment = new AVObject(\"Comment\");myConment.put(\"content\", \"评论\");myConment.put(\"post\",myWeibo);myConment.saveInBackground();// 通过objectId来关联已用对象myComment.put(\"post\",AVObject.createWithoutData(\"Post\", \"1zEcyElZ80\")); 默认情况下，获取一个对象的时候，关联的AVObject不会被获取，这些对象的值无法获取，直到调用fetch123456myConment.getAVObject(\"post\").fetchIfNeededInBackground(new GetCallback&lt;AVObject&gt;() &#123; @Override public void done(AVObject object, AVException e) &#123; String content = object.getString(\"content\"); &#125;&#125;); 使用AVRelation来建模多对多关系。比如一个User喜欢很多Post，可以用getRelation方法保存一个用户喜欢的用户的Post集合。123456AVUser user = AVUser.getCurrentUser();AVRelation&lt;AVObject&gt; relation = user.getRelation(\"likes\");relation.add(post);user.saveInBackground();// 从AVRelation中移除一个Postrelation.remove(post) 默认情况，处于关系的对象集合不会被下载，可以通过getQuery方法返回的AVQuery对象，使用它的findInBackground方法来获取Post链表12345678910111213141516171819relation.getQuery().findInBackground(new FindCallback&lt;AVObject&gt;()&#123; void done(List&lt;AVObject&gt; result,AVException e)&#123; if(e == null)&#123; // &#125; else &#123; // &#125; &#125; &#125;);// 获取链表的一个子集合，可以添加更多的约束条件到`getQuery`返回`AVQuery`对象AVQuery&lt;AVObject&gt; query = relation.getQuery();// 已持有一个post对象，想知道它被哪些User所喜欢，反查询AVQuery&lt;AVObject&gt; userQuery = AVRelation.reverseQuery(\"_User\",\"likes\",myPost);userQuery.findInBackground(new FindCallBack&lt;AVObject&gt;()&#123; @Override public void done(List&lt;AVObject&gt; users,AVException e)&#123; // &#125;&#125;); 数据类型支持的数据类型有String、Int、Boolean、AVObject，同时支持java.util.Date、byte[]、JSONObject、JSONArray数据类型。 查询基本查询先创建一个AVQuery对象，然后通过添加不同的条件，使用findInBackground方法结合FindCallback回调类来查询与条件匹配的AVObject数据，使用whereEqualTo方法来添加条件值1234567891011AVQuery&lt;AVObject&gt; query = new AVQuery&lt;AVObject&gt;(\"MyObject\");query.whereEqualTo(\"value1\",\"value2\");query.findInBackgroud(new FindCallback&lt;AVObject&gt;()&#123; public void done(List&lt;AVOject&gt; object,AVException e)&#123; if (e == null) &#123; // &#125; else &#123; // &#125; &#125; &#125;); 查询条件 whereNotEqualTo() 不等于 setLimit() 限制结果的个数 setSkip() 忽略多少个 orderByAscending() 升序排列 orderByDescending() 降序排列 whereLessThan() 小于 whereLessThanOrEqualTo() 小于等于 whereGreaterThan() 大于 whereGreaterThanOrEqualTo() 大于等于 想查询匹配几个不同值的数据，如：要查询”steve”、”chard”、”jack”三个人的成绩，可以使用whereContainedIn方法来实现，排除可以使用whereNotContainedIn方法12String[] names = &#123;\"steve\",\"chard\",\"jack\"&#125;;query.whereContainedIn(\"playName\",Arrays.asList(names)); 使用whereMatches方法可以使用任何正确的正则表达式来检索匹配的值123456789// 比较name字段的值是以大写字母和数字开头AVQuery&lt;AVObject&gt; query = new AVQuery&lt;AVObject&gt;(\"GameScore\");query.whereMatches(\"name\", \"^[A-Z]\\\\d\");query.findInBackground(new FindCallback&lt;AVObject&gt;() &#123; public void done(List&lt;AVObject&gt; sauceList, AVException e) &#123; &#125;&#125;); 查询字符串中包含“XX“内容，可用如下方法：1234567891011// 查询playerName字段的值中包含“ste“字的数据AVQuery query = new AVQuery(\"GameSauce\");query.whereContains(\"playerName\", \"ste\");// 查询playerName字段的值是以“cha“字开头的数据AVQuery query = new AVQuery(\"GameSauce\");query.whereStartsWith(\"playerName\", \"cha\");// 查询playerName字段的值是以“vj“字结尾的数据AVQuery query = new AVQuery(\"GameSauce\");query.whereEndsWith(\"playerName\", \"vj\"); 数组查询如果key对应的值是一个数组，可以查询key的数组包含了数字2的所有对象1query.whereEqualTo(\"arrayKey\",2); 同样，你可以查询出 Key 的数组同时包含了 2,3 和 4 的所有对象：123456//查找出所有arrayKey对应的数组同时包含了数字2,3,4的所有对象。ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;();numbers.add(2);numbers.add(3);numbers.add(4);query.whereContainsAll(\"arrayKey\", numbers); 字符串的查询使用 whereStartsWith 方法来限制字符串的值以另一个字符串开头。非常类似 MySQL 的 LIKE 查询，这样的查询会走索引，因此对于大数据集也一样高效：123//查找出所有username以avos开头的用户AVQuery&lt;AVObject&gt; query = AVQuery.getQuery(\"_User\");query.whereStartsWith(\"username\", \"avos\"); 查询对象个数query使用count替代find可以统计多少个对象满足查询12345678query.countInBackgroud(new CountCallback()&#123; @Ovrride public void done (int count,AVException e) &#123; if(e == null)&#123; // count 就是符合查询条件的个数 &#125; &#125;&#125;);","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Swift笔记(三)","date":"2014-07-10T05:11:08.000Z","path":"2014/07/10/Swift笔记(三)/","text":"字符串和字符（String and Character）Swift的String类型和Foundation的NSString类进行了无缝桥接，所有NSString API都可以调用Swift的String类型的值 字符串字面量(String Literals)字符串字面量是由双引号(“”)包裹的具有固定顺序的文本字符集字符串字面量可以包含以下特殊字符： 转义字符\\0(空字符)、\\(反斜线)、\\t(水平制表符)、\\n(换行符)、\\r(回车符)、\\”(双引号)、\\’(单引号) 单字节 Unicode 标量，写成\\xnn，其中nn为两位十六进制数 双字节 Unicode 标量，写成\\unnnn，其中nnnn为四位十六进制数 四字节 Unicode 标量，写成\\Unnnnnnnn，其中nnnnnnnn为八位十六进制数初始化空字符串12345var emptyString = \"\"var antherEmptyString = String()if emptyString.isEmpty &#123; //&#125; 字符串可变性(String Mutability)可以通过分配一个变量来对字符串进行修改，或者分配一个常量保证其不被修改 字符串是值类型String类型进行常量、变量赋值操作或在函数\\方法中传递，会进行拷贝，是值传递 字符Swift的String类型表示特定序列的character类型值的集合123for character in \"Hello world\"&#125; println(character)&#125; 可以表明Character类型来创建字符常量或者变量1let a:Character = \"1\" 计算字符数量通过调用全局的countElement函数，并将字符串作为参数传递，可以获取字符串的字符数量12let str = &quot;I have a word&quot;pritln(\\(coutElemnts(str))); 连接字符串和字符使用+相加就可以连接字符串使用+=可以讲一个字符串加上另一个字符串存到原有的字符串上 字符串插值字符串插值是一种构建新字符串的方式，可以在其中包含常量、变量、字面量和表达式1\\(Double(3) * 2.5) // \"7.5\" 比较字符串Swift 提供了三种方式来比较字符串的值：字符串相等、前缀相等和后缀相等。 字符串相等123456let str = \"一样样的\"str == \"一样样的\" // true#### 前缀/后缀相等调用字符串的`hasPrefix`/`hasSuffix`方法来检查字符串是否拥有特定前缀/后缀。```swift\"I am a boy\".hasPrefix(\"I am\"); // true 大写和小写字符串通过字符串的uppercaseString和lowercaseString属性来方位大写/小写版本的字符串 UnicodeUnicode是一个国际标准，用于文本的编码和表示。每一个字符都可以被Unicode解释成一个或多个unicode标量。字符的unicode标量是一个唯一的21位数字，例如U+0061表示小写的拉丁字母a当Unicode字符串被写进文本文件或其他存储结构当中，这些unicode标量将会按照Unicode定义的集中格式之一进行编码，其中包括UTF-8（以8位代码单元进行编码）和UTF-16（以16位代码单元进行编码） 字符串的Unicode表示Swift提供了几种不同的方法来访问字符串的Unicode UTF-8 代码单元集合 (利用字符串的utf8属性进行访问) UTF-16 代码单元集合 (利用字符串的utf16属性进行访问) 21位的 Unicode 标量值集合 (利用字符串的unicodeScalars属性进行访问)utfb属性其为UTF8View类型的属性，是无符号8位(UInt)值的集合，同理utf16属性是UTF16View类型的属性1234567let dogString \"Dog!\"for codeUnit in dogString.utf8 &#123; pritln(\"\\(codeUnit)\");&#125;for code16Unit in dogString.utf16 &#123; println(\"\\(code16Unit)\");&#125; Unicode标量unocodeScalars属性为UnicodeScalarView类型的属性，是UnicodeScalar的集合,UnicodeScalar是21位的 Unicode 代码点。123for scale in dogString.unicodeScalars &#123; println(\"\\(scale.value)\")&#125; 集合类型(Collection Types) 数组数组使用有序列表存储同一类型的多个值，相同的值可以多次出现在一个数组的不同位置中在Swift中。数据值在被存储进入某个数组之前类型必须明确，方法是通过显示的类型标注或类型推断，Swift的数组是类型安全的，并且它包含的类型必须明确，这点和NSArray和NSMutableArray很不同。 数组的简单语法数组遵循Array&lt;SomeType&gt;这样的形式，其中SomeType是这个数组中唯一允许存在的数据类型。也可以使用像SomeType[]这样的简单语法。 数组构造语句形如[value1,value2,value3]1var names:String[] = [\"joy\",\"jack\"] 变量被声明为字符串类型的数组由于Swift的类型推断机制，也可以这样写1var names = [\"jay\",\"jack\"] 访问和修改数组可以通过数组的方法和属性来访问和修改数组，或者下表语法。还可以使用数组的只读属性count来获取数组中的数据数量，使用isEmpty属性可以检测数组是否为空，使用append方法在数组后面添加新的数据项，也可以使用(+=)添加单个数据项或者拥有相同数据类型的数组也可以通过索引获取数组项12345678var names = [&quot;joy&quot;,&quot;jack&quot;]names.count // 2names.isEmpty // falsenames.append(&quot;alisa&quot;)names+=&quot;Demi&quot;names+=[&quot;Carry&quot;,&quot;Carry&quot;]names[0] //&quot;joy&quot;names[2...3] // [&quot;alisa&quot;,&quot;Demi&quot;] 调用insert(atIndex:)可以再在指定位置插入数据，removeAtIndex方法可以移除数组中的某一项，removeLast方法可以移除最后一项 数组的遍历使用for-in循环来遍历所有数组中的数据项123for item in shoppingList&#123; println(item) &#125; 也可以使用全局enumerate函数来进行数组遍历123for (index,value) in enumerate(shoppingList) &#123; println(\"Item \\(index+1) : \\(value)\")&#125; 创建或构造一个数组123var someInts = Int[]()var threeDoubles = Double[](count:3,repeatedValue:0.0) // 指定大小，初始值var anotherThreeDoubles = Array(count:3,repeatedValue:2.5) // 类型推到 字典字典是一种存储多个相同类型的值的容器，没个值都关联唯一的键，键作为字典中的这个值数据的标识符。字典的数据项没有具体的顺序，需要通过键访问数据。与Objective-C中的NSDictionary和NSMutableDictionary类可以使用任何类型的对象做键和值不同，Swift在某个特定字典中可以存储的键和值必须提前定义，方法是通过显式标注或者类型推断Swift的字典可以使用Dictionary&lt;KeyType,ValueType&gt;定义，其中keyType是键的数据类型，ValueType是值的数据类型。keyType的唯一限制是可哈希的，这样可以保证它的唯一性，所有Swift的基本类型(String,Int,Double和Bool)都是可哈希的，未关联的枚举成员也是可哈希的。 字典字面量[key1:value1,key2:value2,key3:value3]可以创建字典12var airports:Dictionary&lt;String,String&gt; = [\"TYO\":\"Tokyo\",\"DUB\":\"Dublin\"]var airports = [\"TYO\":\"Tokyo\",\"DUB\":\"Dubin\"] 读取和修改字典使用下标语法或者字典的方法属性可以读取字典，只读属性count来获取字典的数据项的数量也可以使用下标法添加新的数据项updateValue(forkey:)方法可以设置或更新特定键对应的值，根据键值是否存在判断。该函数会返回包含一个字典值类型的可选值12345airports[&quot;LHR&quot;] = &quot;London Heathrow&quot; // 添加数据项airports[&quot;LHR&quot;] = &quot;London&quot; // 修改if let oldValue = airports.updateValue(&quot;Dublin Internation&quot;,forKey:&quot;DUB&quot;)&#123; oldValue // 返回的是原值&#125; 使用下标法也可以访问对应键的值，如果不存在，返回nil，通过下标法设置某键的值为nil，也可以删除数据项，也可以使用removeValueForKey方法移除123if let removedValue = airports.removeValueForKey(\"DUB\")&#123; // removedValue为被移除的值，不存在的话返回nil&#125; 字典遍历使用for-in语法便可遍历，每一个字典的数据项都由(key,value)元组形式返回123for (airportCode,airportName) in airport &#123; prinln(\"\\(airportCode):\\(airportName)\")&#125; 也可以访问它的keys和values属性检索一个字典的键或者值1234for airportCode in airports.keys &#123; println(\"Airport code: \\(airportCode)\")&#125;let airportNames = Array(airports.values) 创建字典创建空字典12var nameOfIntegers = Dictionary&lt;Int,String&gt;()var nameOfIntegers = [:] 集合的可变性如果数组或字典设置为变量，那么它的数据项是可变的，设置为常量，那么它的大小是不可变的，数据在首次设定之后便不能改变。不同的是，数组的大小不能改变，但是可以改变它的值。控制流 For循环for循环用作按照指定的次数多次执行一系列语句。Swift提供了两种for循环形式： for-in用来遍历一个区间(range)，序列(sequence),集合(collection)，系列(progression)里面多有的元素 for条件递增(for-condition-increment)语句，用来重复执行一系列语句知道达到特定条件，一般通过在每次循环完成后增加计数器的值来实现。For-In1234// index不需要声明for index in 1...5&#123; println(\"\\(index)\");&#125; 如果不需要知道区间每一项的值，可以使用下划线(_)替代变量名忽略对值的访问123for _ in 1...9&#123; //&#125; For条件递增（for-condition-increment）123for var index = 0; index &lt; 3;++index&#123; //&#125; 下面是一般情况下这种循环方式的格式： for initialization; condition; increment { statements} While循环while循环运行一系列语句直到条件变成false。这类循环适合使用在第一次迭代前迭代次数未知的情况下。Swift 提供两种while循环形式： while循环，每次在循环开始时计算条件是否符合； do-while循环，每次在循环结束时计算条件是否符合。一般格式如下：123456while condition&#123; statements&#125;do &#123; statements&#125; while condition 条件语句Swift提供两种类型的条件语句：if语句和switch语句。通常，当条件较为简单且可能的情况很少时，使用if语句。而switch语句更适用于条件较复杂、可能情况较多且需要用到模式匹配（pattern-matching）的情境。 Ifif语句最简单的形式就是只包含一个条件，当且仅当该条件为true时，才执行相关代码：123if true &#123; //&#125; Switchswitch语句会尝试把某个值与若干个模式（pattern）进行匹配。根据第一个匹配成功的模式，switch语句会执行对应的代码。123456789witch some value to consider &#123; case value 1: respond to value 1 case value 2, value 3: respond to value 2 or 3 default: otherwise, do something else&#125; swift不存在隐藏的贯穿，即不需要break，执行完也会推出，同时swift还支持区间匹配123456switch count&#123; case 0: // case 1...3: //&#125; 元组匹配12345var count = (1,3)switch count&#123; case (0,0): //&#125; 值绑定case分支的模式允许将匹配的值绑定到一个临时的常量或变量，这些变量或常量在该case分支里就可以被引用————这种行为被称为值绑定123456789let point = (2,0)switch point &#123;case (let x,0): //case (0, let y): //case let (x,y): // &#125; Wherecase分支模式可以使用where语句来判断额外的条件12345let point = (1,0)switch point &#123; case let (x,y) where x == y: //&#125; 控制转移语句（Control Transfer Statements）控制转移语句改变你代码的执行顺序，通过它你可以实现代码的跳转。Swift有四种控制转移语句。- continue break fallthrough returnContinuecontinue语句告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。Breakbreak语句会立刻结束整个控制流的执行。贯穿（Fallthrough）Swift不存在C语言中switch语句的贯穿行为，要实现需要使用fallthrouth1234567switch count&#123; case 1: // fallthrough default: // 这里会被执行&#125; 带标签的语句（Labeled Statements）环体和switch代码块两者都可以使用break语句来提前结束整个方法体，通过带标签的语句可以指定想要终止哪个循环或者switch代码块，如果有许多嵌套的循环体，也可以实现continue指定跳转123label name:while condition&#123; statenments&#125; 123456789loop:while count != 100&#123; if count &lt; 100 &#123;count += 10&#125; switch count &#123; case 1..20 : break loop case 21...99: // &#125;&#125; 函数(Functions) 函数的定义与调用(Defining and Calling Functions)12345func sayHello(personName:String) -&gt; String&#123; let greeting = \"Hello,\" + personName + \"!\" return greeting&#125;println(\"\\(sayHeloo(\"zoe\"))\") 函数参数与返回值(Function Parameters and Return Values) 多个参数 123func fun(start: Int,end: Int) -&gt; Int &#123; return end - start&#125; 无参 123func say() -&gt; String&#123; return \"hello\"&#125; 无返回值 123func sayGoodbye(personName: String)&#123; println(\"Goodbye\",\\(personName)!)&#125; 多返回值// 计算一个字符串中元音、辅音和其他字母的个数 1234567891011121314151617func count(str:String) -&gt; (vowels: Int, consonants: Int,others: Int) &#123; var vowels = 0, consonants = 0, others = 0 for character in string &#123; switch String(character).lowercaseString &#123; case \"a\", \"e\", \"i\", \"o\", \"u\": ++vowels case \"b\", \"c\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\", \"v\", \"w\", \"x\", \"y\", \"z\": ++consonants default: ++others &#125; &#125; return (vowels, consonants, others)&#125;let total = count(\"some arbitrary string!\")println(\"\\(total.vowels) vowels and \\(total.consonants) consonants\") 函数参数名称在函数定义时定义的参数为局部参数名，只能在函数体中使用 外部函数名类似于Objective-C的函数命名1234func join(string s1:String,toString s2:String) -&gt; String&#123; return s1 + s2&#125;join(string:\"hello\",toString:\"world\") 简写外部参数名上面的方法需要为参数提供外部参数名和内部参数名，可以通过#简写，将外部参数名和内部参数名等同起来1234func join(# string:String,# toString:String) -&gt; String&#123; return string + toString&#125;join(string:\"hello\",toString:\"world\") 默认参数值为参数提供一个初始值，调用时，缺省可以忽略并使用默认值123func join(str1 String,str2 String = \"world\") -&gt; String&#123; return str1 + str2&#125; 可变参数1234567func add (numbers: Double...) -&gt; Double &#123; var total: Double = 0; for number in numbers &#123; total += number &#125; return total / Double(numbers.cout)&#125; 常量参数和变量参数函数参数默认是常量，在函数体中更改参数值将会导致编译错误，如果参数定义为变量就可以当做参数的副本来使用12345678// 用来右对齐输入的字符串到一个长的输出字符串中。左侧空余的地方用指定的填充字符填充func alignRight(var string: String, count: Int, pad: Character) -&gt; String &#123; let amountToPad = count - countElements(string) for _ in 1...amountToPad &#123; string = pad + string &#125; return string&#125; 输入输出参数一个输入输出参数时，在参数定义前加inout关键字。一个输入输出参数有传入函数的值，这个值被函数修改，然后被传出函数，替换原来的值。当传入的参数作为输入输出参数时，需要在参数前加&amp;符，表示这个值可以被函数修改。1234567func swap (inout a:Int,inout b:Int)&#123; let temp = a a = b b = temp&#125;var a = 3,b = 4swap(&amp;a,&amp;b) 函数类型每个函数都有种特定的函数类型，由函数的参数类型和返回类型组成。() -&gt; ()表示没用参数，返回Void，在Swift中，Void与空元组是一样的 使用函数类型使用函数名来给另一个函数赋值1var fun2:(Int,Int) -&gt; Int = fun1 使用函数类型12var mathFunction:(Int,Int) -&gt; Int = addTwoInts// 只要matchFunction和addTwoInts的类型相同，该赋值就是合法的 函数类型作为参数类型1234func printMathResult(matchFunction:(Int,Int) -&gt; Int,a:Int,b:Int)&#123; println(\"Result: \\(mathFunction(a,b))\")&#125;printMathResult(addTwoInts,3,5) 函数类型作为返回类型123func chooseStepFunction(backwards:Bool) -&gt; (Int) -&gt; Int &#123; return backwards ? stepBackward : stepForward&#125; 闭包闭包之自包含的函数代码块，可以在代码中传递和使用，与Objective-C的blocks相似闭包可以捕获和存储其所在上下文任意常量和变量的引用。全局和嵌套函数也是特殊的闭包，闭包采取如下三种形式： 全局函数是一个有名字但不会捕获任何值的闭包 嵌套函数是一个有名字并可以捕获其封闭函数内值的闭包 闭包表达式是一个利用轻量级语法所写的可以捕获其上下文中变量或常量值的匿名闭包 闭包表达式(Closure Expreessions)闭包表达式是一种利用简洁语法构建内联闭包的方式，闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了。 闭包表达式语法闭包表带式语法一般形式：123&#123; (parameters) -&gt; returnType in statemnts&#125; Swift标准库提供了sort函数，会根据基于输出类型排序的闭包函数将已知类型数组的值进行排序，返回一个与原数组大小相同的新数组，并排序完成。 ```","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"理解Optional","date":"2014-07-10T05:10:42.000Z","path":"2014/07/10/理解Optional/","text":"Swift可以再类型后面加一个?来将变量声明为optional(随意的)。如果不是Optional的变量，那么它就必须有值，而没有值发话，我们使用Optional并且将它设置为nil来表示没有值。123var num:Int?num = nilnum = 3 Optional Value就像一个盒子，盒子可能装着实际的值，可能声明都没装。123456var num:Int?=3 // 声明一个Int的Optianal，并将其设为3if let n = num &#123; // hava a num&#125; else &#123; // no num&#125; 使用场景1foo?.somemethod()","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"数据持久化","date":"2014-07-10T00:23:17.000Z","path":"2014/07/10/数据持久化/","text":"数据持久化的方法有： 保存在硬盘或闪存上 保存在计算机内存中 保存在数据库中 保存在cookie或会话中 将数据写入文件12345678910// weite.jsvar fs = require('fs'), data = \"Some data I want to write to a file.\";fs.writeFile('file.txt',data,function(err)&#123; if (!err) &#123; console.log(\"Wrote data to file.txt.\"); &#125; else &#123; throw err; &#125;&#125;); 注意： 如果文件不存在，writeFile方法也创建文件 文件默认写入脚本运行位置，也可以指定完整路径 可能的错误包括文件不存在或者没有读取文件的权限 从文件读取数据123456789// read.jsvar fs = require('fs');fs.readFile('file.txt','utf8',function(err,data)&#123; if (!err) &#123; console.log(data); &#125;else&#123; throw err; &#125;&#125;); 环境变量设置环境变量windows:1SET SOMETHING=&apos;12345678&apos; UNIX:1var something = process.env.SOMETHING 可以再node中访问process.env.SOMETHING 使用数据库NoSQL数据库 Cassandra Redis Memcached MongoDB Hadoop 在Node.js中使用MongoDBMongoDB是面向文档的数据库，它不遵照将关系数据连接在一起的关系模型，它可执行关系数据库的大多数功能并且旨在提供高度的可用性和可扩展性。CRUD指Create、Read、Update、Delete 安装MongiDB可以到MongoDB官网获得对应平台的安装文件。MongoDB有很多GUI支持，OSX可以使用MongoHub；Windows，可以使用Monogo VUE,它是功能受限的免费版，同事需要.NET Framework支持；Linux上可以使用JMongoBrowser，它是基于Java客户端，需要Java运行环境。 连接MongoDBMongoose是Node.js中一个功能齐备的第三方模块，用于处理MongoDB。将Mongoose模块加入到项目中，并在package.json文件中将其作为依赖模块包含进来：1234567&#123; \"name\":\"your-application\", \"version\":\"0.0.1\", \"dependcies\":&#123; \"mongoose\":\"&gt;= 2.3.1\" &#125;&#125; 运行npm install并在应用程序文件中请求它var mongoose = require(&#39;mongoose&#39;);之后连接并使用它mongoose.connect(&#39;mongodb://localhost/your_database&#39;);. 定义文档MongoDB中，没有关系数据库中表的概念，M哦你goDB围绕着文档的思想来组织数据。通过Mongoose模块在MongoDB中定义一个文档：通过Mongoose提供的Schema接口定义，然后声明属性。Mongoose可声明的类型如下： String(字符串) Number(数值) Date(日期) Boolean(布尔值) Buffer(缓存) ObjectID(对象ID) Mixed(混合) Array(数组)对于task模型而言，只需要一个属性123456var Schema = mongoose.Schema, ObjectId = Shema.ObjectId;var Task = new Schema(&#123; task:String&#125;);var Task = mongoose.model('Task',Task); 将Twitter Bootstrap包含进来在views/layout.jade包含如下内容123456html head title=title link(rel=&apos;stylesheet&apos;,href=&apos;http://twitter.github.com/bootstrap/1.4.0/bootstrap.min.css&apos;) body section.container!=body","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"}]},{"title":"图片选取","date":"2014-07-09T05:37:51.000Z","path":"2014/07/09/图片选取/","text":"数据类 Bimp12345678910111213141516171819202122232425262728293031public class Bimp &#123; public static int max = 0; public static boolean act_bool = true; public static List&lt;Bitmap&gt; bmp = new ArrayList&lt;Bitmap&gt;(); // 图片的存放地址 public static List&lt;String&gt; drr = new ArrayList&lt;String&gt;(); // 用于压缩图片 public static Bitmap revitionImageSize(String path)throws IOException &#123; BufferedInputStream in = new BufferedInputStream(new FileInputStream( new File(path))); BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeStream(in, null, options); in.close(); int i = 0; Bitmap bitmap = null; while (true) &#123; if ((options.outWidth &gt;&gt; i &lt;= 1000) &amp;&amp; (options.outHeight &gt;&gt; i &lt;= 1000)) &#123; in = new BufferedInputStream( new FileInputStream(new File(path))); options.inSampleSize = (int) Math.pow(2.0D, i); options.inJustDecodeBounds = false; bitmap = BitmapFactory.decodeStream(in, null, options); break; &#125; i++; &#125; return bitmap; &#125;&#125; 工具类 BitmapCache类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class BitmapCache &#123; public final String TAG = getClass().getSimpleName(); public Handle h = new Handle(); private HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;(); public void put(String path,Bitmap bmp) &#123; if(!TextUtils.isEmpty(path) &amp;&amp; bmp != null) &#123; imageCache.put(path, new SoftReference&lt;Bitmap&gt;(bmp)); &#125; &#125; public void displayBmp(final ImageView iv, final String thumbPath, final String sourcePath, final ImageCallback call ballback) &#123; if (TextUtils.isEmpty(thumbPath) &amp;&amp; TextUtils.isEmpty(sourcePath)) &#123; Log.e(TAG, \"no paths pass in\"); return; &#125; final String path; final boolean isThumbPath; if (!TextUtils.isEmpty(thumbPath)) &#123; path = thumbPath; isThumbPath = true; &#125;else if (!TextUtils.isEmpty(sourcePath)) &#123; path = sourcePath; isThumbPath = false; &#125;else &#123; return; &#125; // 缓存中是否有该图片 if(imageCache.containsKey(path))&#123; SoftReference&lt;Bitmap&gt; reference = imageCache.get(path); if (bmp != null) &#123; if (callback != null) &#123; callback.imageLoad(iv, bmp ,sourcePath); &#125; iv.setImageBitmap(bmp); Log.d(TAG,\"hit cache\"); return; &#125; &#125; iv.setImageBitmap(null); new Thread() &#123; Bitmap thumb; public void run()&#123; try &#123; if (isThumbPath) &#123; thumb = BitmapFactory.decodeFile(thumbPath); if (thumb == null) &#123; thumb = revitionImageSize(sourcePath); &#125; else &#123; thumb = revitionImageSize(thumbPath); &#125; &#125; catch (Exception e)&#123; &#125; if (thumb == null) &#123; thumb = revitionImageSize(sourcePath); &#125; put(path,thumb); if(callback != null)&#123; h.post(new Runnable()&#123; @Override public void run() &#123; callback.imageLoad(iv, thumb, sourcePath); &#125; &#125;); &#125; &#125; &#125;.strat(); &#125; public Bitmap revitionImageSize(String path) throws IOException &#123; BufferedInputStream in = new BufferedInputStream(new FileInputStream( new File(path))); BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeStream(in, null, options); in.close(); int i = 0; Bitmap bitmap = null; while (true) &#123; if ((options.outWidth &gt;&gt; i &lt;= 256) &amp;&amp; (options.outHeight &gt;&gt; i &lt;= 256)) &#123; in = new BufferedInputStream( new FileInputStream(new File(path))); options.inSampleSize = (int) Math.pow(2.0D, i); options.inJustDecodeBounds = false; bitmap = BitmapFactory.decodeStream(in, null, options); break; &#125; i += 1; &#125; return bitmap; &#125; public interface ImageCallback &#123; public void imageLoad(ImageView imageView, Bitmap bitmap, Object... params); &#125;&#125; AlbumHelper 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252public class AlbumHelper &#123; private final String TAG = getClass().getSimpleName(); private Context context; private ContentResolver cr; // 缩略图列表 public HashMap&lt;String, String&gt; thumbnailList = new HashMap&lt;String, String&gt;(); // 专辑列表 private List&lt;HashMap&lt;String, String&gt;&gt; albumList = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); private HashMap&lt;String, ImageBucket&gt; bucketList = new HashMap&lt;String, ImageBucket&gt;(); private static AlbumHelper instance; private AlbumHelper() &#123; &#125; public static AlbumHelper getHelper() &#123; if (instance == null) &#123; instance = new AlbumHelper(); &#125; return instance; &#125; /** * 初始化 * * @param context */ public void init(Context context) &#123; if (this.context == null) &#123; this.context = context; cr = context.getContentResolver(); &#125; &#125; /** * 得到缩略图 */ private void getThumbnail() &#123; String[] projection = &#123; Thumbnails._ID, Thumbnails.IMAGE_ID, Thumbnails.DATA &#125;; Cursor cursor = cr.query(Thumbnails.EXTERNAL_CONTENT_URI, projection, null, null, null); getThumbnailColumnData(cursor); &#125; /** * 从数据库中得到缩略图 * * @param cur */ private void getThumbnailColumnData(Cursor cur) &#123; if (cur.moveToFirst()) &#123; int _id; int image_id; String image_path; int _idColumn = cur.getColumnIndex(Thumbnails._ID); int image_idColumn = cur.getColumnIndex(Thumbnails.IMAGE_ID); int dataColumn = cur.getColumnIndex(Thumbnails.DATA); do &#123; _id = cur.getInt(_idColumn); image_id = cur.getInt(image_idColumn); image_path = cur.getString(dataColumn); thumbnailList.put(\"\" + image_id, image_path); &#125; while (cur.moveToNext()); &#125; &#125; /** * 得到原图 */ private void getAlbum() &#123; String[] projection = &#123; Albums._ID, Albums.ALBUM, Albums.ALBUM_ART, Albums.ALBUM_KEY, Albums.ARTIST, Albums.NUMBER_OF_SONGS &#125;; Cursor cursor = cr.query(Albums.EXTERNAL_CONTENT_URI, projection, null, null, null); getAlbumColumnData(cursor); &#125; /** * 从本地数据库中得到原图 * * @param cur */ private void getAlbumColumnData(Cursor cur) &#123; if (cur.moveToFirst()) &#123; int _id; String album; String albumArt; String albumKey; String artist; int numOfSongs; int _idColumn = cur.getColumnIndex(Albums._ID); int albumColumn = cur.getColumnIndex(Albums.ALBUM); int albumArtColumn = cur.getColumnIndex(Albums.ALBUM_ART); int albumKeyColumn = cur.getColumnIndex(Albums.ALBUM_KEY); int artistColumn = cur.getColumnIndex(Albums.ARTIST); int numOfSongsColumn = cur.getColumnIndex(Albums.NUMBER_OF_SONGS); do &#123; _id = cur.getInt(_idColumn); album = cur.getString(albumColumn); albumArt = cur.getString(albumArtColumn); albumKey = cur.getString(albumKeyColumn); artist = cur.getString(artistColumn); numOfSongs = cur.getInt(numOfSongsColumn); Log.i(TAG, _id + \" album:\" + album + \" albumArt:\" + albumArt + \"albumKey: \" + albumKey + \" artist: \" + artist + \" numOfSongs: \" + numOfSongs + \"---\"); HashMap&lt;String, String&gt; hash = new HashMap&lt;String, String&gt;(); hash.put(\"_id\", _id + \"\"); hash.put(\"album\", album); hash.put(\"albumArt\", albumArt); hash.put(\"albumKey\", albumKey); hash.put(\"artist\", artist); hash.put(\"numOfSongs\", numOfSongs + \"\"); albumList.add(hash); &#125; while (cur.moveToNext()); &#125; &#125; /** * 是否创建了图片集 */ private boolean hasBuildImagesBucketList = false; /** * 得到图片集 */ private void buildImagesBucketList() &#123; long startTime = System.currentTimeMillis(); // 构造缩略图索引 getThumbnail(); // 构造相册索引 String columns[] = new String[] &#123; Media._ID, Media.BUCKET_ID, Media.PICASA_ID, Media.DATA, Media.DISPLAY_NAME, Media.TITLE, Media.SIZE, Media.BUCKET_DISPLAY_NAME &#125;; // 得到一个游标 Cursor cur = cr.query(Media.EXTERNAL_CONTENT_URI, columns, null, null, null); if (cur.moveToFirst()) &#123; // 获取指定列的索引 int photoIDIndex = cur.getColumnIndexOrThrow(Media._ID); int photoPathIndex = cur.getColumnIndexOrThrow(Media.DATA); int photoNameIndex = cur.getColumnIndexOrThrow(Media.DISPLAY_NAME); int photoTitleIndex = cur.getColumnIndexOrThrow(Media.TITLE); int photoSizeIndex = cur.getColumnIndexOrThrow(Media.SIZE); int bucketDisplayNameIndex = cur .getColumnIndexOrThrow(Media.BUCKET_DISPLAY_NAME); int bucketIdIndex = cur.getColumnIndexOrThrow(Media.BUCKET_ID); int picasaIdIndex = cur.getColumnIndexOrThrow(Media.PICASA_ID); // 获取图片总数 int totalNum = cur.getCount(); do &#123; String _id = cur.getString(photoIDIndex); String name = cur.getString(photoNameIndex); String path = cur.getString(photoPathIndex); String title = cur.getString(photoTitleIndex); String size = cur.getString(photoSizeIndex); String bucketName = cur.getString(bucketDisplayNameIndex); String bucketId = cur.getString(bucketIdIndex); String picasaId = cur.getString(picasaIdIndex); Log.i(TAG, _id + \", bucketId: \" + bucketId + \", picasaId: \" + picasaId + \" name:\" + name + \" path:\" + path + \" title: \" + title + \" size: \" + size + \" bucket: \" + bucketName + \"---\"); ImageBucket bucket = bucketList.get(bucketId); if (bucket == null) &#123; bucket = new ImageBucket(); bucketList.put(bucketId, bucket); bucket.imageList = new ArrayList&lt;ImageItem&gt;(); bucket.bucketName = bucketName; &#125; bucket.count++; ImageItem imageItem = new ImageItem(); imageItem.imageId = _id; imageItem.imagePath = path; imageItem.thumbnailPath = thumbnailList.get(_id); bucket.imageList.add(imageItem); &#125; while (cur.moveToNext()); &#125; // Interator为迭代器，Entry为Map接口 // 遍历所有图片 Iterator&lt;Entry&lt;String, ImageBucket&gt;&gt; itr = bucketList.entrySet() .iterator(); while (itr.hasNext()) &#123; Map.Entry&lt;String, ImageBucket&gt; entry = (Map.Entry&lt;String, ImageBucket&gt;) itr .next(); ImageBucket bucket = entry.getValue(); Log.d(TAG, entry.getKey() + \", \" + bucket.bucketName + \", \" + bucket.count + \" ---------- \"); for (int i = 0; i &lt; bucket.imageList.size(); ++i) &#123; ImageItem image = bucket.imageList.get(i); Log.d(TAG, \"----- \" + image.imageId + \", \" + image.imagePath + \", \" + image.thumbnailPath); &#125; &#125; hasBuildImagesBucketList = true; long endTime = System.currentTimeMillis(); Log.d(TAG, \"use time: \" + (endTime - startTime) + \" ms\"); &#125; /** * 得到图片集 * * @param refresh * @return */ public List&lt;ImageBucket&gt; getImagesBucketList(boolean refresh) &#123; if (refresh || (!refresh &amp;&amp; !hasBuildImagesBucketList)) &#123; buildImagesBucketList(); &#125; List&lt;ImageBucket&gt; tmpList = new ArrayList&lt;ImageBucket&gt;(); Iterator&lt;Entry&lt;String, ImageBucket&gt;&gt; itr = bucketList.entrySet() .iterator(); while (itr.hasNext()) &#123; Map.Entry&lt;String, ImageBucket&gt; entry = (Map.Entry&lt;String, ImageBucket&gt;) itr .next(); tmpList.add(entry.getValue()); &#125; return tmpList; &#125; /** * 根据图片的_ID得到原始图像路径 * * @param image_id * @return */ public String getOriginalImagePath(String image_id) &#123; String path = null; Log.i(TAG, \"---(^o^)----\" + image_id); String[] projection = &#123; Media._ID, Media.DATA &#125;; Cursor cursor = cr.query(Media.EXTERNAL_CONTENT_URI, projection, Media._ID + \"=\" + image_id, null, null); if (cursor != null) &#123; cursor.moveToFirst(); path = cursor.getString(cursor.getColumnIndex(Media.DATA)); &#125; return path; &#125;&#125; layout相册选取layout123456789101112131415161718192021222324252627282930313233343536373839&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"# f1eff5\" android:orientation=\"vertical\" &gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"# ff495a\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:text=\"相册\" android:textColor=\"# ffffff\" android:textSize=\"20sp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"40dp\" android:gravity=\"center\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_marginRight=\"8dp\" android:textColor=\"@drawable/text_while\" android:text=\"取消\" android:textSize=\"20sp\" /&gt; &lt;/RelativeLayout&gt; &lt;GridView android:id=\"@+id/gridview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"10dp\" android:horizontalSpacing=\"20dp\" android:numColumns=\"2\" android:scrollbars=\"none\" android:verticalSpacing=\"20dp\" &gt; &lt;/GridView&gt;&lt;/LinearLayout&gt; 图片选取layout 123456789101112131415161718192021222324252627282930313233343536373839&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"# f1eff5\" android:orientation=\"vertical\" &gt; &lt;RelativeLayout android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"# ff495a\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:text=\"相册\" android:textColor=\"# ffffff\" android:textSize=\"20sp\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"40dp\" android:gravity=\"center\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:layout_marginRight=\"8dp\" android:textColor=\"@drawable/text_while\" android:text=\"取消\" android:textSize=\"20sp\" /&gt; &lt;/RelativeLayout&gt; &lt;GridView android:id=\"@+id/gridview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"10dp\" android:horizontalSpacing=\"20dp\" android:numColumns=\"2\" android:scrollbars=\"none\" android:verticalSpacing=\"20dp\" &gt; &lt;/GridView&gt;&lt;/LinearLayout&gt; 图片预览layout 12345678910111213141516171819202122232425262728293031323334353637&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/android.support.v4.view.ViewPager&gt; &lt;RelativeLayout android:id=\"@+id/photo_relativeLayout\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:layout_alignParentBottom=\"true\" &gt; &lt;Button android:id=\"@+id/photo_bt_exit\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_alignParentLeft=\"true\" android:layout_centerVertical=\"true\" android:background=\"@drawable/bt_quxiao\" /&gt; &lt;Button android:id=\"@+id/photo_bt_del\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_centerInParent=\"true\" android:background=\"@drawable/bt_shanchu\" /&gt; &lt;Button android:id=\"@+id/photo_bt_enter\" android:layout_width=\"50dp\" android:layout_height=\"50dp\" android:layout_alignParentRight=\"true\" android:layout_centerVertical=\"true\" android:background=\"@drawable/bt_queding\" /&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"写在决赛之前","date":"2014-07-09T01:32:42.000Z","path":"2014/07/09/写在决赛之前/","text":"除了揭幕战，今天又真真的熬完了整整一场比赛的直播。开赛前就冥冥感觉，这场不一般，当然我不是马后炮的证明我猜到了大胜，赛前我的预想只是净胜2球，德意志已经超过我的想象。其实比，大胜更让我欣喜的是，米洛进球了。那一刻，真的想流泪，即使段暄还在感叹节奏的突变，与接二连三的进球，人们视乎忘了，这个德国人破纪录了。没有欢呼，没有庆贺，没有空翻，一切平平淡淡。就像克洛泽一样，一个平凡的不能再平凡的球员，没错，在很多定义上他都算不上球星。他不张扬，个性内敛和谦逊，小时候优良的家境和艺术教育的烘托使得他跟一般的球员在性格上可以被归属为文艺派。克洛泽从未在联赛中大杀四方，也没有在世界杯上君临天下，他总是在适当的时候，出现在适当的位置，做了适当的事情。这就是德国人的冷静、铁血、严谨，这是与生俱来的天性。他不是足球天才，23岁的时候甚至还是业余球球，这个岁数的梅西已经功成名就。不是每个人都能成为字母罗、内马尔或者梅西，但每个人都可以成为克洛泽————或者说，成为这个时空中、这番命运下那个最好的自己。 02年世界杯的时候，那个时候我还懵懵懂懂，决赛日，我和老爸在电视前，我穿着我新买不久的巴西队服，看着除了巴西队不怎么熟悉的面孔，为罗纳尔多的进球欢呼雀跃，但是那场比赛，却让我喜欢上了，卡恩和金发碧眼的克洛泽，甚至我自己都不知道缘由。06年，金色轰炸机克林斯曼职教德国，那届的德国打的真是漂亮，不知道那一届诞生了多少德国脑残粉。点球救主的莱曼，小猪施魏因斯泰格，已经屈居二线的卡恩，大着石膏扔界外球的拉姆，还有些青涩的波多尔斯基，还有巴拉克，还有克洛泽。那一届德国踢得那么好，那么漂亮，还是输给了亚平宁骑士，防守至上的意大利。至今，我还记恨那支冠军，马特拉齐的咒骂，齐祖的惨淡谢幕与大力神杯擦肩而过，更可恨的是他们淘汰了德国，那支最美的德国。10年，德国新人辈出，诺伊尔、厄齐尔、巴阿滕、还有神奇小子穆勒。可惜巴拉克，赛前的伤退，让这个德国人永远的告别了世界杯。我这届德国一如既往的强，可惜既生瑜何生亮，如日中天的西班牙在那个时空，仿佛不可战胜。02年，我们输给了天赋异禀的巴西，06年，我们输给了沉稳的意大利，10年，我们输给了不可战胜的西班牙。14年，我们离冠军只差一场胜利，加油，德意志。","tags":[{"name":"杂文","slug":"杂文","permalink":"http://seniorzhai.github.io/tags/杂文/"}]},{"title":"响应不同的请求","date":"2014-07-08T03:22:59.000Z","path":"2014/07/08/响应不同的请求/","text":"123456789nodevar url = require('url')var requestURL = 'http://example.com:1234/pathname?query=string# hash'// 获取主机名url.parse(requestURL).hostname// 获取路径端口url.parse(requestURL).port// 获取路径名url.parse(requestURL).pathname","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"}]},{"title":"Android发送短信权限","date":"2014-07-07T05:37:21.000Z","path":"2014/07/07/Android发送短信权限/","text":"权限12345678&lt;!-- 发送消息 --&gt;&lt;uses-permission android:name=\"android.permission.SEND_SMS\" /&gt;&lt;!-- 阅读消息 --&gt;&lt;uses-permission android:name=\"android.permission.READ_SMS\" /&gt;&lt;!-- 写入消息 --&gt;&lt;uses-permission android:name=\"android.permission.WRITE_SMS\" /&gt;&lt;!-- 接收消息 --&gt;&lt;uses-permission android:name=\"android.permission.RECEIVE_SMS\" /&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"使用ContentProvider管理App数据","date":"2014-07-07T05:36:43.000Z","path":"2014/07/07/使用ContentProvider管理App数据/","text":"工具类 Column用于管理字段 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Column &#123; // 约束 public static enum Constraint &#123; UNIQUE(\"UNIQUE\"), NOT(\"NOT\"), NULL(\"NULL\"), CHECK(\"CHECK\"), FOREIGN_KEY( \"FOREIGN KEY\"), PRIMARY_KYE(\"PRIMARY KEY\"); private String value; private Constraint(String value) &#123; this.value = value; &#125; @Override public String toString() &#123; return value; &#125; &#125; // 数据类型 public static enum DataType &#123; NULL, INTEGER, REAL, TEXT, BLOB &#125; private String mColumnName; private Constraint mConstraint; private DataType mDataType; public Column(String columnName, Constraint constraint, DataType dataType) &#123; mColumnName = columnName; mConstraint = constraint; mDataType = dataType; &#125; public String getColumnName() &#123; return mColumnName; &#125; public Constraint getConstraint() &#123; return mConstraint; &#125; public DataType getDataType() &#123; return mDataType; &#125;&#125; SQLiteTable用于表管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SQLiteTable &#123; String mTableName; ArrayList&lt;Column&gt; mColumnsDefinitions = new ArrayList&lt;Column&gt;(); public String getTableName() &#123; return mTableName; &#125; // 自动添加主键_ID public SQLiteTable(String tableName) &#123; mTableName = tableName; mColumnsDefinitions.add(new Column(BaseColumns._ID, Column.Constraint.PRIMARY_KYE, Column.DataType.INTEGER)); &#125; public SQLiteTable addColumn(Column columnsDefinition) &#123; mColumnsDefinitions.add(columnsDefinition); return this; &#125; public SQLiteTable addColumn(String columnName, Column.DataType dataType) &#123; mColumnsDefinitions.add(new Column(columnName, null, dataType)); return this; &#125; public SQLiteTable addColumn(String columnName, Column.Constraint constraint, Column.DataType dataType) &#123; mColumnsDefinitions.add(new Column(columnName, constraint, dataType)); return this; &#125; // 在SQLite中创建本表 public void create(SQLiteDatabase db) &#123; String formatter = \" %s\"; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\"CREATE TABLE IF NOT EXISTS \"); stringBuilder.append(mTableName); stringBuilder.append(\"(\"); int columnCount = mColumnsDefinitions.size(); int index = 0; for (Column columnsDefinition : mColumnsDefinitions) &#123; stringBuilder.append(columnsDefinition.getColumnName()).append( String.format(formatter, columnsDefinition.getDataType() .name())); Column.Constraint constraint = columnsDefinition.getConstraint(); if (constraint != null) &#123; stringBuilder.append(String.format(formatter, constraint.toString())); &#125; if (index &lt; columnCount - 1) &#123; stringBuilder.append(\",\"); &#125; index++; &#125; stringBuilder.append(\");\"); db.execSQL(stringBuilder.toString()); &#125; // 在SQLite中删除本表 public void delete(final SQLiteDatabase db) &#123; db.execSQL(\"DROP TABLE IF EXISTS \" + mTableName); &#125;&#125; 数据库操作类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class BaseDataHelper &#123; private Context mContext; public BaseDataHelper(Context context) &#123; mContext = context; &#125; public Context getContext() &#123; return mContext; &#125; protected abstract Uri getContentUri(); public void notifyChange() &#123; mContext.getContentResolver().notifyChange(getContentUri(), null); &#125; protected final Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return mContext.getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder); &#125; protected final Cursor query(String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return mContext.getContentResolver().query(getContentUri(), projection, selection, selectionArgs, sortOrder); &#125; protected final Uri insert(ContentValues values) &#123; return mContext.getContentResolver().insert(getContentUri(), values); &#125; protected final int bulkInsert(ContentValues[] values) &#123; return mContext.getContentResolver() .bulkInsert(getContentUri(), values); &#125; protected final int update(ContentValues values, String where, String[] whereArgs) &#123; return mContext.getContentResolver().update(getContentUri(), values, where, whereArgs); &#125; protected final int delete(Uri uri, String selection, String[] selectionArgs) &#123; return mContext.getContentResolver().delete(getContentUri(), selection, selectionArgs); &#125; protected final Cursor getList(String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return mContext.getContentResolver().query(getContentUri(), projection, selection, selectionArgs, sortOrder); &#125; public CursorLoader getCursorLoader(Context context) &#123; return getCursorLoader(context, null, null, null, null); &#125; protected final CursorLoader getCursorLoader(Context context, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; return new CursorLoader(context, getContentUri(), projection, selection, selectionArgs, sortOrder); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android Sqlite Tips","date":"2014-07-04T05:35:49.000Z","path":"2014/07/04/Android-Sqlite-Tips/","text":"Add column1ALTER TABLE &#123;tableName&#125; ADD COLUMN COLNew &#123;type&#125;; 2.Delete column,Rename columnsqlite3不允许指直接delete，rename只能进行以下操作12create table temp(id integer PRIMARY KEY,code varchar(255));insert into temp(id,code) select id ,code from t; 3.Rename table1alter table foo rename to bar 4.Copy data from one sqlite file to another12attach 'database2file' as db2;insert into TANLENAME select * from db2.TANLENAME; 5.导出sql123sqlite3. data.db&gt;.output dd.sql&gt;.dump 6.导入12sqlite3 mydb.db&gt;.read dd.sql 7.释放空间1vacuum 一些SQLite命令 database 列出数据库文件名 tables ?PATTERN? 列出?PATTERN?匹配的表名 import FILE TABLE 将文件中的数据导入表中 dump ?TABLE? 生成形成数据表的SQL脚本 output FILENAME 将输出导入到指定的文件中 output stdout 将输出打印到屏幕 mode MODE ?TABLE? 设置数据输出模式(csv,html,tcl…) nullvalue STRING 用指定的串代替输出的NULL串 read FILENAME 指定指定文件中的SQL语句 schema ?STRING? 打印创建数据库表的SQL语句 separator STRING 用指定的字符串代替字段分隔符 show 打印所有SQLite环境变量的设置 quite 推出命令行接口","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Drawerlayout","date":"2014-07-04T05:35:17.000Z","path":"2014/07/04/Drawerlayout/","text":"使用DrawerLayout类在Support Library里，有android-support-v4.jar这个包即可 1234567891011121314151617181920212223242526272829&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;FrameLayout android:id=\"@+id/content_frame\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; &lt;ListView android:id=\"@+id/left_drawer\" android:layout_width=\"240dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"left\" android:background=\"# 111\" android:choiceMode=\"singleChoice\" android:divider=\"@android:color/transparent\" android:dividerHeight=\"0dp\" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/RelativeLayout&gt;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Uri、UriMatcher、CententUris详解","date":"2014-07-03T05:33:21.000Z","path":"2014/07/03/Uri、UriMatcher、CententUris详解/","text":"Uri通用资源标志符(Universal Resource Ident，简称”URI”)Uri代表要操作的数据，Android上可用的每种资源——图片、视频等资源都可以用Uri表示URI一般分为三个部分组成：访问资源的命名机制，存放资源的主机名,资源自身的名字，由路径表示 Android的Uri由以下三部分组成：”content://“、数据的路径、标示ID(可选)如： 所有联系人的Uri：content://contacts/people 某个联系人的Uri：content://contacts/people/5 所有图片Uri:content://media/external 某个图片的Uri:content://media/external/images/media/4 UriMatcherUriMatcher类主要用于匹配Uri使用方法如下，初始化：1UriMathcer matcher = new UriMatcher(UriMatcher.NO_MATCH); 第二步注册需要的Ur:12matcher.addURI(\"com.zoe.blog\",\"people\",PEOPLE);matcher.addURI(\"com.zoe.blog\", \"person/# \", PEOPLE_ID); 第三部，与已经注册的Uri进行匹配:1234567891011Uri uri = Uri.parse(\"content://\" + \"com.zoe.blog\" + \"/people\");int match = matcher.match(uri);switch(match)&#123; case PEOPLE: return \"vnd.android.cursor.dir/people\"; case PEOPLE_ID: return \"vnd.android.cursor.item/people\"; default: return null;&#125; match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。 常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码 # 号为通配符 *号为任意字符 CententUrisContentUris类用于获取Uri路径后面的ID部分12345Uri uri = Uri.parse(&quot;content://com.zoe.demo/people&quot;);Uri resultUri = ContentUris.withAppendedId(uri,10);//resultUri为：content://com.zoe.demo/people/10ling id = ContentUris.parseId(uri);//id = 10","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Eclipse导入Gradle项目","date":"2014-07-02T05:32:22.000Z","path":"2014/07/02/Eclipse导入Gradle项目/","text":"Importing gradle project to eclipse 打开build.gradle文件，在第一行添加以下代码 1apply plugin &apos;eclipse&apos; 在项目所在目录下运行以下命令Windows下 1gradlew.bat eclipse mac或linux下1./gradlew eclipse 最后导入Eclipse中即可","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"EclipseADT迁移到AndroidStudio","date":"2014-07-02T05:31:41.000Z","path":"2014/07/02/EclipseADT迁移到AndroidStudio/","text":"AndroidStudio是Google I/O 2013大会上推出的Android开发环境，基于IntelliJ IDEA，和EclipseADT类似。AudioStudio使用Gradle来构建项目。Gradle是一款自动化编译部署测试工具。 AndroidStudio官方主页 为何 IntelliJ IDEA 比 Eclipse 更好 Gradle等构建系统使用介绍 本文主要介绍如果将EclipseADT的项目迁移到AndroidStudio。1.为项目生成Gradle所需的文件 项目节本结构 ADT版本在22以上，在项目上右击-&gt;Export，然后选择Generate Gradle build files。 一路next，直到finish。搞定，这时候已经生成Gradle的相关文件，此时的结构 2.在AndroidStudio中导入项目 打开AudioStudio，选择Import Project，选择项目的目录。OK即可导入。 主要就是build.gradle文件。 扩展阅读 参考官方说明 Migrating from Eclipse AndroidStudio快捷键","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"node.js入门(二)","date":"2014-07-01T09:22:41.000Z","path":"2014/07/01/node.js入门(二)/","text":"ExpressExpress是Node.js的一个Web框架，Web应用程序有公用的模式，所以使用框架来构建经常事半功倍。其他一些成熟的框架，比如： Ruby on Rails(Ruby) Sinatra(Ruby) Django(Python) Zend(PHP) CodeIgniter(PHP) 一些使用Express能做的事情有： 基于JSON的API 单页面Web应用程序 事实Web应用程序 安装Express：npm install -g express使用-g标记表示Express将是全局安装。 Express项目文件结构如下： app.jsapp.js是用来启动应用程序的应用程序文件夹，它包含应用程序的配置信息。 node_modules用来保存在pack.json中定义并且已经安装的Node模块 package.json提供应用程序的信息，包括运行应用程序所需安装的依赖模块 publicWeb进行服务的公共文件夹，在这个文件夹中可以看到样式单、javascript和图片 routes路由，定义了应用程序应该响应的页面 views视图文件夹定义应用程序的布局在views文件夹有很多以.jade为扩展名的文件，Express利用模板引擎将视图编译成HTML，默认情况，Express使用Jade作为模板引擎。JadeJade通过缩进定义页面结构，如果一行在上一行下面缩进，就认为它是上一行的子行。 html 编译后是： 这里可以使用任何HTML标记(body、section、p等等) 要给标记使用id，可加上一个#号后跟id名称，注意不允许有空格section# wrapper 编译后： 可以添加一个类，方法是加上一个小数点后跟类的名称。p.highlight 编译后： 急需要类也需要idsection# wrapper.class-name 编译后： Jade也支持在一个标记上有多个类p.first.second.third.fourth 编译后： 为了创建HTML结构，要使用缩进12p span 编译后：1&lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt; 要标记中加入文本，只需在标记定义后加入即可h1 Very important heading 编译后： Very important heading Jade支持管道描述符(|)组织大文本1234p | Text can be over | many lines | after a pipe symbol 编译后：1&lt;p&gt;Text can be over many lines after a pipe symbol&lt;/p&gt; Jade输出数据Jade使用两个特殊符号来决定应该如何翻译代码，当一个字符是减号(-)，用于告诉随后的代码应当被执行。第二个字符是字符(=)告诉解释器要对对代码进行演算、转义，然后输出。 变量 -var foo = bar变量设置之后可以再以后使用：p I want to learn to use variables.Foo is # {foo}!”# {变量}“这个特殊语法将用变量来代替：I want to learn to use variables.Foo is bar!循环循环用来迭代数组和对象。 123- users = [&apos;Sally&apos;,&apos;Joseph&apos;,&apos;Michael&apos;,&apos;Sanjay&apos;]- each user in users p= user 编译后：1234&lt;p&gt;Sally&lt;/p&gt;&lt;p&gt;Joseph&lt;/p&gt;&lt;p&gt;Michael&lt;/p&gt;&lt;p&gt;Sanjay&lt;/p&gt; 也可以使用for关键字 12- for user in users p= user 对象进行迭代： 12345- obj = &#123;first_name:&apos;George&apos;,surname:&apos;Ornbo&apos;&#125;- each val,key in obj li # &#123;key&#125;:# &#123;val&#125;``` 编译后： first_name:George surname:Ornbo1#### 条件 awake = false if (awake)p You are awake! Make coffee! elsep You are sleeping12`if`和`else`关键字之前的减号(-)是可选的#### 内联(inline)JavaScript script alert(‘You can execute inline JavaScript through Jade’)12##### 包含(include)Jade通过include关键字后跟想要包含的模板来支持包含功能 html body include includes/header```","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"}]},{"title":"node.js入门(一)","date":"2014-07-01T03:22:28.000Z","path":"2014/07/01/node.js入门(一)/","text":"用于Windows和OS X的安装程序可以再Node.js的主页下载:http://nodejs.org/ 验证Node.js是否正确安装在命令行中输入node可以看到以下提示: First Code1234567// server.jsvar http = require('http')http.createServer(function (req,res)&#123; res.writeHead(200,&#123;'Content-Type':'text/plain'&#125;); res.end('Hello Node.js\\n');&#125;).listen(3000,\"127.0.0.1\");console.log(\"Server running at http://128.0.0.1:3000/\"); 在命令行中执行node server.js，一个简单的web吴福气就完成了 npmnpm(Node Package Manager)是Node.js的包管理器，它允许开发者在Node.js应用程序中创建、共享并重用模块。 安装模块npm install [module_name] 使用模块下载之后必须请求(require)它们，var module = require(&#39;module&#39;); 如何找模块 官方来源：在http://search.npmjs.org/上有一个官方基于Web的npm搜索工具。也可以在nmp命令行工具来搜索Node.js模块npm search irc 非官方来源：如http://blago.dachev.com/modules站点，该站点可以提供了Github上某个项目的围观者数量、分叉(fork)数量以及问题数量。或者http://eirikb.github.com/nipster/根据GitHub上的分叉数量对项目评级。 本地和全局的安装 本地安装：本地安装意味着库将安装在项目本地的一个名为node_modules的文件夹下以便项目使用，这是默认行为。├ foo.js├ node_modules/module_name 全局安装：有些模块可能任何一个位置都能运行这些可执行文件，需要全局安装，只需要在安装时加上-g标记。npm install -g express 查找模块文档 通过npm docs [module_name]一般就能查看文件，还可以使用npm bugs [module_name]查看项目的Bug 使用package.json指定依赖关系(dependency) npm允许开发人员使用package.json文件来指定应用程序中要用的模块，并且通过单个命令来安装它们npm install，如下例 创建一个模块foo.js 1234var _ = require('underscore');_.each([1,2,3],function(num)&#123; console.log(\"underscore.js says \" + num);&#125;); 创建一个package.json 1234567&#123; &quot;name&quot;:&quot;example02&quot;, &quot;version&quot;:&quot;0.0.1&quot;, &quot;dependencies&quot;:&#123; &quot;underscore&quot;:&quot;~1.2.1&quot; &#125;&#125; 运行npm install可以看在underscore库安装在了node_modules文件夹下 Node.js目的Node.js网站提供了的队Node.js的一段简短描述 Node.js是构建在Chrome的JavaScript运行时之上的一个平台，用于简单构建快速的、可扩展的网络应用程序。Node.js使用事件驱动的、非阻塞的I/O模型，这让其既轻量又高效，是运行于不同发布设备上的数据密集型实时应用程序的完美平台。 回调函数可以被作为参数传递到另一个函数中，然后被调用。123456789var fs = require('fs');fs.readFile('somefile.txt','utf8',function(err,data)&#123; if(err)throw err;&gt; Blockquote console.log(data);&#125;); fs(filesystem)模块被请求，以便在脚本中使用 将文件系统上的文件路径作为第一个参数提供给fs.readFile方法 第二个参数是utf8，表示文件编码 被回调函数作为第三个参数提供给fs.readFile方法 回调函数的第一个参数是err，用于保存在读取文件时返回错误 回调函数的第二个参数是data，用于保存读取文件所返回的数据 一旦文件被读取，回调就会被调用 如果err为真，那么就会抛出错误 如果err为假，那么来自文件的数据就可以使用 使用curl查看HTTP表头","tags":[{"name":"node.js","slug":"node-js","permalink":"http://seniorzhai.github.io/tags/node-js/"}]},{"title":"ContentProvider","date":"2014-06-25T05:30:54.000Z","path":"2014/06/25/ContentProvider/","text":"概述ContentProvider是Android应用对外开放的数据接口，只要符合它所定义的Uri格式的请求，均可以正常访问执行操作。其他的Android应用可以使用ContentResolver对象通过与ContentProvider同名的方法请求执行，被执行的就是ContentProvider中的同名的方法。所以ContentProvider很多对外可以访问的方法，在ContentResolver中均有同名的方法，是一一对应的，如图： Uri在Android中，Uri是一种比较常见的资源访问方式，而对ContentProvider而言，Uri也是有固定格式的： ://// ：ContentProvider的srandard_prefix始终是content:// ：ContentProvider的名称 ：请求的数据类型 ：指定请求的特定数据 ContentProvider ContentProvider也是Android应用的四大组件之一，所以也需要在AndroidManifest.xml文件中进行配置。而且某个应用程序通过ContentProvider暴露了自己的数据操作接口，那么不管该应用程序是否启动，其他应用程序都可以通过这个接口来操作它的内部数据。 Android附带了许多有用的ContentProvider，但是本篇博客不会涉及到这些内容的，以后有时间会再讲解。Android附带的ContentProvider包括： Browser：存储如浏览器的信息。 CallLog：存储通话记录等信息。 Contacts：存储联系人等信息。 MediaStore：存储媒体文件的信息。 Settings：存储设备的设置和首选项信息。在Android中，如果要创建自己的内容提供者的时候，需要扩展抽象类ContentProvider，并重写其中定义的各种方法。然后在AndroidManifest.xml文件中注册该ContentProvider即可。 ContentProvider是内容提供者，实现Android应用之间的数据交互，对于数据操作，无非也就是CRUD而已。下面是ContentProvider必须要实现的几个方法： onCreate()：初始化提供者。 query(Uri, String[], String, String[], String)：查询数据，返回一个数据Cursor对象。 insert(Uri, ContentValues)：插入一条数据。 update(Uri, ContentValues, String, String[])：根据条件更新数据。 delete(Uri, String, String[])：根据条件删除数据。 getType(Uri) 返回MIME类型对应内容的URI。 除了onCreate()和getType()方法外，其他的均为CRUD操作，这些方法中，Uri参数为与ContentProvider匹配的请求Uri，剩下的参数可以参见SQLite的CRUD操作，基本一致。还有两个方法：call()和bulkInsert()方法，使用call，理论上可以在ContentResolver中执行ContentProvider暴露出来的任何方法，而bulkInsert()方法用于插入多条数据。 在ContentProvider的CRUD操作，均会传递一个Uri对象，通过这个对象来匹配对应的请求，那么如何确定一个Uri执行哪项操作呢？需要用到一个UriMatcher对象，这个对象用来帮助内容提供者匹配Uri，它所提供的方法非常简单，仅有两个： void addURI(String authoity,String path,int code):添加一个Uri匹配项，authtity为AndroidManifest.xml中注册的ContentProvider的authority属性；path为一个路径，可以设置通配符，# 表示任意数字，*表示任意字符；code为自定义的一个Uri代码 int match(Uri uri):匹配传递的Uri，返回addUri()传递的Code参数。 在创建好一个ContentProvider之后，还需要在AndroidManifest.xml文件中对ContentProvider进行配置，使用一个节点，一般只需要设置两个属性即可访问，一些额外的属性就是为了设置访问权限而存在的 android:name:provide的响应类 android:authorities:Provider的唯一标识，用于Uri匹配，一般为ContentProvider类的全名 ContentResolverContentResolver，内容访问者。可以通过ContentResolver来操作ContentProvider所暴露处理的接口。一般使用Content.getContentResolver()方法获取ContentResolver对象，上面已经提到ContentResolver的很多方法与ContentProvider————对应，所以它存在insert、query、update、delete等方法。 getType()中的MIMEMIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型。在ContentProvider中的getType方法，返回的就是一个MIME的字符串。如果支持需要使用ContentProvider来访问数据，getType()完全可以返回一个Null，并不影响效果，但是覆盖ContentProvider的getType方法对于用new Intent(String action,Uri uri)方法启动activity是很重要的，如果它返回的MIME type和activity在中定义的data的MIME type不一致，将造成activity无法启动。getType返回的字符串，如果URI针对的是单条数据，则返回的字符串以vnd.android.cursor.item/开头；如果是多条数据，则以vnd.android.cursor.dir/开头。 访问权限对于ContentProvider暴露出来的数据，应该是储存在自己应用内存中的数据，对于一些储存在外部储存器上发数据，并不能限制访问权限，使用ContentProvider就没有意义了。对于ContentProvider而言，有很多权限控制，可以AndroidManifest.xml文件中对节点的属性进行配置，一般使用如下一些属性设置： android:grantUriPermssions:临时许可标志。 android:permission:Provider读写权限。 android:readPermission:Provider的读权限。 android:writePermission:Provider的写权限。 android:enabled:标记允许系统启动Provider。 android:exported:标记允许其他应用程序使用这个Provider。 android:multiProcess:标记允许系统启动Provider相同的进程中调用客户端。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Swift笔记(二)","date":"2014-06-25T05:10:04.000Z","path":"2014/06/25/Swift笔记(二)/","text":"基础部分数据类型基于C和Objective-C的基础上提出，Int是整形，Double和Float是浮点型，Bool是布尔型，String是字符串。Swift还有两个集合类型Array和Dictionary除了我们熟悉的类型，Swift 还增加了 Objective-C 中没有的类型比如元组（Tuple）。元组可以让你创建或者传递一组数据，比如作为函数的返回值时，你可以用一个元组可以返回多个值。Swift 还增加了可选（Optional）类型，用于处理值缺失的情况。可选表示“那儿有一个值，并且它等于 x ”或者“那儿没有值”。可选有点像在 Objective-C 中使用nil，但是它可以用在任何类型上，不仅仅是类。可选类型比 Objective-C 中的nil指针更加安全也更具表现力，它是 Swift 许多强大特性的重要组成部分。Swift 是一个类型安全的语言，会阻止不正确的值传递。 常量和变量常量和变量必须在使用前声明，用let来声明常量，用var来声明变量。12let a = 10var b = 1 以在一行中声明多个常量或者多个变量，用逗号隔开：1var x = 0.0, y = 0.0, z = 0.0 类型标注，在声明常量和变量的时候加上类型标注，说明变量或者常量要存储的类型。1var str:String 变量名不能包含数学符号，箭头，保留的关键字，Unicode码位，连线和制表符。不能以数字开头。 输出常量和变量使用println函数来输出当前的变量或常量的值：1println(myValue) 使用\\()语法可以将值转换成字符串类型1println(\"I have a value -- \\(myValue)\") 注释与C语言相通，可以使用//,/*做单行、多行注释，也可以嵌套12345678// 单行注释/* 多行注释 *//* 嵌套/* 注释 */ * 嵌套 */ 分号Swift 并不强制要求你在每条语句的结尾处使用分号（;）,同一行内写多条独立的语句则必须加上分号1let cat = &quot;pop&quot;;println(cat) 整数整数可以是有符号的或者无符号的如8位无符号整数的类型是UInt8，32位有符号的整数是Int32 整数范围可以根据不同数据类型的min和max来获取对应的最大值和最小值12let minValue = UInt8.minlet maxValue = UInt8.max Int长度默认与平台的原生字长相同 在32位平台上，Int和Int32长度相同。 在64位平台上，Int和Int64长度相同。 浮点数 Double表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。 Float表示32位浮点数。精度要求不高的话可以使用此类型。 类型安全和类型推断Swift 是一个类型安全（type safe）的语言。不匹配的类型会被标记为错误。12345let meaningOfLife = 42// meaningOfLife 会被推测为 Int 类型//如果你没有给浮点字面量标明类型，Swift 会推断你想要的是Double：let pi = 3.14159// pi 会被推测为 Double 类型 数值型字面量 一个十进制数，没有前缀 一个二进制数，前缀是0b 一个八进制数，前缀是0o 一个十六进制数，前缀是0x 如果一个十进制数的指数为exp，那这个数相当于基数和10^exp的乘积： 1.25e2 表示 1.25 × 10^2，等于 125.0。 1.25e-2 表示 1.25 × 10^-2，等于 0.0125。 如果一个十六进制数的指数为exp，那这个数相当于基数和2^exp的乘积： 0xFp2 表示 15 × 2^2，等于 60.0。 0xFp-2 表示 15 × 2^-2，等于 3.75。 类型别名类型别名（type aliases）就是给现有类型定义另一个名字。你可以使用typealias关键字来定义类型别名。1typealias AudioSample = UInt16 元组元组（tuples）把多个值组合成一个复合值。元组内的值可以使任意类型，并不要求是相同类型。1let http404Error = (400,\"Not Found\") 元组分解12let (statusCode,statusMessage) = http404Errorprintln(statusCode) //输出404 也可以使用一部分元组，忽略的部分使用下划线(_)标记1let (statusCode,_) = http404Error 也可以实现下标访问单个元素1let statusCode = http404Error.0 可以定于元组的时候给单个元素命名12let http200Status = (statusCode:200,description:\"OK\")println(http200Status.statusCode) 可选值(Optional)使用可选值来处理值可能缺失的情况12// 设置num是一个可选值，并赋值为3let num? Int = 3 if语句及强制解析if语句可以判断一个可选值是否包含值，如果可选类型有值返回ture，没有值返回false1234// num为一个可选值if var value = num &#123; // 有值&#125; 确定可选类型包含值后，可以再可选的名字后面加上感叹号(!)来获取值。这个感叹号表示：我知道这个可选值有值，请使用它1num!.toString() 可选绑定使用可选绑定来判断可选类型是否包含值，如果包含就把赋值给一个临时常量或者变量。1if let temp = someOptional nil可以给可选变量赋值为nil来表示它没有值12var someOptinal:Int? = nilsomeOptinal = 3 如果在声明可选变量或常量的时候没有赋值，默认设置为nil 隐式解析可选类型改用感叹号来声明一个隐式解析可选类型，隐式可选类型就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都解析来获取值。12let value : String! = \"Hello\"println(value) // 不需要value! 隐式解析可选类型主要被用作Swift中类的构造过程隐式解析可选类型可以被当做普通可选类型来判断它是否有值123if value &#123; // 有值&#125; 断言断言用作出结束代码运行并通过调试来找到原因 使用断言进行调试断言会在运行时判断一个逻辑条件是否为true，当条件为真，运行某段代码，条件为假，代码运行停止，应用被终止例如使用全局assert函数来写一个断言，向assert函数传入一个结果为true或者false的表达式以及一条信息，当表达式为false的时候这条信息会被显示123let age = -3assert(age &gt;= 0,&quot;岁数不能小于0&quot;)// 断言会被触发 何时使用断言当条件可能为假时使用断言，但是最终一定要保证条件为真，这样代码才能继续运行，断言的适用场景 整数类型的下标索引被传入一个自定义下标脚本实现，但是下标索引可能太小或者太大 需要给函数传入一个值，但是非法的值可能导致函数不能正常运行 一个可选值现在是nil，但是后续的代码运行时需要一个非nil值 基本运算符Swift支持大部分标准C语言的运算符，且改进许多特性来减少常规的编码错误，如：赋值符(=)不返回值，以防止把想要判断相等运算符(==)的地方写错导致赋值的错误。数值运算符(+，-，*，、，%)会检测并不允许值溢出。允许使用Swift的溢出运算符来实现溢出。区别于C语言，在Swift中可以对浮点数进行取余运算(%)，Swift还提供了表达两数之间的值的区间的运算符(a..b和a...b)表达一个区间的数值。 数值运算符赋值表达用一个值来初始化或更新变量或常量123let b = 10;var a = 5;a = b 但赋值不返回任何值123if x = y &#123; // 此句错误，因为x = y表达式不返回值&#125; 数值运算 加法（+） 减法（-） 乘法（*） 除法（/）Swift默认不允许数值运算中出现溢出情况，但是可以使用溢出运算符来达到有目的的溢出(如a &amp;+ b)加法可以用于String的拼接1\"heloo\" + \" world\" 两个Character值或一个String和一个Character值，相加会生成一个新的String值 求余运算129 % 4 // 等于1-9 % 4 // 等于-1 4*(-2)+(-1) = 9 浮点数求余计算18 % 2.5 // 等于0.5 自增和自增运算和 C 语言一样，Swift 也提供了方便对变量本身加1或减1的自增（++）和自减（–）的运算符。其操作对象可以是整形和浮点型。 当++前置的时候，先自増再返回。 当++后置的时候，先返回再自增。复合赋值（Compound Assignment Operators）Swift也提供把其他运算符和赋值运算符组合的复合赋值运算符12var a = 1a += 2 // a = 3 比较运算 等于(==) 不等于(!=) 大于(&gt;) 小于(&lt;) 大于等于(&gt;=) 小于等于(&lt;=)Swift还提供了恒等于===和恒不等于!==来比较两个对象是否饮用同一个对象的实例三元条件运算(Ternary Conditional Operator)问题 ? 答案1 : 答案2，如果问题成立，返回答案1的结果; 如果不成立，返回答案2的结果。1let value = (boolValue ? 10 : 30) 三元条件运算提供有效率且便捷的方式来表达二选一的选择。 区间运算符闭区间运算符a...b定义了一个包含从a到b所有值的区间，闭区间运算符在迭代一个区间的所有值时非常有用，比如for-in循环中：123for index in 1...5&#123; // &#125; 半闭区间a..b定义了一个从a到b但不包括b的区间。12345let names = [\"Anna\",\"Alex\",\"Brian\",\"Jack\"]let count = name.countfor i in 0..count &#123; //&#125; 逻辑运算 逻辑非(!) 逻辑与(&amp;&amp;) 逻辑或(||)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"Gradle","date":"2014-06-24T05:30:16.000Z","path":"2014/06/24/Gradle/","text":"Gradle 什么是Gradle？Gradle 是以 Groovy 语言为基础，面向Java应用为主，基于DSL语法的自动化构建工具。说到Java的自动化构建工具。使用Gradle构建Android项目的优点： 在IDE环境和命令行下使用同一个构建系统 改进的依赖关系管理 更容易地集成到自动构建系统 Gradle 基本概念如果你用Android Studio新建一个项目的时候，默认生成一大堆关于gradle的东西，其中最重要的是一个build.gradle的文件，内容如下：12345678910111213141516171819202122232425262728293031323334buildscript &#123; // 声明用本地maven库查找依赖 repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:0.8.+' &#125;&#125;// 声明项目是一个android构建apply plugin: 'android'// SDK版本 build工具版本android &#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\" // 版本细节 defaultConfig &#123; minSdkVersion 14 targetSdkVersion 19 versionCode 1 versionName \"1.0\" &#125; // 发行版定义 buildTypes &#123; release &#123; runProguard false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125;dependencies &#123; compile 'com.android.support:support-v4:19.0.+'&#125; buildscript节点的内容完全不用动，大概意思就是支持maven，声明Gradle的版本。apply plugin节点声明构建的项目类型，这里当然是android了android节点设置编译android项目的参数，接下来，我们的构建android项目的所有配置都在这里完成。 构建一个Gradle Android项目除了最基本的Android Gradle配置文件，项目常常需要引入第三方的jar包，比如依赖一个support_v4的jar包，则完整的build.gradle文件如下：12345678910111213141516171819202122232425262728293031323334buildscript &#123; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:0.8.+' &#125;&#125;apply plugin: 'android'android &#123; compileSdkVersion 19 buildToolsVersion \"19.0.0\" defaultConfig &#123; minSdkVersion 14 targetSdkVersion 19 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; runProguard false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;&#125;dependencies &#123; //单文件依赖 compile files('libs/android-support-v4.jar\") //某个文件夹下面全部依赖 compile fileTree(dir: 'libs', include: '*.jar')&#125; 接着在命令行切换到项目目录下1gradle clean 如果是第一次使用gradle构建，则会下载相关依赖包并且对环境进行初始化，如果出错了，一般可能是下载超时，试多几次即可，最后你会看到如下提示：BUILD SUCCESSFUL 完成以上的步骤，就可以正式使用gralde 构建你的android项目了。 接着执行1gradle build 就完成了android 项目的构建了。如果，你是照着以上步骤走的话，你将会在项目目录里面看到一个build 的目录，里面就是用gradle 构建android项目的全部东西了。最终打包的apk 就在build/apk 目录下了。然后，你会发现，两个apk 一个是 [项目名]-debug-unaligned [项目名]-release-unsigned，看名字就猜到一个是调试模式没有进行优化的apk（可直接安装），一个是release模式但没有签名的apk（不可直接安装）。 打包签名默认输出 release apk 是没有签名的，那么我们需要签名的很简单，只需要在android{}里面补充加上如下代码即可。1234567891011121314151617// 签名signingConfigs &#123; myConfig &#123; storeFile file(&quot;storm.keystore&quot;) storePassword &quot;storm&quot; keyAlias &quot;storm&quot; keyPassword &quot;storm&quot; &#125;&#125; buildTypes&#123; release &#123; signingConfig signingConfigs.myConfig runProguard true proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.txt&apos; &#125; &#125; 然后，运行12gradle clean gradle build 接着在build/apk目录下就生成了我们需要的签名的apk。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"SQLite","date":"2014-06-23T05:29:42.000Z","path":"2014/06/23/SQLite/","text":"创建SQLite数据库推荐继承SQLiteOpenHelper类，然后重写其中的onCreate()方法，在onCreate()方法中，执行数据库创建的SQL语句。而SQLiteOpenHelper不仅仅用于SQLite的创建，也可以对其进行维护，以及获得SQLiteDatabase这个数据库操作对象。SQLiteOpenHelper提供了两个构造器，用于传递当前上下文对象以及SQLite数据库版本信息，在SQLiteOpenHelper的继承类构造方法中，会调用它：123// context是上下文对象；name是数据库名称；factory是一个允许子类在查询时使用的游标，一般不用传null;version是数据库版本号；errorHandler是一个接口，当数据库错误的时候，执行的补救方法。SQLiteOpenHelper(Context context,String name,SQLiteDatabase.CursorFactory factory,int version).SQLiteOpenHelper(Context context,String name,SQLiteDatabase.CursorFactroy factory,int version,DatabaseErrorHandler errorHandler). 常用的方法： String getDatabaseName():获取数据库名。 SQLiteDatabase getReadableDatabase():创建或者打开一个可读的数据库对象。 SQLiteDatabase getWritableDatabase():创建或者打开一个可读/写的数据库对象。 abstract void onCreate(SQLiteDatabase db):当第一次调用SQLiteOpenHelper的时候执行，之后再次调用将不再执行，一般用于完成数据库初始化的工作。 void onUpgrade(SQLiteDatabase db,int oldVersion,int newVersion):当数据库版本号发生向上更新时，被执行。 void onDowngrade(SQLiteDatabase db,int oldVersion,int newVersion)当数据库版本号发生向下更新时，被执行。 执行CRUD 当使用SQLiteOpenHelper的getReadableDatabase()或者getWritableDatabase()方法获取到SQLiteDatabase对象，就可以对这个数据库进行操作了。 对于熟悉SQL语句的开发者而言，其实只需要使用两个方法，即可执行所有CRUD操作，以下方法提供多个重载方法： void execSQL()：通过SQL语句执行一条非查询语句。 Cursor rawQuery()：通过SQL语句执行一条查询语句。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Cocos2d-X 3.0 Hello World 分析","date":"2014-06-23T03:35:39.000Z","path":"2014/06/23/Cocos2d-X-30-Hello-World-分析/","text":"AppDelegate.h与AppDelegate.cpp文件这两个文件时Cocos2d-x游戏的入口文件，控制着游戏的生命周期,除去构造函数和析构函数外，共有 3 个方法。 1234567891011121314151617181920// 应用程序启动后将调用这个方法。默认的实现中已经包含了游戏启动后的必要准备bool applicationDidFinishLaunching()&#123; // 初始化游戏引擎控制器Director,以便启动游戏引擎 auto director = Director::getInstance(); auto glview = director-&gt;getOpenGLView(); if(!glview)&#123; glview = GLView::create(\"My Game\"); director-&gt;setOpenGLView(glview); &#125; // 启动FPS显示 director-&gt;setDisplayStats(true); // 设置绘制间隔 director-&gt;setAnimationInterval(1.0 / 6.0); auto scence = HelloWorld::createScene(); director-&gt;runWithScene(scence); return true;&#125; 这段代码首先对引擎进行必要的初始化，然后开启了 FPS 显示。FPS 即每秒帧速率，也就是屏幕每秒重绘的次数。启用了FPS 显示后，当前 FPS 会在游戏的左下角显示。通常在游戏开发阶段，我们会启用 FPS 显示，这样就可以方便地确定游戏运行是否流畅。 接下来是设置绘制间隔。绘制间隔指的是两次绘制的时间间隔，因此绘制间隔的倒数就是 FPS 上限。对于移动设备来说，我们通常都会将 FPS 限制在一个适当的范围内。过低的每秒重绘次数会使动画显示出卡顿的现象，而提高每秒重绘次数会导致设备运算量大幅增加，造成更高的能耗。人眼的刷新频率约为 60 次每秒，因此把 FPS 限定在 60 是一个较为合理的设置，Cocos2d-x 就把绘制间隔设置为 1/60 秒。至此，我们已经完成了引擎的初始化，接下来我们将启动引擎。 最后也是最关键的步骤，那就是创建 Hello World 场景，然后指派 Director 运行这个场景。对于游戏开发者而言，我们需要在此处来对我们的游戏进行其他必要的初始化，例如读取游戏设置、初始化随机数列表等。程序的最末端返回 true，表示程序已经正常初始化。 void applicationDidEnterBackground()。当应用程序将要进入后台时，会调用这个方法。具体来说，当用户把程序切换到后台，或手机接到电话或短信后程序被系统切换到后台时，会调用这个方法。此时，应该暂停游戏中正在播放的音乐或音效。动作激烈的游戏通常也应该在此时进行暂停操作，以便玩家暂时离开游戏时不会遭受重大损失。 void applicationWillEnterForeground()。该方法与 applicationDidEnterBackground()成对出现，在应用程序回到前台 时被调用。相对地，我们通常在这里继续播放刚才暂停的音乐，显示游戏暂停菜单等。","tags":[{"name":"Cocos2d-X","slug":"Cocos2d-X","permalink":"http://seniorzhai.github.io/tags/Cocos2d-X/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://seniorzhai.github.io/tags/Hello-World/"}]},{"title":"Swift内建函数","date":"2014-06-20T05:09:31.000Z","path":"2014/06/20/Swift内建函数/","text":"abs(singedNumber):返回给定的有符号数字的绝对值 12abs(-1) == 1abs(-42) == 42 contains(sequence,element):判断给定的序列（如数组）是否包含特定的元素 1234var languages = [\"Swift\",\"Objective-C\"]contains(languages,\"Swift\") == truecontains(languages,\"Java\") == falsecontains([29,85,42,96,75],42) == true drop abs(singedNumber):返回给定的有符号数字的绝对值 12abs(-1) == 1abs(-42) == 42 contains(sequence,element):判断给定的序列（如数组）是否包含特定的元素 1234var languages = [\"Swift\",\"Objective-C\"]contains(languages,\"Swift\") == truecontains(languages,\"Java\") == falsecontains([29,85,42,96,75],42) == true drop","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"Android permission访问权限大全","date":"2014-06-19T05:29:07.000Z","path":"2014/06/19/Android-permission访问权限大全/","text":"程序执行需要读取到安全敏感项必需在androidmanifest.xml中声明相关权限请求, 完整列表如下: android.permission.ACCESS_CHECKIN_PROPERTIES 允许读写访问”properties”表在 checkin数据库中，改值可以修改上传( Allows read/write access to the “properties” table in the checkin database, to change values that get uploaded) android.permission.ACCESS_COARSE_LOCATION 允许一个程序访问CellID或WiFi热点来获取粗略的位置(Allows an application to access coarse (e.g., Cell-ID, WiFi) location) android.permission.ACCESS_FINE_LOCATION 允许一个程序访问精良位置(如GPS) (Allows an application to access fine (e.g., GPS) location) android.permission.ACCESS_LOCATION_EXTRA_COMMANDS 允许应用程序访问额外的位置提供命令(Allows an application to access extra location provider commands) android.permission.ACCESS_MOCK_LOCATION 允许程序创建模拟位置提供用于测试(Allows an application to create mock location providers for testing) android.permission.ACCESS_NETWORK_STATE 允许程序访问有关GSM网络信息(Allows applications to access information about networks) android.permission.ACCESS_SURFACE_FLINGER 允许程序使用SurfaceFlinger底层特性 (Allows an application to use SurfaceFlinger’s low level features) android.permission.ACCESS_WIFI_STATE 允许程序访问Wi-Fi网络状态信息(Allows applications to access information about Wi-Fi networks) android.permission.ADD_SYSTEM_SERVICE 允许程序发布系统级服务(Allows an application to publish system-level services). android.permission.BATTERY_STATS 允许程序更新手机电池统计信息(Allows an application to update the collected battery statistics) android.permission.BLUETOOTH 允许程序连接到已配对的蓝牙设备(Allows applications to connect to paired bluetooth devices) android.permission.BLUETOOTH_ADMIN 允许程序发现和配对蓝牙设备(Allows applications to discover and pair bluetooth devices) android.permission.BRICK 请求能够禁用设备(非常危险)(Required to be able to disable the device (very *erous!).) android.permission.BROADCAST_PACKAGE_REMOVED 允许程序广播一个提示消息在一个应用程序包已经移除后(Allows an application to broadcast a notification that an application package has been removed) android.permission.BROADCAST_STICKY 允许一个程序广播常用intents(Allows an application to broadcast sticky intents) android.permission.CALL_PHONE 允许一个程序初始化一个电话拨号不需通过拨号用户界面需要用户确认 (Allows an application to initiate a phone call without going through the Dialer user interface for the user to confirm the call being placed.) android.permission.CALL_PRIVILEGED 允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认 (Allows an application to call any phone number, including emergency numbers, without going through the Dialer user interface for the user to confirm the call being placed) android.permission.CAMERA 请求访问使用照相设备(Required to be able to access the camera device. ) android.permission.CHANGE_COMPONENT_ENABLED_STATE 允许一个程序是否改变一个组件或其他的启用或禁用(Allows an application to change whether an application component (other than its own) is enabled or not. ) android.permission.CHANGE_CONFIGURATION 允许一个程序修改当前设置，如本地化(Allows an application to modify the current configuration, such as locale. ) android.permission.CHANGE_NETWORK_STATE 允许程序改变网络连接状态(Allows applications to change network connectivity state) android.permission.CHANGE_WIFI_STATE 允许程序改变Wi-Fi连接状态(Allows applications to change Wi-Fi connectivity state) android.permission.CLEAR_APP_CACHE 允许一个程序清楚缓存从所有安装的程序在设备中(Allows an application to clear the caches of all installed applications on the device. ) android.permission.CLEAR_APP_USER_DATA 允许一个程序清除用户设置(Allows an application to clear user data) android.permission.CONTROL_LOCATION_UPDATES 允许启用禁止位置更新提示从无线模块 (Allows enabling/disabling location update notifications from the radio. ) android.permission.DELETE_CACHE_FILES 允许程序删除缓存文件(Allows an application to delete cache files) android.permission.DELETE_PACKAGES 允许一个程序删除包(Allows an application to delete packages) android.permission.DEVICE_POWER 允许访问底层电源管理(Allows low-level access to power management) android.permission.DIAGNOSTIC 允许程序RW诊断资源(Allows applications to RW to diagnostic resources. ) android.permission.DISABLE_KEYGUARD 允许程序禁用键盘锁(Allows applications to disable the keyguard ) android.permission.DUMP 允许程序返回状态抓取信息从系统服务(Allows an application to retrieve state dump information from system services.) android.permission.EXPAND_STATUS_BAR 允许一个程序扩展收缩在状态栏,android开发网提示应该是一个类似Windows Mobile中的托盘程序(Allows an application to expand or collapse the status bar. ) android.permission.FACTORY_TEST 作为一个工厂测试程序，运行在root用户(Run as a manufacturer test application, running as the root user. ) android.permission.FLASHLIGHT 访问闪光灯,android开发网提示HTC Dream不包含闪光灯(Allows access to the flashlight ) android.permission.FORCE_BACK 允许程序强行一个后退操作是否在顶层activities(Allows an application to force a BACK operation on whatever is the top activity. ) android.permission.FOTA_UPDATE 暂时不了解这是做什么使用的，android开发网分析可能是一个预留权限. android.permission.GET_ACCOUNTS 访问一个帐户列表在Accounts Service中(Allows access to the list of accounts in the Accounts Service) android.permission.GET_PACKAGE_SIZE 允许一个程序获取任何package占用空间容量(Allows an application to find out the space used by any package. ) android.permission.GET_TASKS 允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等(Allows an application to get information about the currently or recently running tasks: a thumbnail representation of the tasks, what activities are running in it, etc.) android.permission.HARDWARE_TEST 允许访问硬件(Allows access to hardware peripherals. ) android.permission.INJECT_EVENTS 允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流，android 开发网提醒算是hook技术吧(Allows an application to inject user events (keys, touch, trackball) into the event stream and deliver them to ANY window.) android.permission.INSTALL_PACKAGES 允许一个程序安装packages(Allows an application to install packages. ) android.permission.INTERNAL_SYSTEM_WINDOW 允许打开窗口使用系统用户界面(Allows an application to open windows that are for use by parts of the system user interface. ) android.permission.INTERNET 允许程序打开网络套接字(Allows applications to open network sockets) android.permission.MANAGE_APP_TOKENS 允许程序管理(创建、催后、 z- order默认向z轴推移)程序引用在窗口管理器中(Allows an application to manage (create, destroy, Z-order) application tokens in the window manager. ) android.permission.MASTER_CLEAR 目前还没有明确的解释，android开发网分析可能是清除一切数据，类似硬格机 android.permission.MODIFY_AUDIO_SETTINGS 允许程序修改全局音频设置(Allows an application to modify global audio settings) android.permission.MODIFY_PHONE_STATE 允许修改话机状态，如电源，人机接口等(Allows modification of the telephony state ? power on, mmi, etc. ) android.permission.MOUNT_UNMOUNT_FILESYSTEMS 允许挂载和反挂载文件系统可移动存储 (Allows mounting and unmounting file systems for removable storage. ) android.permission.PERSISTENT_ACTIVITY 允许一个程序设置他的activities显示 (Allow an application to make its activities persistent. ) android.permission.PROCESS_OUTGOING_CALLS 允许程序监视、修改有关播出电话(Allows an application to monitor, modify, or abort outgoing calls) android.permission.READ_CALENDAR 允许程序读取用户日历数据(Allows an application to read the user’s calendar data.) android.permission.READ_CONTACTS 允许程序读取用户联系人数据(Allows an application to read the user’s contacts data.) android.permission.READ_FRAME_BUFFER 允许程序屏幕波或和更多常规的访问帧缓冲数据(Allows an application to take screen shots and more generally get access to the frame buffer data) android.permission.READ_INPUT_STATE 允许程序返回当前按键状态(Allows an application to retrieve the current state of keys and switches. ) android.permission.READ_LOGS 允许程序读取底层系统日志文件(Allows an application to read the low-level system log files. ) android.permission.READ_OWNER_DATA 允许程序读取所有者数据(Allows an application to read the owner’s data) android.permission.READ_SMS 允许程序读取短信息(Allows an application to read SMS messages.) android.permission.READ_SYNC_SETTINGS 允许程序读取同步设置(Allows applications to read the sync settings) android.permission.READ_SYNC_STATS 允许程序读取同步状态(Allows applications to read the sync stats) android.permission.REBOOT 请求能够重新启动设备(Required to be able to reboot the device. ) android.permission.RECEIVE_BOOT_COMPLETED 允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动(Allows an application to receive the ACTION_BOOT_COMPLETED that is broadcast after the system finishes booting. ) android.permission.RECEIVE_MMS 允许一个程序监控将收到MMS彩信,记录或处理(Allows an application to monitor incoming MMS messages, to record or perform processing on them. ) android.permission.RECEIVE_SMS 允许程序监控一个将收到短信息，记录或处理(Allows an application to monitor incoming SMS messages, to record or perform processing on them.) android.permission.RECEIVE_WAP_PUSH 允许程序监控将收到WAP PUSH信息(Allows an application to monitor incoming WAP push messages. ) android.permission.RECORD_AUDIO 允许程序录制音频(Allows an application to record audio) android.permission.REORDER_TASKS 允许程序改变Z轴排列任务(Allows an application to change the Z-order of tasks) android.permission.RESTART_PACKAGES 允许程序重新启动其他程序(Allows an application to restart other applications) android.permission.SEND_SMS 允许程序发送SMS短信(Allows an application to send SMS messages) android.permission.SET_ACTIVITY_WATCHER 允许程序监控或控制activities已经启动全局系统中Allows an application to watch and control how activities are started globally in the system. android.permission.SET_ALWAYS_FINISH 允许程序控制是否活动间接完成在处于后台时Allows an application to control whether activities are immediately finished when put in the background. android.permission.SET_ANIMATION_SCALE 修改全局信息比例(Modify the global animation scaling factor.) android.permission.SET_DEBUG_APP 配置一个程序用于调试(Configure an application for debugging.) android.permission.SET_ORIENTATION 允许底层访问设置屏幕方向和实际旋转(Allows low-level access to setting the orientation(actually rotation) of the screen.) android.permission.SET_PREFERRED_APPLICATIONS 允许一个程序修改列表参数 PackageManager.addPackageToPreferred() 和PackageManager.removePackageFromPreferred()方法(Allows an application to modify the list of preferred applications with the PackageManager.addPackageToPreferred() and PackageManager.removePackageFromPreferred() methods.) android.permission.SET_PROCESS_FOREGROUND 允许程序当前运行程序强行到前台(Allows an application to force any currently running process to be in the foreground.) android.permission.SET_PROCESS_LIMIT 允许设置最大的运行进程数量(Allows an application to set the maximum number of (not needed) application processes that can be running. ) android.permission.SET_TIME_ZONE 允许程序设置时间区域(Allows applications to set the system time zone) android.permission.SET_WALLPAPER 允许程序设置壁纸(Allows applications to set the wallpaper ) android.permission.SET_WALLPAPER_HINTS 允许程序设置壁纸hits(Allows applications to set the wallpaper hints) android.permission.SIGNAL_PERSISTENT_PROCESSES 允许程序请求发送信号到所有显示的进程中 (Allow an application to request that a signal be sent to all persistent processes) android.permission.STATUS_BAR 允许程序打开、关闭或禁用状态栏及图标Allows an application to open, close, or disable the status bar and its icons. android.permission.SUBSCRIBED_FEEDS_READ 允许一个程序访问订阅RSS Feed内容提供(Allows an application to allow access the subscribed feeds ContentProvider. ) android.permission.SUBSCRIBED_FEEDS_WRITE 系统暂时保留改设置,android开发网认为未来版本会加入该功能。 android.permission.SYSTEM_ALERT_WINDOW 允许一个程序打开窗口使用 TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层(Allows an application to open windows using the type TYPE_SYSTEM_ALERT, shown on top of all other applications. ) android.permission.VIBRATE 允许访问振动设备(Allows access to the vibrator) android.permission.WAKE_LOCK 允许使用PowerManager的 WakeLocks保持进程在休眠时从屏幕消失( Allows using PowerManager WakeLocks to keep processor from sleeping or screen from dimming) android.permission.WRITE_APN_SETTINGS 允许程序写入API设置(Allows applications to write the apn settings) android.permission.WRITE_CALENDAR 允许一个程序写入但不读取用户日历数据(Allows an application to write (but not read) the user’s calendar data. ) android.permission.WRITE_CONTACTS 允许程序写入但不读取用户联系人数据(Allows an application to write (but not read) the user’s contacts data. ) android.permission.WRITE_GSERVICES 允许程序修改Google服务地图(Allows an application to modify the Google service map. ) android.permission.WRITE_OWNER_DATA 允许一个程序写入但不读取所有者数据(Allows an application to write (but not read) the owner’s data.) android.permission.WRITE_SETTINGS 允许程序读取或写入系统设置(Allows an application to read or write the system settings. ) android.permission.WRITE_SMS 允许程序写短信(Allows an application to write SMS messages) android.permission.WRITE_SYNC_SETTINGS 允许程序写入同步设置(Allows applications to write the sync settings)","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Service","date":"2014-06-19T05:28:28.000Z","path":"2014/06/19/Service/","text":"- void onCreate():当Service第一次被创建后将立即回调该方法。 - void onStartCommand(Intent intent,int flag,int startId):每次通过startService()方法启动Service时都会被回调 - void onDestroy():当Service被关闭前会被回调 - abstract IBinder onBind(Intent intent):该方法是Service子类必须实现的方法，如果不需要通过绑定的方式启动服务，可以返回Null - boolean onUnbind(Intent intent):当Service上绑定的所有客户端都被断开连接将被回调该方法 通过Service的启动方式与适用范围，可将Service分为两类服务： - start:启动服务，当一个Android组件（如一个Activity）调用startService()的时候，启动一个Service。Service一旦启动，就可以一直在后台运行下去，即使这个启动它的组件被摧毁。这样的服务模式，通常用于执行一个操作而不需要返回结果给调用者。 - Bound：绑定服务，当一个Android组件（如一个Activity）调用binService()，一个绑定Service提供了一个客户端到服务端的接口，允许组件与服务之间进行交互，这样可以实现跨进程的通信。绑定服务的生命周期默认是跟随他的绑定组件的，但是一个绑定Service可以绑定多个Android组件，如果这些Android组件都被销毁，那么这个绑定服务也将被销毁。 一个Service可以包含上面两种运行方式，与它重载的方法有关，如果重写了onStartCommand()即支持启动Service，如果重写onBind()即支持绑定服务，如果重载实现了两个方法即可实现两种服务。 对于两种方式的Service，其生命周期被回调的方法也是不一样的： 清单文件的配置Service是Android的四大组件之一，所以它必须在AndroidManifest清单文件中进行配置，否则系统将找不到这个服务。Service的配置也是在&lt;application /&gt;这个节点下，使用&lt;service /&gt;进行配置，其中android:name属性为Service类。 如果开发的Service需要被外部操作，还需要配置&lt;intent-filter /&gt;节点。 如果Service强制仅本应用操作，可以配置&lt;service /&gt;节点的android:exported属性为false，这样即使配置了&lt;intent-filter /&gt;，外部应用也无法操作这个服务，android:exported属性默认是true。 Service开发步骤 开发一个Service类，需要继承Service或者IntentService 在AndroidManifest清单文件中注册这个Service组件 在一个Android组件中启动这个Service Service使用完成之后，需要停止这个服务 启动Service启动服务必须实现Service.onStartCommond()方法，启动服务使用startService(Intent intent)方法开启一个服务，仅需要传递一个Intent对象即可，在Intent对象中指定需要启动的服务，而使用startService()方法启动的服务，在服务的外部，必须使用stopService()方法停止当前的Service，该Service就会被销毁。 对于启动服务，一旦启动将与访问它的组件无任何关联，即使访问它的组件被销毁了，这个服务也一直运行下去，直到被销毁！ 1234567891011121314151617181920212223242526272829public class StartService extends Service&#123; private final static String TAG = \"StartService\"; @Override public IBinder onBind(Intent arg0) &#123; // 仅通过startService()启动服务，所以这个方法返回null即可。 return null; &#125; @Override public void onCreate()&#123; super.onCreate(); Log.i(TAG,\"Service is Create\"); &#125; @Override public void onCreate() &#123; super.onCreate(); Log.i(TAG, \"Service is Created\"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, \"Service is started\"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; Log.i(TAG, \"Service is Destroyed\"); super.onDestroy(); &#125;&#125; 1234567891011121314151617181920212223242526public class MainActivity extends Activity&#123; private Button startSer,stopSer; private Intent intent = null; @Override protected void onCreate(Bundle saveInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startSer = (Button) findViewById(R.id.startSer); stopSer = (Button) findViewById(R.id.stopSer); intent = new Intent(MainActivity,StartService.class); startSer.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startService(intent); &#125; &#125; stopSer.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; stopService(intent); &#125; &#125; &#125;&#125; 绑定服务如果Service和宿主之间需要进行方法调用或者数据交换，则应该使用Context对象的binService()和unbindSevice()方法来绑定和解除绑定服务。 Context的binService()方法的完整方法签名为:binService(Intent service,ServiceConnection conn,int flags) - service:通过Intent指定要绑定的Service - conn:一个ServiceConnection对象，该对象用于监听访问者与Service对象的onServiceConnected()方法 - flags:指定绑定时是否自动创建Service，0为不自动创建，BIND_AUTO_CREATE为自动创建 从上面的bindService方法可以看出，绑定一个服务与宿主交互，依托一个ServiceConnection接口，这个接口对象必须声明在主线程中，通过实现其中的两个方法，来实现与Service的交互。 - void onServiceConnection(ComponentName name,IBinder service)：绑定服务的时候被回调，在这个方法获取绑定Service传递过来的IBinder对象，通过这个IBinder对象，实现宿主和Service的交互。 - void onServiceDisconnected(ComponetName name):当取消绑定时回调，但正常情况下不被调用，它的调用时机是当Service服务被意外销毁时，才被自动调用。 在绑定Service时，必须提供一个IBinder onBind(Intent intent)方法，在绑定本地Service的情况下，onBind()方法h返回的IBinder对象会传给宿主ServiceConnection.onServiceConnected()方法发service参数，这样宿主就可用通过IBinder对象与Service进行通信。实际开发中一般会继承Binder类(IBinder的实现类)的方式来实现自己的IBinder对象。 如果绑定服务提供的onBind返回为Null，则也可以使用bindService()启动服务，但不会绑定上Service，因此宿主的ServiceConnection.onServiceConnected()方法不会被执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// MainActivity.javapublic class MainActivity extends Activity &#123; private final String TAG = \"MainActivity\"; private Button bn1,bn2,bn3; private MyService.MyBinder binder; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, \"--Service Disconnected--\"); &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Toast.makeText(MainActivity.this, \"绑定成功\", Toast.LENGTH_SHORT).show(); binder = (MyService.MyBinder) service; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); final Intent intent = new Intent(MainActivity.this,MyService.class); bn1 = (Button) findViewById(R.id.button1); bn1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; bindService(intent, conn, Service.BIND_AUTO_CREATE); &#125; &#125;); bn2 = (Button) findViewById(R.id.button2); bn2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; binder = null; unbindService(conn); &#125; &#125;); bn3 = (Button) findViewById(R.id.button3); bn3.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; if(binder!=null)&#123; Toast.makeText(MainActivity.this, \"Count\"+binder.getCount(), Toast.LENGTH_SHORT).show(); &#125;else &#123; Toast.makeText(MainActivity.this, \"未绑定\", Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; 12345678910111213141516171819202122232425262728293031&lt;!-- activity_main.xml --&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.example.service.MainActivity\" &gt; &lt;Button android:id=\"@+id/button1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"bind\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"unbind\" /&gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"getCount\" /&gt; &lt;/LinearLayout&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//MyService.javapublic class MyService extends Service &#123; private final static String TAG = \"MyService\"; private int count; private boolean quit = true; private Thread thread; private MyBinder binder = new MyBinder(); public class MyBinder extends Binder &#123; public int getCount() &#123; return count; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (quit) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; &#125; count++; &#125; &#125; &#125;); thread.start(); &#125; @Override public IBinder onBind(Intent intent) &#123; return binder; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Python 六 - 面向对象编程","date":"2014-06-18T06:12:31.000Z","path":"2014/06/18/Python-六---面向对象编程/","text":"面向对象编程————Object Oriented Programming，简称OOP，是一种程序设计思想。OOP吧对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行，为了简化程序设计，面向过程吧函数继续切分成为子函数，即把大块的函数通过切割成小块函数降低系统的复杂度。 而面向对象的程序设计吧计算机程序视为一组对象的集合，而每个对象都可以接受其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 在Python中，所有数据类型都可以视为对象，当然也可以自定义对象，自定义的对象数据类型就是面向对象中的类(Class)的概念。 类和实例面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，而实例是根据类创建出来的一个个具体的‘对象’，每个对象都拥有相同的方法，但各自的数据可能不同。以Student类为例，在Python中，定义类是通过class关键字12class Student(object): pass clas后米娜紧接着是类名，即’Student’，类名通过是大写开头的单词，紧接着是(object)，表示类是从哪个类继承下来的，object是所有类都会继承的类。定义了好了Student类，就可以根据Student类创建出Student的实例，创建实例是通过类名+()实现的：12345678910111213&gt;&gt;&gt; jack = Student()&gt;&gt;&gt; jack&lt;__main__.Student object at 0x10f5e3110&gt;&gt;&gt;&gt; Student&lt;class '__main__.Student'&gt;&gt;&gt;&gt; 通过一个特殊的`__init__`方法，在创建实例的时候，就可以对某些属性初始化```Pythonclass Student(object): def __init__(self, name, score): self.name = name self.score = score 注意innit方法的第一个参数永远是self，表示创建的实例本身，因此在__init__方法内部，就可以把各个属性绑定到self，因为self就指向创建的实例本身。 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量穿进去：123456&gt;&gt;&gt; class Student(object):... ... def __init__(self,name):... self.name = name... &gt;&gt;&gt; jack = Student('jack') 数据封装面向对象编程的一个重要特点就是数据封装。类本身就拥有数据，要访问数据，就没有必要从外面的函数去访问，就直接用类内部定义访问数据的函数，这样就把“数据”给封装起来了，这些封装数据的函数是和类本身关联起来的，外面称之为类的方法，要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，出了self不用传递，其他参数正常传入。123456789&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... def getName(self):... return self.name... &gt;&gt;&gt; jack = Student('jack')&gt;&gt;&gt; jack.getName()'jack' 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样就可以隐藏内部的复杂逻辑。为了内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例变量名如果以__开头，就变成了一个私有变量(private)，只有内部可以访问，外部不能访问。需要注意的是，在Python中变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以不能用name这样的变量名。双下划线开头的实例变量外部不能直接访问是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量。123456789101112131415# /usr/bin/env python# -*- coding:utf-8 -*-class Student(object): def __init__(self,name): self.__name = name def print_name(self): print '%s' % (self.__name)jack = Student('jack')jack.print_name()print jack._Student__name# 执行结果# jack# jack 但不同版本的Python解释器可能会把__name改成不同的变量名。 继承和多态在OOP程序设计中，定义一个class的时候，可以从某个现有的class继承，新的class称为子类(Subclass)，而被继承的class称为基类、父类或者超类(Base class、Super class)12345678910111213141516171819class Animal(object): def run(self): print 'Animal is running...'class Dog(Animal): def run(self): print 'Dog is running...'class Cat(Animal): passdog = Dog()dog.run()cat = Cat()cat.run()# 运行结果# Dog is running...# Animal is running... 判断一个变量是否是某个类型可以用isinstance()判断：12345678910111213&gt;&gt;&gt; a = list() # a是list类型&gt;&gt;&gt; b = Animal() # b是Animal类型&gt;&gt;&gt; c = Dog() # c是Dog类型&gt;&gt;&gt; isinstance(a,list)True&gt;&gt;&gt; isinstance(b,list)False&gt;&gt;&gt; isinstance(b,Animal)True&gt;&gt;&gt; isinstance(c,Animal)True&gt;&gt;&gt; isinstance(c,Dog)True 获取对象信息使用type()判断对象类型，使用type()函数12345678&gt;&gt;&gt; type(123)&lt;type 'int'&gt;&gt;&gt;&gt; type('str')&lt;type 'str'&gt;&gt;&gt;&gt; type(None)&lt;type 'NoneType'&gt;&gt;&gt;&gt; type(abs)&lt;type 'builtin_function_or_method'&gt; Python把每种type类型都定义好了常量，放在types模块里，使用之前，需要先导入：123456789&gt;&gt;&gt; import types&gt;&gt;&gt; type('abc')==types.StringTypeTrue&gt;&gt;&gt; type(u'abc')==types.UnicodeTypeTrue&gt;&gt;&gt; type([])==types.ListTypeTrue&gt;&gt;&gt; type(str)==types.TypeTypeTrue 使用isinstance()对于class的继承关系，可以用isinstance()函数判断123456789101112131415161718192021222324252627&gt;&gt;&gt; class Animal(object):... pass... &gt;&gt;&gt; class Dog(Animal):... pass... &gt;&gt;&gt; class Husky(Dog):... pass... &gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h,Husky)True&gt;&gt;&gt; isinstance(h,Dog)True&gt;&gt;&gt; isinstance(h,Animal)True&gt;&gt;&gt; isinstance(d,Husky)False&gt;&gt;&gt; isinstance(d,Dog)True&gt;&gt;&gt; isinstance(d,Animal)True&gt;&gt;&gt; isinstance(d,(Animal,Husky))# d是否为Animal,Husky中的一种True 使用dir()获取一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的list12&gt;&gt;&gt; dir('ABC')['__add__', '__class__', '__contains__', '__delattr__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__getslice__', '__gt__', '__hash__', '__init__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_formatter_field_name_split', '_formatter_parser', 'capitalize', 'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 类似__xxx__的属性和方法在Python中都有特殊的用途，比如上例的__len__方法返回长度。调用len()函数获取对象长度时，实际回去调用对象的__len__方法。利用getattr()、setattr()、hasattr()函数还可以直接操作一个对象的状态：12345678910&gt;&gt;&gt; obj = MyObject()&gt;&gt;&gt; hasattr(obj,'x')# 是否有属性'x'？True&gt;&gt;&gt; hasattr(obj,'y')# 是否有属性'y'？False&gt;&gt;&gt; setattr(obj,'y',19)# 设置一个属性'y'&gt;&gt;&gt; hasattr(obj,'y')# 是否有属性'y'？True&gt;&gt;&gt; getattr(obj,'y')# 或属性属性'y'19 可以传入一个default参数，如果属性不存在，就返回默认值：12&gt;&gt;&gt; getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404404 动态绑定属性和方法正常情况下，当我们定义了一个class，差创建一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性：123456789101112131415&gt;&gt;&gt; class Student(object):... pass... &gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = 'Zoe'&gt;&gt;&gt; print s.nameZoe&gt;&gt;&gt; def set_age(self,age): # 定义一个函数作为实例的方法... self.age = age... &gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age,s,Student) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(22)&gt;&gt;&gt; s.age22 但是其他的实例该方法是不起作用的12345&gt;&gt;&gt; s1 = Student()&gt;&gt;&gt; s2.set_age(21)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 's2' is not defined 可以给class绑定方法： Student.set_age = MethodType(set_age,None,Student)s1.set_age(21)s1.age21s.age22123456789101112## 使用__slots__如果想要限制class的属性怎么办？比如只允许Student实例添加`name`和`age`属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class能添加的属性：```Python&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = &apos;Zoe&apos;&gt;&gt;&gt; s.age = 22&gt;&gt;&gt; s.score = 99Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &apos;Student&apos; object has no attribute &apos;score&apos; 注意，__slots__定义的属性仅对当前类起作用，对继承的子类是不起作用的 @property在绑定属性时，我们直接把属性暴露出来，这样还不安全为了限制属性的使用范围，可以使用@property装饰器把一个方法变成属性调用：1234567891011&gt;&gt;&gt; class Student(object):... @property... def score(self):... return self._score... @score.setter... def score(self,value):... if not isinstance(value,int):... raise ValueError('score must be an integer!')... if value &lt; 0 or value &gt; 100:... raise ValueError('score must between 0 ~ 100')... self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：1234567891011121314&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 69&gt;&gt;&gt; s.score 69&gt;&gt;&gt; s.score = 101Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 10, in scoreValueError: score must between 0 ~ 100&gt;&gt;&gt; s.score = &apos;99&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 8, in scoreValueError: score must be an integer! 还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2014 - self._birth 上面的birth是可读写属性，而age就是一个只读属性，因为age可以根据birth和当前时间计算出来。 多重继承Python支持同时继承多个父类1class SubClass(SpuClass1,SpuClass2,...) Mixin在设计类的继承关系时，通常主线是单一继承下来的。为了混入额外的功能，可以通过多继承实现，这种设计称为Mixing。为了更好地看出继承关系，可以在添加功能的类后面在Mixin，比如class Dog(Mammal,RunnableMixin,CarnivorousMixin)Python子弟啊的很多库使用了Mixi,举个例子，Python自带的TCPServer和UDPServer这两个网络服务，而要同时多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixin和ThreadingMixin提供。 定制类之前，我们知道了一些形如__xxx__的变量或方法的特殊作用，如：__slots__，__len__() Str类的说明123456789101112131415161718192021222324252627ValueError: score must be an integer!&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... &gt;&gt;&gt; print Student('Jack')&lt;__main__.Student object at 0x10e50d910&gt;&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... def __str__(self):... return 'Student object (name:%s)' % self.name... &gt;&gt;&gt; print Student('Jack')Student object (name:Jack)&gt;&gt;&gt; s&lt;__main__.Student object at 0x10e50d790&gt; # 直接输出还是“不好看”&gt;&gt;&gt; class Student(object):... def __str__(self):... return 'Student object (name:%s)' % self.name... def __init__(self,name):... self.name = name... __repr__ = __str__... &gt;&gt;&gt; s = Student(\"Jakc\")&gt;&gt;&gt; sStudent object (name:Jakc) iter_如果一个类要呗用于for...in循环，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，值得遇到StopIteration错误时退出循环。123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; class Fib(object):... def __init__(self):... self.a,self.b = 0,1... def __iter__(self):... return self... def next(self):... self.a,self.b = self.b,self.a + self.b... if self.a &gt; 100000:... raise StopIteration()... return self.a... &gt;&gt;&gt; for n in Fib():... print n... 112358132134558914423337761098715972584418167651094617711286574636875025 getitem要想像list那样按照下标取元素，需要实现getitem()方法123456789101112131415161718&gt;&gt;&gt; class Fib(object):... def __getitem__(self,n):... a,b = 1,1... for x in range(n):... a,b = b,a+b... return a... &gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[1]1&gt;&gt;&gt; f[10]89&gt;&gt;&gt; f[20]10946&gt;&gt;&gt; f[30]1346269 但是list有个神奇的切片方法：12&gt;&gt;&gt; range(100)[5:10][5, 6, 7, 8, 9] 对于Fib却报错。原因是getitem()传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：1234567891011121314151617class Fib(object): def __getitem__(self, n): if isinstance(n, int): a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice): start = n.start stop = n.stop a, b = 1, 1 L = [] for x in range(stop + 1): if x &gt;= start: L.append(a) a, b = b, a + b return L getattr通过__getattr__()方法我们可以返回一个不存在的属性12345678&gt;&gt;&gt; class SubClass(object):... def __getattr__(self,name):... if name=='age':... return lambda:22... &gt;&gt;&gt; s = SubClass()&gt;&gt;&gt; s.age()22 call设置一个函数，通过实例本身调用123456789&gt;&gt;&gt; class Student(object):... def __init__(self,name):... self.name = name... def __call__(self):... print('My name is %s' % self.name)... &gt;&gt;&gt; s = Student('zoe')&gt;&gt;&gt; s()My name is zoe 通过callable()函数，我们就可以判断一个对象是否是“可调用”对象。12345678910&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1,2,4])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable('str')False&gt;&gt;&gt; callable(Student('zoe'))True","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Activity启动模式","date":"2014-06-18T05:27:47.000Z","path":"2014/06/18/Activity启动模式/","text":"针对Activity而言，Android存在一个回退栈维护界面体验。当一个应用程序图标被点击时，应用的Task就会来到前台，并把应用的主Activity压入BackStack的栈顶，并获得焦点，这个Activity称之为根Activity，而BackStack中的Activity可以通过点击回退键弹出栈并销毁，使上一个Activity获得焦点，直到用户返回到Home页，而当BackStack中的Activity都被销毁之后，这个Task就不服存在，这个程序的进程还存在（不在此时销毁）。 Task的状态每个个Task都存在一个BackStack，而系统中可以存在多个Task，但是每次只有一个Task获得前台焦点，一般而言，系统允许用户在多个Task中切换，而被置于后台的Task的Activity将被置于Stopped状态。实际上，同一个Task中的Activity，只要不存在于栈顶并且获得前台焦点，那么它就是一个Stopped的状态。 Activity启动模式根据Activity的不同启动模式，它在BackStack中的状态时不一样的。Activity可以通过AndroidManifest.xml清单文件配置，在节点中的android:laucherMode属性设置。它有四个选项： standard singleTop singleTask singeInstancestandard标准启动模式，也是默认缺省值。standard模式下的Activity会依照启动顺序压入BackStack中，示意图如下：singleTop单顶模式，这种模式下，启动一个Activity的时候如果发现BackStack的栈顶已经存在这个Activity了，就不会去重建新的Activity，而是复用这个栈顶已经存在的Activity，避免同一个Activity被重复开启。示意图如下： singleTop应用的场景很多，一般适用于可以复用而又有多个开启渠道的Activity，避免当一个Activity已经开启并获得焦点后，再次重复开启。比如说Android系统浏览器的书签页面。singleTask开启一个Activity的时候，检查BackStack里面是否有这个Activity的实例存在，如果存在，清空BackStack里这个Activity上所有的其他Activity。singleInstance被标记为singleInstance启动模式的Activity，在启动的时候，会开启一个新的BackStack，这个BackStack里只有一个Activity的实例存在，并且使这个BackStack获得焦点。这是一种极端的模式，它会导致整个设备的操作系统里，只存在一个这个Activity实例，不论从何处启动的。singleInstance一般只存在一个适用场景，Android系统的来电页面，多次来电均使用的是一个Activity。 当然，在Android中，除了在AndroidManifest.xml清单文件中配置LauncherMode属性外，还可以在代码中设置启动模式。在组件中，启动一个Activity，需要用到startActivity()方法，其中传递一个Intent，可以使用Intent.setFlags(int flags)来设置新启动的Activity的启动模式，而通过代码设置Activity的启动模式的方式，优先级要高于在AndroidManifest.xml清单文件中的配置。 Intent.setFlag(int flags)方法传递的一个整形的数据，被Android系统设置为了常量： FLAG_ACTIVITY_NEW_TASK：这个标识会使新启动的Activity独立创建一个Task。 FLAG_ACTIVITY_CLEAR_TOP：这个标识会使新启动的Activity检查是否存在于Task中，如果存在则清除其之上的Activity，使它获得焦点，并不重新实例化一个Activity，一般结合FLAG_ACTIVITY_NEW_TASK一起使用。 FLAG_ACTIVITY_SINGLE_TOP：等同于在LauncherMode属性设置为singleTop。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android WebView与JS交互","date":"2014-06-17T05:27:06.000Z","path":"2014/06/17/Android-WebView与JS交互/","text":"开启WebView的JS支持 1webView.getSettings().setJavaScriptEnabled(true); 对WebView进行JavascriptInterface绑定，JS脚本通过这个借口来调用Java代码 12// this为借口对象，第二个参数为JS中改参数的别名webView.addJavascriptInterface(this,\"zoe\"); Java中调用JS 12// 调用JS的test函数并传参\"test\"webView.loadUrl(\"javascript:test('\"+test+\"')\"); js中调用Java函数 1&lt;div id='b'&gt;&lt;a onclick=\"window.zoe.onClick\"&gt;b.c&lt;/a&gt;&lt;/div&gt; 示例layout1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:orientation=\"vertical\" &gt; &lt;WebView android:id=\"@+id/webview\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:layout_weight=\"11\" /&gt; &lt;Button android:id=\"@+id/button1\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"调用js无参函数\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_weight=\"1\" android:text=\"调用js有参函数\" /&gt; &lt;/LinearLayout&gt; activity12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends Activity &#123; private WebView contentView = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); contentView = (WebView)findViewById(R.id.webview); contentView.getSettings().setJavaScriptEnabled(true); contentView.loadUrl(\"file:///android_asset/web.html\"); contentView.addJavascriptInterface(this, \"zoe\"); Button button1 = (Button)findViewById(R.id.button1); Button button2 = (Button)findViewById(R.id.button2); button1.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; contentView.loadUrl(\"javascript:fun1()\"); &#125; &#125;); button2.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; contentView.loadUrl(\"javascript:fun2('参数')\"); &#125; &#125;); &#125; public void startFunction() &#123; Toast.makeText(this, \"js调用了java函数\", Toast.LENGTH_SHORT).show(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;); &#125; public void startFunction(final String str) &#123; Toast.makeText(this, \"js调用了java函数，并传参：\"+str, Toast.LENGTH_SHORT).show(); runOnUiThread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;); &#125;&#125; web.html123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\"&gt;&lt;script type=\"text/javascript\"&gt;function fun1()&#123; document.getElementById(\"content\").innerHTML += \"&lt;br\\&gt;java调用了js函数fun1\";&#125;function fun2(arg)&#123; document.getElementById(\"content\").innerHTML += (\"&lt;br\\&gt;\"+\"java调用了js函数fun2，并传参：\"+arg);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;HTML标题 &lt;br/&gt;&lt;a onClick=\"window.zoe.startFunction()\"&gt;调用java函数&lt;/a&gt;&lt;br/&gt;&lt;a onClick=\"window.zoe.startFunction('hello java')\"&gt;调用java函数并传递参数&lt;/a&gt;&lt;br/&gt;&lt;div id=\"content\"&gt;这里是内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 例子","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"自定义图形Shape","date":"2014-06-17T05:26:23.000Z","path":"2014/06/17/自定义图形Shape/","text":"12345678910111213141516171819&lt;shape&gt; &lt;!-- 填充 --&gt; &lt;solid android:color=\"# ff9d77\"&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:startColor=\"# ff8c00\" android:endColor=\"# FFFFFF\" android:angle=\"270\" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=\"2dp\" android:color=\"# dcdcdc\" /&gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=\"2dp\" /&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\" /&gt; solid：填充gradient：渐变 startColor和endColor分别为起始和结束颜色 angle是渐变角度，必须是45的整倍数 type是渐变模式，可选linear，即线性渐变；也可以为radial径向渐变，径向渐变需要制定半径gradientRadius=”50”strokr:描边 width指宽度，color值颜色，dashWitdh指定虚线宽，dashGap指定相隔距离corners:原件 radius角的弧度，值越大角越圆","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Swift笔记(一)","date":"2014-06-17T05:08:43.000Z","path":"2014/06/17/Swift笔记(一)/","text":"Swift初识WWDC2014年6月3日苹果开发者大会发布，2010年7约开始开发 基于C语言和Objective-C语言，使用现有的Cocoa和Cocoa Touch框架，无缝兼容C、Objective-C语言 兼具编译语言的高性能(Performance)和脚背语言的交互性(Interactive) 支持Playground，它允许程序实时预览，无需频繁创建和运行App 简洁、安全、容易、灵活、高效值使用let来声明常量，使用var来声明变量。常量只能赋一次值。 值声明的类型必须和赋的值一致，声明时类型是可选的，声明的同时赋值，编译器会自动推断类型。也可以在声明时，指定类型。123var myVariable = 42let myConstant = 42let explicitDouble:Double = 70 值永远不会被隐式转换为其他类型，如果需要把一个值转换成其他类型，需要显示转换。123let label = \"The width is\"let width = 94let widthLabel = label + String(width) 有一种更简单的把值转换成字符串的方法：把值写到括号里，并且在括号之前加一个反斜杠。12let apples = 3let appleSummary = \"I have \\(apples) apples.\" 使用方括号[]来创建数组和字典，并使用下标或者键(key)来访问元素。12345678var shoppingList = [catfish\", \"water\", \"tulips\", \"blue paint\"]shoppingList[1] = \"bottle of water\"var occupations = [ \"Malcolm\": \"Captain\", \"Kaylee\": \"Mechanic\",]occupations[\"Jayne\"] = \"Public Relations\" 创建一个空数组或者字典，可以使用初始化语法12let emptyArray = String[]()let emptyDictionary = Dictionary&lt;String,Float&gt;() 如果类型信息可以被推断出来，你可以用[]和[:]来创建数组和空字典————就像声明变量或者给函数传参数的时候一样。1shoppingList = [] 控制流使用if和switch来进行条件操作，使用for-in、for、while和do-while来进行循环，包括条件和循环变量的括号可以省略，但是语句体的大括号是必须的。 在if语句中，条件必须是一个布尔表达式 switch支持任意类型的数据及各种比较操作12345678910let vegetable = \"red pepper\"switch vegetable &#123; let vegetableComment = \"Add some raisins and make ants on a log.\"case \"cucumber\", \"watercress\": let vegetableComment = \"That would make a good tea sandwich.\"case let x where x.hasSuffix(\"pepper\"): let vegetableComment = \"Is it a spicy \\(x)?\"default: let vegetableComment = \"Everything tastes good in soup.\"&#125; 运行switch中匹配到的子句之后，程序会退出switch语句，并不会继续向下运行，所以不需要在每个子句结尾写break。 for-in可以遍历字典1234567891011121314let interestingNumbers = [ \"Prime\": [2, 3, 5, 7, 11, 13], \"Fibonacci\": [1, 1, 2, 3, 5, 8], \"Square\": [1, 4, 9, 16, 25],]var largest = 0for (kind, numbers) in interestingNumbers &#123; for number in numbers &#123; if number &gt; largest &#123; largest = number &#125; &#125;&#125;largest 使用while来重复运行一段代码直到不满足条件。循环条件可以在开头也可以在结尾。1234567891011var n = 2while n &lt; 100 &#123; n = n * 2&#125;nvar m = 2do &#123; m = m * 2&#125; while m &lt; 100m 你可以在循环中使用..来表示范围，也可以使用传统的写法，两者是等价的：1234567891011var firstForLoop = 0for i in 0..3 &#123; firstForLoop += i&#125;firstForLoopvar secondForLoop = 0for var i = 0; i &lt; 3; ++i &#123; secondForLoop += 1&#125;secondForLoop 函数和闭包使用func来声明一个函数，使用名字和参数来调用函数，使用-&gt;来指定函数返回值1234func greet(name:String,day:String) -&gt; String&#123; return \"Hello \\(name),today is \\(day).\"&#125;greet(\"Bob\",\"Tuesday\") 使用一个元组来返回多个值1234func getGasPrices() -&gt; (Double,Double,Double)&#123; return (3.59,3.69,3.79)&#125;getGasPrices() 函数可以带有可变个数的参数，这些参数在函数内表现为数组的形式：12345678func sumOf(number:Int...) -&gt; Int &#123; var sum = 0 for number in numbers &#123; sum += number &#125; return sum&#125;sumOf(42,597,12) 函数可以嵌套，被嵌套的函数可以访问外侧函数的变量123456789func returnFifteen() -&gt; Int &#123; var y = 10 func add() &#123; y += 5 &#125; add() return y&#125;returnFifteen() 函数也可以作为另一个函数的返回值func makeIncrementer() -&gt; (Int-&gt; Int){ func addOne(number: Int) -&gt; Int { return 1 + number } return addOne}var increment = makeIncrementer()increment(7)123456789101112131415函数也可以当做参数传入另一个函数```swiftfunc hasAnyMatches(list:Int[],condition:Int -&gt; Bool) -&gt; Bool&#123; for item in list &#123; if condition(item)&#123; return true &#125; &#125; return false;&#125;func lessThanTen(number: Int) -&gt; Bool &#123; return number &lt; 10&#125;var numbers = [20,19,7,12]hasAnyMatches(numbers,lessThanTen) 函数实际上是一种特殊的闭包，可以使用{}来创建一个匿名闭包，使用in来将参数和返回值类型声明与闭包函数体进行分离12345numbers.map(&#123; (number:Int) -&gt; Int in let result = 3 * number return result&#125;) 如果一个闭包的类型已知，比如作为一个回调函数，可以忽略参数的类型和返回值，单个语句闭包会把它语句的值当作结果返回1number.map(&#123;number in 3 *number&#125;) 可以通过参数位置而不是参数名字来引用参数————这种方法在非常短的闭包中很有用，当一个闭包作为最后一个参数传给一个函数的时候，它可以直接跟在括号后面1234567891011sort([1,5,3,12,2])&#123;$0 &gt; $1&#125;## 对象和类使用`class`和类名来创建一个类，类中属性的声明和常量、变量声明一样，唯一区别的是上下文是类，同样方法和函数声明也一样```swiftclass Shape&#123; var numberOfSides = 0 func simpleDescriotion() -&gt; String&#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 创建一个类的实例，在类名后加上括号，使用点语法来访问实例的属性和方法123var shape = Shape()shape.numberOfSides = 7var shapeDescription = shape.simpleDescription() 使用init来创建一个构造器123456789101112class NamedShape&#123; vae numberOfSides:Int = 0 var name:String init(name:String) &#123; self.name = name &#125; func simpleDescription() -&gt; String &#123; return \"A shape with \\(numberOfSides) sides.\" &#125;&#125; 如果你需要在删除对象之前进行一些清理工作，使用deinit创建一个析构函数。 子类的定义方法是在类名后加上父类的名字，用冒号分割，创建类的时候并不需要一个标准的根类，可以忽略父类 子类如果重写父类的方法的话，需要用override标记————如果没有添加override就重写父类方法的话编译器会报错，编译器同样会检测override标记的方法是否确实在父类中。12345678910111213141516171819class Square:NamsedShape &#123; var sideLength:Double init(sideLength:Double,name:String)&#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 4 &#125; func area() -&gt; Double &#123; return sideLength * sideLength &#125; override func simpleDescription() -&gt; String &#123; return \"A square with sides of length \\(sideLength).\" &#125;&#125;let test = Square(sideLength: 5.2, name: \"my test square\")test.area()test.simpleDescription() 属性可以有 getter 和 setter 。1234567891011121314151617181920212223242526class EquilateralTriangle: NamedShape &#123; var sideLength: Double = 0.0 init(sideLength: Double, name: String) &#123; self.sideLength = sideLength super.init(name: name) numberOfSides = 3 &#125; var perimeter: Double &#123; get &#123; return 3.0 * sideLength &#125; set &#123; sideLength = newValue / 3.0 &#125; &#125; override func simpleDescription() -&gt; String &#123; return \"An equilateral triagle with sides of length \\(sideLength).\" &#125;&#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")triangle.perimetertriangle.perimeter = 9.9triangle.sideLength 在perimeter的setter中，新值的名字是newValue。也可以再set之后显示的设置一个名字 不需要计算属性，但是仍然需要在设置一个新值之前或者之后运行代码，使用willSet和didSet12345678910111213141516171819202122// 确保三角形的边长总是和正方形的边长相同class TriangleAndSquare &#123; var triangle : EquilateralTriangle &#123; willSet&#123; square.sideLength = newValue.sideLength &#125; &#125; var square:Square &#123; willSet &#123; triangle.sideLength = newValue.sideLength &#125; &#125; init(size:Double,name:String)&#123; square = Square(sideLength:size,name:name) triangle = EquilateralTriangle(sideLength:size,name:name) &#125;&#125;var triangeleAndSquare = TriangleAndSquare(size:10,name:\"another test shape\")triangleAndSquare.square.sideLengthtriangleAndSquare.triangle.sideLenthtriangleAndSquare.square = Square(sideLength:50,name:\"larger square\")triangleAndSquare.triangle.sideLength 类中的方法和一般的函数有一个重要的区别，函数的参数名只在函数内部使用，但是方法的参数名需要在调用的时候显示说明(除了第一个参数)。默认情况下，方法的参数名和它在方法内部的名字一样，不过也可以定义第二个名字，这个名字被用在方法内部12345678class Counter &#123; var count:Int = 0 func incrementBy(amout:Int,numberOfTimers times:Int)&#123; count += amount * times &#125;&#125;var counter = Counter()counter.incrementyBy(2,numberOfTimes:8) 出来变量的可选值时，可以再操作（比如方法、属性和子脚本）之前加?，如果?之前的值是nil,?后面的东西都会被忽略，并且整个表达式返回nil，否则，?之后的东西都会被运行，这两种情况下，整个表示式的值也是一个可选值12let optionalSquare:Square ?= Square(sideLength:2.5,name:\"optional square\")let sideLength = optionalSquare?.sideLength 枚举和结构体使用enum来创建一个枚举，枚举可以包含方法123456789101112131415161718192021enum Rank:Int &#123; case Ace = 1 case Two,Three,Four,Five,Six,Seven,Eight,Nine,Ten case Jack,Queen,King func simpleDesription() -&gt; String &#123; switch self&#123; case .Ace: return \"ace\" case .Jack: return \"Jack\" case .Queen: return \"Queen\" case .King: return \"King\" default: return String(self.toRaw()) &#125; &#125;&#125;let ace = Rank.Acelet aceRawValue = ace.toRaw() 上面的枚举原始值的类型是Int，所以需要设置当一个原始值，剩下的原始值会按照顺序赋值。也可以使用字符串或者浮点数作为枚举的原始值。 使用toRaw和fromRaw函数来在原始值和枚举值之间进行转换123if let convertedRank = Rank.froRaw(3) &#123; let threeDescription = convertedRank.simpleDescription()&#125; 枚举的成员是实际值，并不是原始值的另一种表达式。如果原始值没有意义，不重要设置1234567891011121314151617enum Suit &#123; case Spades,Hearts,Diamonds,Clubs func simpleDescription() -&gt; String &#123; switch self &#123; case .Spades: return \"spades\" case .Hearts: return \"hearts\" case .Diamonds: return \"diamonds\" case .Clubs return \"clubs\" &#125; &#125;&#125;let hearts = Suit.Heartslet heartsDescription = hearts.simpleDescription() 使用struct来创建一个结构体，结构体和类有很多相同的地方，比如方法和构造器，他们之间最大的区别就是，结构体是值传递，类是引用传递123456789struct Card&#123; var rank:Rank var suit:Suit func simpleDescription() -&gt; String &#123; return \"The \\(rank.simpleDescription()) of \\(suit.simpleDescription)\" &#125;&#125;let threeOfSpades = Card(rank: .Three,suit: .Spades)let threeOfSpadesDescription = threeOfSpades.simleDescription() 协议和扩展使用protocol来声明一个协议1234protocol ExampleProtocol &#123; var simpleDescription: String&#123;get&#125; mutating func adjust()&#125; 类、枚举和结构体都可以实现协议1234567891011121314151617181920class SimpleClass:ExampleProtocol &#123; var simpleDescription:String = \"A very simple class\" var anotherProperty: Int = 69105 func adjust()&#123; simpleDescription += \"Noew 100% adjusted.\" &#125;&#125;var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct SimpleStructire:ExampleProtocol&#123; var simpleDescription:String = \"A simple structure\" mutating func adjust()&#123; simpleDescription += \"(adjust)\" &#125;&#125;var b = SimpleStructire()b.adjust()let bDescruption = b.simpleDescription 声明的时候mutating关键字用来标记一个会修改结构体的方法。 使用extension来为现有的类型添加功能，比如新的方法和参数。123456789extension Int: ExampleProtocol&#123; var simpleDescription:String&#123; return \"The number \\(self)\" &#125; mutating func adjust()&#123; self += 42 &#125;&#125;7.simpleDescription 你可以像使用其他命名类型一样使用协议名——例如，创建一个有不同类型但是都实现一个协议的对象集合。当你处理类型是协议的值时，协议外定义的方法不可用。123let protocolValue: ExampleProtocol = aprotocolValue.simpleDescription// protocolValue.anotherProperty // Uncomment to see the error 泛型在尖括号里写一个名字来创建一个泛型函数或者类型12345678func repeat&lt;ItemType&gt;(item: ItemType,times:Int) -&gt; ItemType[]&#123; var result = ItemType[]() for i in 0..times&#123; result += item &#125; return result&#125;repeat(\"knock\",4) 也可以创建泛型类、枚举和结构体123456enum OptionalValue&lt;T&gt; &#123; case None case Some(T)&#125;var possibleInteger: OptionalValue&lt;Int&gt; = .NonepossibleInteger = .Some(100) 在类型名后面使用where来指定类型的需求，比如，限定类型实现某一个协议，限定两个类型是相同的，或者限定某个类必须有一个特定的父类1234567891011func anyCommonElements &lt;T,U where T:Sequence,U:Sequence,T.GeneratorType.Element:Equatable,T.GeneratorType.Element == U.GeneratorType.Element&gt; (1hs: T, rhs: U) -&gt; Bool &#123; or lhsItem in lhs &#123; for rhsItem in rhs &#123; if lhsItem == rhsItem &#123; return true &#125; &#125; &#125; return false&#125;anyCommonElements([1, 2, 3], [3]) 简单起见，可以忽略where，只在冒号后面写协议或者类名。和是等价的。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Swift","slug":"Swift","permalink":"http://seniorzhai.github.io/tags/Swift/"}]},{"title":"Python 五 - 模块","date":"2014-06-16T03:18:22.000Z","path":"2014/06/16/Python-五---模块/","text":"在Python中，一个.py文件就称为一个模块(Module)。为了避免模块名冲突，Python按目录来组织模块，称之为包(backage)。每个包目录下面都会有一个__init__py文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以使空文件，也可以有Python代码。 使用模块Python本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。以sys模块为例12345678910111213141516171819202122# !/usr/bin/env python# -*- coding:utf-8 -*-' a test module '# 第一个字符串会被默认视为模块的文档说明__author__ = 'Zoe'import sysdef test(): args = sys.argv if len(args) == 1: print 'Hello,world!' elif len(args) == 2: print 'Hello,%s!' % args[1] else: print 'Too many arguments!'if __name__=='__main__': test()# 当命令行运行本模块时，Python解释器吧一个特殊变量__name__置为__main__,而如果在其他地方导入该模块，if判断将会失败。# 要导入后调用才会生效if判断 别名导入模块，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：1234try: import cStringIO as StringIOexcept ImportError: # 导入失败会捕获到ImportError import StringIO 还有类似simplejson这样的库，在Python 2.6之前是独立的第三方库，从2.6开始内置，所以，会有这样的写法：1try: import json # python &gt;= 2.6 except ImportError: import simplejson as json # python &lt;= 2.5 作用域在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们不希望别人使用，有的函数和变量我们希望仅仅在模块内部使用，在Python中，是通过_前缀来实现的。正常的函数和变量名是公开的(public)，可以被直接饮用。类似xxx这样的变量是特殊变量，可以被直接饮用，但是有特殊用途，比如__name__，__author__，模块定义的文档注释课可以用__doc__访问。类似_xxx和__xxx这样的函数或变量就是非公开的(private)，不应该被直接饮用。 安装第三方模块首先需要安装setuptools工具，Mac和Linux自带了此工具，Windows下载get-pip文件，运行Python get-pip.py命令，并将\\Python27\\Spripts路径添加到Path中安装第三方模块easy_install XXX即可安装一个第三方库——Python Imaging Library，这是Python下非常强大的处理图像的工具库。一般来说，第三方库都会在Python官方的pypi.python.org网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Python Imaging Library的名称叫PIL，因此，安装Python Imaging Library的命令就是：1easy_install PIL 模块搜索路径当加载一个模块时，Python会在指定的路径下搜索对应的.py文件（搜索当前目录、所有已安装的内置模块和第三方模块），如果找不到会报错。要添加自己的搜索目录，一是直接修改模块的目录，即修改.path变量，而是设置在环境变量中。 使用futurePython提供了future模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下： 为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法：12345678# still running on Python 2.7from __future__ import unicode_literalsprint '\\'xxx\\' is unicode?', isinstance('xxx', unicode)print 'u\\'xxx\\' is unicode?', isinstance(u'xxx', unicode)print '\\'xxx\\' is str?', isinstance('xxx', str)print 'b\\'xxx\\' is str?', isinstance(b'xxx', str)","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python 四 - 函数式编程","date":"2014-06-14T03:15:54.000Z","path":"2014/06/14/Python-四---函数式编程/","text":"函数是一种把大段代码封装的一种形式，通过一层层的函数调用，可以把复杂的任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。函数式编程——Functional Programming可以归结到面向过程的程序设计，但其思想更接近数学计算。函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程编写的函数没有变量。因此任意一个函数只要输入是确定的，输出就是确定的，这种函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于韩式内部的变量状态不稳定，同样的输入，可能得到不同的输出，因此这种函数就是有副作用的。函数式编程的一个特点就是允许把函数本身作为参数传入另一个函数，还允许返回一个函数！Python对函数式编程提供部分支持，由于Python允许使用变量，因此，Python不是纯函数式编程语言。 高阶函数传入函数map()函数接收两个参数，一个函数，一个是序列，map将传入函数一次作用到序列的每个元素，并把结果作为新的list返回。举例说明，比如我们有一个函数f(x)=x^2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下：12345&gt;&gt;&gt; def f(x):... return x * x...&gt;&gt;&gt; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 像map()函数这种能够接收函数作为参数的函数，称之为高阶函数（Higher-order function）。 再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：1reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 比方说对一个序列求和，就可以用reduce实现：12345&gt;&gt;&gt; def add(x, y):... return x + y...&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])25 考虑到字符串str也是一个序列，对上面的例子稍加改动，配合map()，我们就可以写出把str转换为int的函数：12345&gt;&gt;&gt; def fn(x, y):... return x * 10 + y...&gt;&gt;&gt; reduce(fn, map(int, '13579'))13579 整理成一个str2int的函数就是：1234def str2int(s): def fn(x, y): return x * 10 + y return reduce(fn, map(int, s)) 还可以用lambda函数进一步简化成：12def str2int(s): return reduce(lambda x,y: x*10+y, map(int, s)) 排序算法Python内置的sorted()函数可以对list进行排序12&gt;&gt;&gt; sorted([34,12,43,65,1])[1, 12, 34, 43, 65] sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序，比如实现一个倒叙排序123456def reversed_cmp(x,y): if x &gt; y: return -1 if x &lt; y: return 1 return 0 传入自定义的比较函数reversed_cmp，就可以实现倒序排序：12&gt;&gt;&gt; sorted([36, 5, 12, 9, 21], reversed_cmp)[36, 21, 12, 9, 5] 再看一个字符串排序的例子：12&gt;&gt;&gt; sorted(['about', 'bob', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob'] 默认情况下，对字符串排序，是按照ASCII的大小比较的，由于’Z’ &lt; ‘a’，结果，大写字母Z会排在小写字母a的前面。 函数作为返回值高阶函数除了可以接收函数作为参数外，也可以把函数作为结果值返回。1234567def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum 调用lazy_sum()时，返回的并不是求和结果，而是求和函数：1234&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function sum at 0x10452f668&gt;&gt;&gt;&gt; f() # 调用函数f时，才真正计算求和的结果 匿名函数当我们在传入函数时，有时候，不需要显式地定义函数，直接传入匿名函数更方便。在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：12&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])[1, 4, 9, 16, 25, 36, 49, 64, 81] 通过对比可以看出，匿名函数lambda x: x * x实际上就是：12def f(x): return x * x 关键字lambda表示匿名函数，冒号前面的x表示函数参数。 匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。 用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：12345&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x10453d7d0&gt;&gt;&gt;&gt; f(5)25 同样，也可以把匿名函数作为返回值返回，比如：12def build(x, y): return lambda: x * x + y * y 装饰器由于函数也是一个对象，而且函数对象可以被赋值给变量，所以通过变量也能调用该函数123456&gt;&gt;&gt; def now():... print '2014-03-16'... &gt;&gt;&gt; f = now&gt;&gt;&gt; f()2014-03-16 函数对象有一个__name__属性，可以拿到函数的名字：1234&gt;&gt;&gt; now.__name__'now'&gt;&gt;&gt; f.__name__'now' 假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：12345def log(func): def wrapper(*args, **kw): print &apos;call %s():&apos; % func.__name__ return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：123@logdef now(): print '2013-12-25' 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：123&gt;&gt;&gt; now()call now():2013-12-25 把@log放到now()函数的定义处，相当于执行了语句：1now = log(now) 由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。wrapper()函数的参数定义是(args, *kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。 如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：1234567def log(text): def decorator(func): def wrapper(*args, **kw): print '%s %s():' % (text, func.__name__) return func(*args, **kw) return wrapper return decorator 这个3层嵌套的decorator用法如下：123@log('execute')def now(): print '2013-12-25' 执行结果如下：123&gt;&gt;&gt; now()execute now():2013-12-25 和两层嵌套的decorator相比，3层嵌套的效果是这样的：1&gt;&gt;&gt; now = log('execute')(now) 我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。 以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的’now’变成了’wrapper’：12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：12345678import functoolsdef log(func): @functools.wraps(func) def wrapper(*args, **kw): print 'call %s():' % func.__name__ return func(*args, **kw) return wrapper 或者针对带参数的decorator：12345678910import functoolsdef log(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print '%s %s():' % (text, func.__name__) return func(*args, **kw) return wrapper return decorator import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。 偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数(Parial function)functools.partial的作用就是，把一个函数的某些参数（不管有没有默认值）给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。1234567&gt;&gt;&gt; import functools&gt;&gt;&gt; def fun(i):... print i... &gt;&gt;&gt; fun2 = functools.partial(fun,i = 1)&gt;&gt;&gt; fun2()1","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"SwipRefreshLayout","date":"2014-06-13T05:25:39.000Z","path":"2014/06/13/SwipRefreshLayout/","text":"SwipRefreshLayout是Google官方推出的一款下拉刷新组件，可以实现Google Now上的下拉刷新效果。SwipRefreshLayout只能有一个直接子View，且该组件必须是支持下拉刷新的，比如ListView和ScrollView Demo示例activity_main.xml123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipe_refresh\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ListView android:id=\"@+id/listview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/ListView&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/LinearLayout&gt; listview_item.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;TextView android:id=\"@+id/item_name\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_margin=\"15dp\" android:gravity=\"center\" android:singleLine=\"true\" android:textSize=\"16sp\" android:textStyle=\"bold\" /&gt;&lt;/RelativeLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class MainActivity extends Activity implements SwipeRefreshLayout.OnRefreshListener&#123; private SwipeRefreshLayout swipeLayout; private ListView listView; private ListViewAdapter adapter; private List&lt;ItemInfo&gt; infoList; @Override protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); swipeLayout = (SwipeRefreshLayout)this.findViewById(R.id.swipe_refresh); swipeLayout.setOnRefreshListener(this); swipeLayout.setColorScheme(android.R.color.holo_red_light,android.R.color.holo_green_light,android.R.color.holo_blue_bright,android.R.color.orange_light); infoList = new ArrayList&lt;ItemInfo&gt;(); Item info = new ItemInfo(); info.setName(\"icon\"); infoList.add(info); listView = (ListView) findViewById(R.id.listView); adapter = new ListViewAdapter(this,infoList); &#125; public void onRefresh()&#123; new Handler().postDelayed(new Runnable()&#123; public void run()&#123; ItemInfo info = new ItemInfo(); info.setName(\"icon-refresh\"); info.add(info); adapter.notifyDataSetChanged(); swipeLayout.setRefreshing(false); &#125; &#125;,1500); &#125;&#125;class ItemInfo &#123; /** * id */ private int id; /** * name */ private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class ListViewAdapter extends ArrayAdapter&lt;ItemInfo&gt; &#123; private LayoutInflater inflater; public ListViewAdapter(Context context, List&lt;ItemInfo&gt; list) &#123; super(context, 0, list); inflater = LayoutInflater.from(context); &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ItemInfo info = getItem(position); if (convertView == null) &#123; convertView = inflater.inflate(R.layout.item_listview, null); &#125; TextView name = (TextView) convertView.findViewById(R.id.item_name); name.setText(info.getName()); return convertView; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Python 三 - 高级特性","date":"2014-06-13T03:15:09.000Z","path":"2014/06/13/Python-三---高级特性/","text":"切片比如一个list去前3个元素,取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。123&gt;&gt;&gt; r = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;]&gt;&gt;&gt; r[0:3][&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。记住倒数最后一个元素的索引是-1。 切片操作十分有用。我们先创建一个0-99的数列：123&gt;&gt;&gt; L = range(100)&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99] 可以通过切片轻松取出某一段数列。比如前10个数：12&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 后10个数：12&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99] 前11-20个数：12&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 前10个数，每两个取一个：12&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8] 所有数，每5个取一个：12&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95] 甚至什么都不写，只写[:]就可以原样复制一个list：12&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99] tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) 字符串’xxx’或Unicode字符串u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：1234&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 迭代因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。 list这种数据类型虽然有下标，但很多其他数据类型是没有下标的，但是，只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：1234567&gt;&gt;&gt; d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; for key in d:... print key...acb 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()。12345678910111213&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; for value in d.itervalues():... print value... 132&gt;&gt;&gt; for k,v in d.iteritems():... print k,v... a 1c 3b 2 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：123456&gt;&gt;&gt; for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):... print i, value...0 A1 B2 C for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print x, y...1 12 43 9 列表生成式列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。举个例子，要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]可以用range(1, 11)：12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 还可以使用两层循环，可以生成全排列：12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：123&gt;&gt;&gt; import os # 导入os模块&gt;&gt;&gt; [d for d in os.listdir(&apos;.&apos;)] # os.listdir可以列出文件和目录[&apos;.emacs.d&apos;, &apos;.ssh&apos;, &apos;.Trash&apos;, &apos;Adlm&apos;, &apos;Applications&apos;, &apos;Desktop&apos;, &apos;Documents&apos;, &apos;Downloads&apos;, &apos;Library&apos;, &apos;Movies&apos;, &apos;Music&apos;, &apos;Pictures&apos;, &apos;Public&apos;, &apos;VirtualBox VMs&apos;, &apos;Workspace&apos;, &apos;XCode&apos;] 内建的isinstance函数可以判断一个变量是不是字符串：123456&gt;&gt;&gt; x = &apos;abc&apos;&gt;&gt;&gt; y = 123&gt;&gt;&gt; isinstance(x, str)True&gt;&gt;&gt; isinstance(y, str)False 生成器列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。123&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x104feab40&gt; 如果要一个一个打印出来，可以通过generator的next()方法：123456789101112131415161718192021222324&gt;&gt;&gt; g.next()0&gt;&gt;&gt; g.next()1&gt;&gt;&gt; g.next()4&gt;&gt;&gt; g.next()9&gt;&gt;&gt; g.next()16&gt;&gt;&gt; g.next()25&gt;&gt;&gt; g.next()36&gt;&gt;&gt; g.next()49&gt;&gt;&gt; g.next()64&gt;&gt;&gt; g.next()81&gt;&gt;&gt; g.next()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。 generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到： 1, 1, 2, 3, 5, 8, 13, 21, 34, … 斐波拉契数列用列表生成式写不出来，但是，用函数把它打印出来却很容易：123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: print b a, b = b, a + b n = n + 1 上面的函数可以输出斐波那契数列的前N个数：1234567&gt;&gt;&gt; fab(6)112358 仔细观察，可以看出，fab函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。 也就是说，上面的函数和generator仅一步之遥。要把fab函数变成generator，只需要把print b改为yield b就可以了：123456def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator：12&gt;&gt;&gt; fab(6)&lt;generator object fab at 0x104feaaa0&gt; 这里，最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。12345678910111213141516171819&gt;&gt;&gt; def fun():... print 'step1'... yield... print 'step2'... yield... print 'step3'... yield... &gt;&gt;&gt; o = fun()&gt;&gt;&gt; o.next()step1&gt;&gt;&gt; o.next()step2&gt;&gt;&gt; o.next()step3&gt;&gt;&gt; o.next()Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Android布局小问题","date":"2014-06-12T05:24:52.000Z","path":"2014/06/12/Android布局小问题/","text":"padding 控件的内容相对控件边缘的边距 margin 控件边缘相对父控件的边距 android:gravity 该view内容的限定限定位置 android:layout_gravity 设置该view中的子view相对于父view的限定位置","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Python 二 - 集合","date":"2014-06-12T05:13:44.000Z","path":"2014/06/12/Python-二---集合/","text":"list 和 tuplelistlist是Python内置的一种数据类型是列表，为一种有序的集合，可以随时添加和删除其中的元素。例如，列出班级中所有同学的名字：12classmates = ['Michael','Bob','Tracy']print classmates 可以用len()函数获取list元素的个数12&gt;&gt;&gt; len(classmates)3 用索引来访问list中每一个位置的元素，记得索引是从0开始的：12345678910&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[2]'Tracy'&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：12&gt;&gt;&gt; classmates[-1]&apos;Tracy&apos; 以此类推，可以获取倒数第2个、倒数第3个：12345678&gt;&gt;&gt; classmates[-2]'Bob'&gt;&gt;&gt; classmates[-3]'Michael'&gt;&gt;&gt; classmates[-4]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 当然，倒数第4个就越界了。 list是一个可变的有序表，所以，可以往list中追加元素到末尾：123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置，比如索引号为1的位置：123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除list末尾的元素，用pop()方法：1234&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置：1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy'] list里面的元素的数据类型也可以不同，比如：1&gt;&gt;&gt; L = ['Apple', 123, True] list元素也可以是另一个list，比如：123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4 要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：12&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme'] 要拿到’php’可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。 如果一个list中一个元素也没有，就是一个空的list，它的长度为0：123&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0 tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：1&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy') 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。 不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2) 如果要定义一个空的tuple，可以写成()：123&gt;&gt;&gt; t = ()&gt;&gt;&gt; t() 但是，要定义一个只有1个元素的tuple，如果你这么定义：123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 最后来看一个“可变的”tuple：12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) 这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？ 别急，我们先看看定义的时候tuple包含的3个元素：当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 小结list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。 条件判断和循环条件判断根据Python的缩进规则，如果if语句判断是True,就把缩进的语句执行，否则不执行。也可以给if添加一个else语句，如果if判断是False，就不执行if的内容，而执行else的内容1234if(3&gt;2): print '执行这里'else: print '没执行这里' 注意不要少写冒号&quot;:&quot;123456789elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 循环Python的循环有两种，一种是for…in循环，用于遍历list或者tuple123colors = ['red','blue','green']for color in colors: print color 执行这段代码会依次打印colors的每一个元素123redbluegreen Python提供了一个range()函数，可以生成一个整数序列，我们可以计算一个1-100的整数之和1234sum = 0for x in range(101): sum = sum + xprint sum 第二种循环是while循环，和C语言一样，只要条件为True，就会执行循环体123456sum = 0n = 1while n &lt;= 100: sum = sum + n n = n + 1print sum 如果死循环了，记得用Ctrl + C退出循环 dict和setdictdict就是dictionary，在Java里也成为map，使用键值对（key-value）存储，具有极快的查找速度例如记录同学们的成绩12d = &#123;'Michael':95,'Bob':75,'Tracy':85&#125;print d['Micheal'] 除了初始化时指定外，存储value时，通过key放入(相同的key赋值的话，会覆盖掉之前的value)：1&gt;&gt;&gt; d['Adam'] = 76 如果key不存在dict会报错，为了避免这种错误，可以通过in判断key是否存在，或者使用dict的get方法，获取value，不存在的话会返回None123dic = &#123;&quot;a&quot;:67,&quot;c&quot;:12,&quot;b&quot;:1&#125;print &apos;d&apos; in dicprint dic.get(&quot;d&quot;) 要删除一个key，使用pop(key)方法与list相比，dict有以下几个特点 查找和插入的速度极快，不会随着key的增加而增加 需要占用大量内存，内存浪费多而list相反 查找和插入的时间随着元素的增加而增加 占用空间小，浪费内存很小 SetSet和dict类似，但是不存在value，只存一组key,而且key不能重复，所以Set中没有重复的key123&gt;&gt;&gt; s = set([1,2,3,4,5,1,2,3,4,5])&gt;&gt;&gt; sset([1, 2, 3, 4, 5]) 重复的元素会被自动过滤掉添加元素可以使用set的add(key)方法，可以重复添加，但不会有效果，删除元素使用remove(key)方法12345678&gt;&gt;&gt; s = set([])&gt;&gt;&gt; s.add(1)&gt;&gt;&gt; s.add(2)&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s.remove(3)&gt;&gt;&gt; sset([1, 2, 4]) 注意删除的元素必须存在，否则报错set可以看成数学上的无序和无重复元素的集合，所以也可以做交集和并集的运算操作123456&gt;&gt;&gt; s1 = set([1,2,3,4])&gt;&gt;&gt; s2 = set([2,4,6,8])&gt;&gt;&gt; s1 &amp; s2set([2, 4])&gt;&gt;&gt; s1 | s2set([1, 2, 3, 4, 6, 8]) 函数Python内置了很多很有用的函数，我们可以直接调用。可以在Python的官网上查看文档可以在命令行通过help()查看某个函数的帮助信息1234567help(abs)Help on built-in function abs in module __builtin__:abs(...) abs(number) -&gt; number Return the absolute value of the argument. 数据类型转换Python内置常用的函数，比如int()函数就可以把其他数据类型转换为整数：12&gt;&gt;&gt; int('123')123 函数名其实就是函数对象的引用，所以可以用一个变量指向该引用，实现别名的效果123&gt;&gt;&gt; a = abs&gt;&gt;&gt; a(-1)1 主要使用函数时，一定要传入正确的参数，否则会出错。 函数的定义在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。12def fun(x,y): return x+y 空函数定义一个什么事也不做的空函数，可以使用pass语句12def nop(): pass 参数检查Python会进行参数个数的检查，如果不对会抛出TypeError，但是类型并不会进行检查 默认参数在定义时为某个参数初始化一个值，若调用时，该参数缺省时，便会使用默认的值123456def power(x,n = 2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 可变参数函数参数个数可变时，我们可以通过list或者tuple包装参数，传入函数，函数会接收到tuple1234567def add(numbers): sum = 0 for number in numbers: sum = sum + number return sumadd([1,2,3,4,5]) 12345def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])14 关键字参数关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装成为一个dict12def person(name,age,**kw): print 'name:',name,'age':,age,'other:',kw 函数person除了参数name和age外，还接受关键字参数kw。在调用该函数时，可以之传入必选参数，或者任意个关键字参数123456&gt;&gt;&gt; person(&apos;Michael&apos;, 30)name: Michael age: 30 other: &#123;&#125;&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数和关键字参数，这4种参数都可以一起使用，或者只用其中的一部分，但定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。比如：12def fun(a,b,c=0,*args,**kw) print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw 调用时，Python接收器自动按照参数位置和参数名把对应的参数传进去12345678&gt;&gt;&gt; func(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125; 最神奇的是通过一个tuple和dict，你也可以调用该函数：1234&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&apos;x&apos;: 99&#125;&gt;&gt;&gt; func(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;x&apos;: 99&#125; 递归函数如果一个函数在内部调用自身，这个函数就是递归函数。在Python中使用递归函数要注意栈溢出,在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Python 一 - 基础","date":"2014-06-12T03:12:36.000Z","path":"2014/06/12/Python-一---基础/","text":"断断续续的学了几次Python了，所谓不求甚解，语法过了一遍没去用忘了，又过一遍又没去用又忘了。虽然现在用Python的机会不多，还是真心喜欢这门语言。所以还是另起门户，把学习笔记记下来，免得自己捡起来又扔掉了。 Python是著名的“龟叔”Guido van Russum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言（我的天。。。）。牛逼闪闪的“龟叔”Python提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，还有大量的第三方库。 Python的定位是优雅、明确、简单，Python是不能加密的，发布Python程序就相当于发布了源代码（到处都能看源代码，想想都有点小激动呢）。 安装PythonMacPython是Mac上的一等公民，天生自带。 Windows1.从Python官网在下2.7.X版本2.运行.MSI安装包，一路Nest即可3.添加环境变量，即把Python的安装路径添加到系统环境变量path中去 Linux没实践过不表，相信google、百度一大把 First Blood国际惯例，我们编写一个Hello,World 在命令行里计入Python交互环境（Python，回车）：12&gt;&gt;&gt; print &quot;Hello,world&quot;Hello,world 完成。 输入与输出输出用print加上字符串，就可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下：1&gt;&gt;&gt; print &apos;hello, world&apos; print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：12&gt;&gt;&gt; print &apos;The quick brown fox&apos;, &apos;jumps over&apos;, &apos;the lazy dog&apos;The quick brown fox jumps over the lazy dog 输入Python提供了一个raw_input，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：1234&gt;&gt;&gt; name = raw_input()zoe&gt;&gt;&gt; name&apos;zoe&apos; 当你输入name = raw_input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。我们在文本编辑器中编写一个完整版的试试：1234# !/usr/bin/env pythonname = raw_input(&apos;please enter your name:&apos;)print &apos;hello,&apos;,name 在终端运行，切换到文件的目录(注意权限，可能需要chmod a+x)123./hello.pyplease enter your name:zoehello, zoe Python基础Python以#开头的语句是注解，注解是给人看的，所以解释器会忽略掉注释。其他没一行都是一个语句，当语句以冒号&quot;:&quot;结尾时，所接的语句视为代码块。还有一点值得注意，Python是大小写敏感的，大小写区分，如果写错了大小写，程序会报错 数据类型整数Python可以处理任意大小的整数，包括负整数，如：1,1000,-1000,0等，十六进度也使用0x前缀和0-9、a-f表示，如：0xffff,0xabcd1234等 浮点数数学写法，如1.23、-4.5、3.1415926，科学计数法，把10用e表示，即1.23e9或13.54e-6。 字符串字符串是以’’或””括起来的任意文本，比如”abc”,’123xyz’.Python也有转义字符，如\\n、\\t、\\&#39;等等。Python 还允许用r&#39;&#39;表示’’内的字符串默认不转义：1234&gt;&gt;&gt; print &apos;\\\\\\t\\\\&apos;\\ \\&gt;&gt;&gt; print r&apos;\\\\\\t\\\\&apos;\\\\\\t\\\\ Python允许使用&#39;&#39;&#39;...&#39;&#39;&#39;表示多行内容12345678&gt;&gt;&gt; print &apos;&apos;&apos;line1... line2... line3... line4&apos;&apos;&apos;line1line2line3line4 布尔值布尔只存在True、False两种值（注意大小写）通过布尔运算：123456&gt;&gt;&gt; 3 &gt; 3False&gt;&gt;&gt; 3 &gt;= 3True&gt;&gt;&gt; 3 &gt; 2True 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True;or运算是或运算，只要其中有一个为True，or运算结果就是True;not运算是非运算，它是一个单目运算符，把True变成False，False变成True;12345678910111213141516&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue 空值空值在Python里用None表示 变量Python里的变量貌似缺少定义的过程，而且不限制数据类型，可以是任意的数据类型，命名方式与C相同：必须是大小写英文、数字和_的组合，且不能用数字开头12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&gt;&gt;&gt; a = 2&gt;&gt;&gt; b = 5&gt;&gt;&gt; c = a&gt;&gt;&gt; a = b&gt;&gt;&gt; b = c&gt;&gt;&gt; print a,b,c5 2 2``### 常量常量即不可变的量，但是Python根本没有任何机制保证常量不可变，通常使用全部大写的变量名，表示常量，而不去改变它。### Python数据之我见Python其实是把任何数据都当作对象，变量只是指向这些数据对象### 字符编码#### 字符编码字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。字母A用ASCII编码是十进制的65，二进制的01000001；字母0用ASCII编码是十进制的48，二进制的00110000，注意字母&apos;0&apos;和整数0是不同的；汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：|**字符**|**ASCII**|**Unicode**|**UTF-8**||---|---|---|---||A|01000001|00000000 01000001|01000001|中|x|01001110|00101101 11100100|10111000 10101101|从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：![](https://github.com/zt1991616/blog/raw/master/Image/14031402.png)浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：![](https://github.com/zt1991616/blog/raw/master/Image/14031403.png)#### Python的字符串Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换： ord(‘A’)65chr(65)‘A’1Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u&apos;...&apos;表示，比如： print u’中文’中文u’中’u’\\u4e2d’12把u&apos;xxx&apos;转换为UTF-8编码的&apos;xxx&apos;用encode(&apos;utf-8&apos;)方法： u’ABC’.encode(‘utf-8’)‘ABC’u’中文’.encode(‘utf-8’)‘\\xe4\\xb8\\xad\\xe6\\x96\\x87’12len()函数可以返回字符串的长度： len(u’ABC’)3len(‘ABC’)3len(u’中文’)2len(‘\\xe4\\xb8\\xad\\xe6\\x96\\x87’)612反过来，把UTF-8编码表示的字符串&apos;xxx&apos;转换为Unicode字符串u&apos;xxx&apos;用decode(&apos;utf-8&apos;)方法： ‘abc’.decode(‘utf-8’)u’abc’‘\\xe4\\xb8\\xad\\xe6\\x96\\x87’.decode(‘utf-8’)u’\\u4e2d\\u6587’print ‘\\xe4\\xb8\\xad\\xe6\\x96\\x87’.decode(‘utf-8’)中文1由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： !/usr/bin/env python-- coding: utf-8 --12345678第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。#### 格式化格式化方式与C语言抑制，用`%`实现例如： ‘Hello, %s’ % ‘world’‘Hello, world’‘Hi, %s, you have $%d.’ % (‘Zoe’, 1000000)‘Hi, Zoe, you have $1000000.’```|%d|整数||—|—||%f|浮点数||%s|字符串||%x|十六进制数|","tags":[{"name":"Python","slug":"Python","permalink":"http://seniorzhai.github.io/tags/Python/"}]},{"title":"Google 全球IP地址库","date":"2014-06-12T03:06:55.000Z","path":"2014/06/12/Google-全球IP地址库/","text":"Bulgaria 93.123.23.1 93.123.23.2 93.123.23.3 93.123.23.4 93.123.23.5 93.123.23.6 93.123.23.7 93.123.23.8 93.123.23.9 93.123.23.10 93.123.23.11 93.123.23.12 93.123.23.13 93.123.23.14 93.123.23.15 93.123.23.16 93.123.23.17 93.123.23.18 93.123.23.19 93.123.23.20 93.123.23.21 93.123.23.22 93.123.23.23 93.123.23.24 93.123.23.25 93.123.23.26 93.123.23.27 93.123.23.28 93.123.23.29 93.123.23.30 93.123.23.31 93.123.23.32 93.123.23.33 93.123.23.34 93.123.23.35 93.123.23.36 93.123.23.37 93.123.23.38 93.123.23.39 93.123.23.40 93.123.23.41 93.123.23.42 93.123.23.43 93.123.23.44 93.123.23.45 93.123.23.46 93.123.23.47 93.123.23.48 93.123.23.49 93.123.23.50 93.123.23.51 93.123.23.52 93.123.23.53 93.123.23.54 93.123.23.55 93.123.23.56 93.123.23.57 93.123.23.58 93.123.23.59 Top Egypt 197.199.253.1 197.199.253.2 197.199.253.3 197.199.253.4 197.199.253.5 197.199.253.6 197.199.253.7 197.199.253.8 197.199.253.9 197.199.253.10 197.199.253.11 197.199.253.12 197.199.253.13 197.199.253.14 197.199.253.15 197.199.253.16 197.199.253.17 197.199.253.18 197.199.253.19 197.199.253.20 197.199.253.21 197.199.253.22 197.199.253.23 197.199.253.24 197.199.253.25 197.199.253.26 197.199.253.27 197.199.253.28 197.199.253.29 197.199.253.30 197.199.253.31 197.199.253.32 197.199.253.33 197.199.253.34 197.199.253.35 197.199.253.36 197.199.253.37 197.199.253.38 197.199.253.39 197.199.253.40 197.199.253.41 197.199.253.42 197.199.253.43 197.199.253.44 197.199.253.45 197.199.253.46 197.199.253.47 197.199.253.48 197.199.253.49 197.199.253.50 197.199.253.51 197.199.253.52 197.199.253.53 197.199.253.54 197.199.253.55 197.199.253.56 197.199.253.57 197.199.253.58 197.199.253.59 Top Egypt 197.199.254.1 197.199.254.2 197.199.254.3 197.199.254.4 197.199.254.5 197.199.254.6 197.199.254.7 197.199.254.8 197.199.254.9 197.199.254.10 197.199.254.11 197.199.254.12 197.199.254.13 197.199.254.14 197.199.254.15 197.199.254.16 197.199.254.17 197.199.254.18 197.199.254.19 197.199.254.20 197.199.254.21 197.199.254.22 197.199.254.23 197.199.254.24 197.199.254.25 197.199.254.26 197.199.254.27 197.199.254.28 197.199.254.29 197.199.254.30 197.199.254.31 197.199.254.32 197.199.254.33 197.199.254.34 197.199.254.35 197.199.254.36 197.199.254.37 197.199.254.38 197.199.254.39 197.199.254.40 197.199.254.41 197.199.254.42 197.199.254.43 197.199.254.44 197.199.254.45 197.199.254.46 197.199.254.47 197.199.254.48 197.199.254.49 197.199.254.50 197.199.254.51 197.199.254.52 197.199.254.53 197.199.254.54 197.199.254.55 197.199.254.56 197.199.254.57 197.199.254.58 197.199.254.59 Top Hong Kong 218.189.25.129 218.189.25.130 218.189.25.131 218.189.25.132 218.189.25.133 218.189.25.134 218.189.25.135 218.189.25.136 218.189.25.137 218.189.25.138 218.189.25.139 218.189.25.140 218.189.25.141 218.189.25.142 218.189.25.143 218.189.25.144 218.189.25.145 218.189.25.146 218.189.25.147 218.189.25.148 218.189.25.149 218.189.25.150 218.189.25.151 218.189.25.152 218.189.25.153 218.189.25.154 218.189.25.155 218.189.25.156 218.189.25.157 218.189.25.158 218.189.25.159 218.189.25.160 218.189.25.161 218.189.25.162 218.189.25.163 218.189.25.164 218.189.25.165 218.189.25.166 218.189.25.167 218.189.25.168 218.189.25.169 218.189.25.170 218.189.25.171 218.189.25.172 218.189.25.173 218.189.25.174 218.189.25.175 218.189.25.176 218.189.25.177 218.189.25.178 218.189.25.179 218.189.25.180 218.189.25.181 218.189.25.182 218.189.25.183 218.189.25.184 218.189.25.185 218.189.25.186 218.189.25.187 Top Hong Kong 218.253.0.76 218.253.0.77 218.253.0.78 218.253.0.79 218.253.0.80 218.253.0.81 218.253.0.82 218.253.0.83 218.253.0.84 218.253.0.85 218.253.0.86 218.253.0.87 218.253.0.88 218.253.0.89 218.253.0.90 218.253.0.91 218.253.0.92 218.253.0.140 218.253.0.141 218.253.0.142 218.253.0.143 218.253.0.144 218.253.0.145 218.253.0.146 218.253.0.147 218.253.0.148 218.253.0.149 218.253.0.150 218.253.0.151 218.253.0.152 218.253.0.153 218.253.0.154 218.253.0.155 218.253.0.156 218.253.0.157 218.253.0.158 218.253.0.159 218.253.0.160 218.253.0.161 218.253.0.162 218.253.0.163 218.253.0.164 218.253.0.165 218.253.0.166 218.253.0.167 218.253.0.168 218.253.0.169 218.253.0.170 218.253.0.171 218.253.0.172 218.253.0.173 218.253.0.174 218.253.0.175 218.253.0.176 218.253.0.177 218.253.0.178 218.253.0.179 218.253.0.180 218.253.0.181 218.253.0.182 218.253.0.183 218.253.0.184 218.253.0.185 218.253.0.186 218.253.0.187 Top Iceland 149.126.86.1 149.126.86.2 149.126.86.3 149.126.86.4 149.126.86.5 149.126.86.6 149.126.86.7 149.126.86.8 149.126.86.9 149.126.86.10 149.126.86.11 149.126.86.12 149.126.86.13 149.126.86.14 149.126.86.15 149.126.86.16 149.126.86.17 149.126.86.18 149.126.86.19 149.126.86.20 149.126.86.21 149.126.86.22 149.126.86.23 149.126.86.24 149.126.86.25 149.126.86.26 149.126.86.27 149.126.86.28 149.126.86.29 149.126.86.30 149.126.86.31 149.126.86.32 149.126.86.33 149.126.86.34 149.126.86.35 149.126.86.36 149.126.86.37 149.126.86.38 149.126.86.39 149.126.86.40 149.126.86.41 149.126.86.42 149.126.86.43 149.126.86.44 149.126.86.45 149.126.86.46 149.126.86.47 149.126.86.48 149.126.86.49 149.126.86.50 149.126.86.51 149.126.86.52 149.126.86.53 149.126.86.54 149.126.86.55 149.126.86.56 149.126.86.57 149.126.86.58 149.126.86.59 Top Indonesia 111.92.162.4 111.92.162.5 111.92.162.6 111.92.162.12 111.92.162.13 111.92.162.14 111.92.162.15 111.92.162.16 111.92.162.17 111.92.162.18 111.92.162.19 111.92.162.20 111.92.162.21 111.92.162.22 111.92.162.23 111.92.162.24 111.92.162.25 111.92.162.26 111.92.162.27 111.92.162.28 111.92.162.29 111.92.162.30 111.92.162.31 111.92.162.32 111.92.162.33 111.92.162.34 111.92.162.35 111.92.162.36 111.92.162.37 111.92.162.38 111.92.162.39 111.92.162.40 111.92.162.41 111.92.162.42 111.92.162.43 111.92.162.44 111.92.162.45 111.92.162.46 111.92.162.47 111.92.162.48 111.92.162.49 111.92.162.50 111.92.162.51 111.92.162.52 111.92.162.53 111.92.162.54 111.92.162.55 111.92.162.56 111.92.162.57 111.92.162.58 111.92.162.59 Top Iraq 62.201.216.196 62.201.216.197 62.201.216.198 62.201.216.199 62.201.216.200 62.201.216.201 62.201.216.202 62.201.216.203 62.201.216.204 62.201.216.205 62.201.216.206 62.201.216.207 62.201.216.208 62.201.216.209 62.201.216.210 62.201.216.211 62.201.216.212 62.201.216.213 62.201.216.214 62.201.216.215 62.201.216.216 62.201.216.217 62.201.216.218 62.201.216.219 62.201.216.220 62.201.216.221 62.201.216.222 62.201.216.223 62.201.216.224 62.201.216.225 62.201.216.226 62.201.216.227 62.201.216.228 62.201.216.229 62.201.216.230 62.201.216.231 62.201.216.232 62.201.216.233 62.201.216.234 62.201.216.235 62.201.216.236 62.201.216.237 62.201.216.238 62.201.216.239 62.201.216.240 62.201.216.241 62.201.216.242 62.201.216.243 62.201.216.244 62.201.216.245 62.201.216.246 62.201.216.247 62.201.216.248 62.201.216.249 62.201.216.250 62.201.216.251 Top Japan 218.176.242.4 218.176.242.5 218.176.242.6 218.176.242.7 218.176.242.8 218.176.242.9 218.176.242.10 218.176.242.11 218.176.242.12 218.176.242.13 218.176.242.14 218.176.242.15 218.176.242.16 218.176.242.17 218.176.242.18 218.176.242.19 218.176.242.20 218.176.242.21 218.176.242.22 218.176.242.23 218.176.242.24 218.176.242.25 218.176.242.26 218.176.242.27 218.176.242.28 218.176.242.29 218.176.242.30 218.176.242.31 218.176.242.32 218.176.242.33 218.176.242.34 218.176.242.35 218.176.242.36 218.176.242.37 218.176.242.38 218.176.242.39 218.176.242.40 218.176.242.41 218.176.242.42 218.176.242.43 218.176.242.44 218.176.242.45 218.176.242.46 218.176.242.47 218.176.242.48 218.176.242.49 218.176.242.50 218.176.242.51 218.176.242.52 218.176.242.53 218.176.242.54 218.176.242.55 218.176.242.56 218.176.242.57 218.176.242.58 218.176.242.59 218.176.242.60 218.176.242.61 218.176.242.62 218.176.242.63 218.176.242.64 218.176.242.65 218.176.242.66 218.176.242.67 218.176.242.68 218.176.242.69 218.176.242.70 218.176.242.71 218.176.242.72 218.176.242.73 218.176.242.74 218.176.242.75 218.176.242.76 218.176.242.77 218.176.242.78 218.176.242.79 218.176.242.80 218.176.242.81 218.176.242.82 218.176.242.83 218.176.242.84 218.176.242.85 218.176.242.86 218.176.242.87 218.176.242.88 218.176.242.89 218.176.242.90 218.176.242.91 218.176.242.92 218.176.242.93 218.176.242.94 218.176.242.95 218.176.242.96 218.176.242.97 218.176.242.98 218.176.242.99 218.176.242.100 218.176.242.101 218.176.242.102 218.176.242.103 218.176.242.104 218.176.242.105 218.176.242.106 218.176.242.107 218.176.242.108 218.176.242.109 218.176.242.110 218.176.242.111 218.176.242.112 218.176.242.113 218.176.242.114 218.176.242.115 218.176.242.116 218.176.242.117 218.176.242.118 218.176.242.119 218.176.242.120 218.176.242.121 218.176.242.122 218.176.242.123 218.176.242.124 218.176.242.125 218.176.242.126 218.176.242.127 218.176.242.128 218.176.242.129 218.176.242.130 218.176.242.131 218.176.242.132 218.176.242.133 218.176.242.134 218.176.242.135 218.176.242.136 218.176.242.137 218.176.242.138 218.176.242.139 218.176.242.140 218.176.242.141 218.176.242.142 218.176.242.143 218.176.242.144 218.176.242.145 218.176.242.146 218.176.242.147 218.176.242.148 218.176.242.149 218.176.242.150 218.176.242.151 218.176.242.152 218.176.242.153 218.176.242.154 218.176.242.155 218.176.242.156 218.176.242.157 218.176.242.158 218.176.242.159 218.176.242.160 218.176.242.161 218.176.242.162 218.176.242.163 218.176.242.164 218.176.242.165 218.176.242.166 218.176.242.167 218.176.242.168 218.176.242.169 218.176.242.170 218.176.242.171 218.176.242.172 218.176.242.173 218.176.242.174 218.176.242.175 218.176.242.176 218.176.242.177 218.176.242.178 218.176.242.179 218.176.242.180 218.176.242.181 218.176.242.182 218.176.242.183 218.176.242.184 218.176.242.185 218.176.242.186 218.176.242.187 218.176.242.188 218.176.242.189 218.176.242.190 218.176.242.191 218.176.242.192 218.176.242.193 218.176.242.194 218.176.242.195 218.176.242.196 218.176.242.197 218.176.242.198 218.176.242.199 218.176.242.200 218.176.242.201 218.176.242.202 218.176.242.203 218.176.242.204 218.176.242.205 218.176.242.206 218.176.242.207 218.176.242.208 218.176.242.209 218.176.242.210 218.176.242.211 218.176.242.212 218.176.242.213 218.176.242.214 218.176.242.215 218.176.242.216 218.176.242.217 218.176.242.218 218.176.242.219 218.176.242.220 218.176.242.221 218.176.242.222 218.176.242.223 218.176.242.224 218.176.242.225 218.176.242.226 218.176.242.227 218.176.242.228 218.176.242.229 218.176.242.230 218.176.242.231 218.176.242.232 218.176.242.233 218.176.242.234 218.176.242.235 218.176.242.236 218.176.242.237 218.176.242.238 218.176.242.239 218.176.242.240 218.176.242.241 218.176.242.242 218.176.242.243 218.176.242.244 218.176.242.245 218.176.242.246 218.176.242.247 218.176.242.248 218.176.242.249 218.176.242.250 218.176.242.251 Top Kenya 41.84.159.12 41.84.159.13 41.84.159.14 41.84.159.15 41.84.159.16 41.84.159.17 41.84.159.18 41.84.159.19 41.84.159.20 41.84.159.21 41.84.159.22 41.84.159.23 41.84.159.24 41.84.159.25 41.84.159.26 41.84.159.27 41.84.159.28 41.84.159.29 41.84.159.30 Top Korea 121.78.74.68 121.78.74.69 121.78.74.70 121.78.74.71 121.78.74.72 121.78.74.73 121.78.74.74 121.78.74.75 121.78.74.76 121.78.74.77 121.78.74.78 121.78.74.79 121.78.74.80 121.78.74.81 121.78.74.82 121.78.74.83 121.78.74.84 121.78.74.85 121.78.74.86 121.78.74.87 121.78.74.88 121.78.74.89 121.78.74.90 121.78.74.91 121.78.74.92 121.78.74.93 121.78.74.94 121.78.74.95 121.78.74.96 121.78.74.97 121.78.74.98 121.78.74.99 121.78.74.100 121.78.74.101 121.78.74.102 121.78.74.103 121.78.74.104 121.78.74.105 121.78.74.106 121.78.74.107 121.78.74.108 121.78.74.109 121.78.74.110 121.78.74.111 121.78.74.112 121.78.74.113 121.78.74.114 121.78.74.115 121.78.74.116 121.78.74.117 121.78.74.118 121.78.74.119 121.78.74.120 121.78.74.121 121.78.74.122 121.78.74.123 Top Mauritius 41.206.96.1 41.206.96.2 41.206.96.3 41.206.96.4 41.206.96.5 41.206.96.6 41.206.96.7 41.206.96.8 41.206.96.9 41.206.96.10 41.206.96.11 41.206.96.12 41.206.96.13 41.206.96.14 41.206.96.15 41.206.96.16 41.206.96.17 41.206.96.18 41.206.96.19 41.206.96.20 41.206.96.21 41.206.96.22 41.206.96.23 41.206.96.24 41.206.96.25 41.206.96.26 41.206.96.27 41.206.96.28 41.206.96.29 41.206.96.30 41.206.96.31 41.206.96.32 41.206.96.33 41.206.96.34 41.206.96.35 41.206.96.36 41.206.96.37 41.206.96.38 41.206.96.39 41.206.96.40 41.206.96.41 41.206.96.42 41.206.96.43 41.206.96.44 41.206.96.45 41.206.96.46 41.206.96.47 41.206.96.48 41.206.96.49 41.206.96.50 41.206.96.51 41.206.96.52 41.206.96.53 41.206.96.54 41.206.96.55 41.206.96.56 41.206.96.57 41.206.96.58 41.206.96.59 41.206.96.60 41.206.96.61 41.206.96.62 41.206.96.63 41.206.96.64 41.206.96.65 41.206.96.66 41.206.96.67 41.206.96.68 41.206.96.69 41.206.96.70 41.206.96.71 41.206.96.72 41.206.96.73 41.206.96.74 41.206.96.75 41.206.96.76 41.206.96.77 41.206.96.78 41.206.96.79 41.206.96.80 41.206.96.81 41.206.96.82 41.206.96.83 41.206.96.84 41.206.96.85 41.206.96.86 41.206.96.87 41.206.96.88 41.206.96.89 41.206.96.90 41.206.96.91 41.206.96.92 41.206.96.93 41.206.96.94 41.206.96.95 41.206.96.96 41.206.96.97 41.206.96.98 41.206.96.99 41.206.96.100 41.206.96.101 41.206.96.102 41.206.96.103 41.206.96.104 41.206.96.105 41.206.96.106 41.206.96.107 41.206.96.108 41.206.96.109 41.206.96.110 41.206.96.111 41.206.96.112 41.206.96.113 41.206.96.114 41.206.96.115 41.206.96.116 41.206.96.117 41.206.96.118 41.206.96.119 41.206.96.120 41.206.96.121 41.206.96.122 41.206.96.123 41.206.96.124 41.206.96.125 41.206.96.126 41.206.96.127 41.206.96.128 41.206.96.129 41.206.96.130 41.206.96.131 41.206.96.132 41.206.96.133 41.206.96.134 41.206.96.135 41.206.96.136 41.206.96.137 41.206.96.138 41.206.96.139 41.206.96.140 41.206.96.141 41.206.96.142 41.206.96.143 41.206.96.144 41.206.96.145 41.206.96.146 41.206.96.147 41.206.96.148 41.206.96.149 41.206.96.150 41.206.96.151 41.206.96.152 41.206.96.153 41.206.96.154 41.206.96.155 41.206.96.156 41.206.96.157 41.206.96.158 41.206.96.159 41.206.96.160 41.206.96.161 41.206.96.162 41.206.96.163 41.206.96.164 41.206.96.165 41.206.96.166 41.206.96.167 41.206.96.168 41.206.96.169 41.206.96.170 41.206.96.171 41.206.96.172 41.206.96.173 41.206.96.174 41.206.96.175 41.206.96.176 41.206.96.177 41.206.96.178 41.206.96.179 41.206.96.180 41.206.96.181 41.206.96.182 41.206.96.183 41.206.96.184 41.206.96.185 41.206.96.186 41.206.96.187 41.206.96.188 41.206.96.189 41.206.96.190 41.206.96.191 41.206.96.192 41.206.96.193 41.206.96.194 41.206.96.195 41.206.96.196 41.206.96.197 41.206.96.198 41.206.96.199 41.206.96.200 41.206.96.201 41.206.96.202 41.206.96.203 41.206.96.204 41.206.96.205 41.206.96.206 41.206.96.207 41.206.96.208 41.206.96.209 41.206.96.210 41.206.96.211 41.206.96.212 41.206.96.213 41.206.96.214 41.206.96.215 41.206.96.216 41.206.96.217 41.206.96.218 41.206.96.219 41.206.96.220 41.206.96.221 41.206.96.222 41.206.96.223 41.206.96.224 41.206.96.225 41.206.96.226 41.206.96.227 41.206.96.228 41.206.96.229 41.206.96.230 41.206.96.231 41.206.96.232 41.206.96.233 41.206.96.234 41.206.96.235 41.206.96.236 41.206.96.237 41.206.96.238 41.206.96.239 41.206.96.240 41.206.96.241 41.206.96.242 41.206.96.243 41.206.96.244 41.206.96.245 41.206.96.246 41.206.96.247 41.206.96.248 41.206.96.249 41.206.96.250 41.206.96.251 Top Netherlands 88.159.13.196 88.159.13.197 88.159.13.198 88.159.13.199 88.159.13.200 88.159.13.201 88.159.13.202 88.159.13.203 88.159.13.204 88.159.13.205 88.159.13.206 88.159.13.207 88.159.13.208 88.159.13.209 88.159.13.210 88.159.13.211 88.159.13.212 88.159.13.213 88.159.13.214 88.159.13.215 88.159.13.216 88.159.13.217 88.159.13.218 88.159.13.219 88.159.13.220 88.159.13.221 88.159.13.222 88.159.13.223 88.159.13.224 88.159.13.225 88.159.13.226 88.159.13.227 88.159.13.228 88.159.13.229 88.159.13.230 88.159.13.231 88.159.13.232 88.159.13.233 88.159.13.234 88.159.13.235 88.159.13.236 88.159.13.237 88.159.13.238 88.159.13.239 88.159.13.240 88.159.13.241 88.159.13.242 88.159.13.243 88.159.13.244 88.159.13.245 88.159.13.246 88.159.13.247 88.159.13.248 88.159.13.249 88.159.13.250 88.159.13.251 Top Norway 193.90.147.0 193.90.147.1 193.90.147.2 193.90.147.3 193.90.147.4 193.90.147.5 193.90.147.6 193.90.147.7 193.90.147.12 193.90.147.13 193.90.147.14 193.90.147.15 193.90.147.16 193.90.147.17 193.90.147.18 193.90.147.19 193.90.147.20 193.90.147.21 193.90.147.22 193.90.147.23 193.90.147.24 193.90.147.25 193.90.147.26 193.90.147.27 193.90.147.28 193.90.147.29 193.90.147.30 193.90.147.31 193.90.147.32 193.90.147.33 193.90.147.34 193.90.147.35 193.90.147.36 193.90.147.37 193.90.147.38 193.90.147.39 193.90.147.40 193.90.147.41 193.90.147.42 193.90.147.43 193.90.147.44 193.90.147.45 193.90.147.46 193.90.147.47 193.90.147.48 193.90.147.49 193.90.147.50 193.90.147.51 193.90.147.52 193.90.147.53 193.90.147.54 193.90.147.55 193.90.147.56 193.90.147.57 193.90.147.58 193.90.147.59 193.90.147.76 193.90.147.77 193.90.147.78 193.90.147.79 193.90.147.80 193.90.147.81 193.90.147.82 193.90.147.83 193.90.147.84 193.90.147.85 193.90.147.86 193.90.147.87 193.90.147.88 193.90.147.89 193.90.147.90 193.90.147.91 193.90.147.92 193.90.147.93 193.90.147.94 193.90.147.95 193.90.147.96 193.90.147.97 193.90.147.98 193.90.147.99 193.90.147.100 193.90.147.101 193.90.147.102 193.90.147.103 193.90.147.104 193.90.147.105 193.90.147.106 193.90.147.107 193.90.147.108 193.90.147.109 193.90.147.110 193.90.147.111 193.90.147.112 193.90.147.113 193.90.147.114 193.90.147.115 193.90.147.116 193.90.147.117 193.90.147.118 193.90.147.119 193.90.147.120 193.90.147.121 193.90.147.122 193.90.147.123 Top Philippines 103.25.178.4 103.25.178.5 103.25.178.6 103.25.178.12 103.25.178.13 103.25.178.14 103.25.178.15 103.25.178.16 103.25.178.17 103.25.178.18 103.25.178.19 103.25.178.20 103.25.178.21 103.25.178.22 103.25.178.23 103.25.178.24 103.25.178.25 103.25.178.26 103.25.178.27 103.25.178.28 103.25.178.29 103.25.178.30 103.25.178.31 103.25.178.32 103.25.178.33 103.25.178.34 103.25.178.35 103.25.178.36 103.25.178.37 103.25.178.38 103.25.178.39 103.25.178.40 103.25.178.41 103.25.178.42 103.25.178.43 103.25.178.44 103.25.178.45 103.25.178.46 103.25.178.47 103.25.178.48 103.25.178.49 103.25.178.50 103.25.178.51 103.25.178.52 103.25.178.53 103.25.178.54 103.25.178.55 103.25.178.56 103.25.178.57 103.25.178.58 103.25.178.59 Top Russia 178.45.251.4 178.45.251.5 178.45.251.6 178.45.251.7 178.45.251.8 178.45.251.9 178.45.251.10 178.45.251.11 178.45.251.12 178.45.251.13 178.45.251.14 178.45.251.15 178.45.251.16 178.45.251.17 178.45.251.18 178.45.251.19 178.45.251.20 178.45.251.21 178.45.251.22 178.45.251.23 178.45.251.24 178.45.251.25 178.45.251.26 178.45.251.27 178.45.251.28 178.45.251.29 178.45.251.30 178.45.251.31 178.45.251.32 178.45.251.33 178.45.251.34 178.45.251.35 178.45.251.36 178.45.251.37 178.45.251.38 178.45.251.39 178.45.251.40 178.45.251.41 178.45.251.42 178.45.251.43 178.45.251.44 178.45.251.45 178.45.251.46 178.45.251.47 178.45.251.48 178.45.251.49 178.45.251.50 178.45.251.51 178.45.251.52 178.45.251.53 178.45.251.54 178.45.251.55 178.45.251.56 178.45.251.57 178.45.251.58 178.45.251.59 178.45.251.60 178.45.251.61 178.45.251.62 178.45.251.63 178.45.251.64 178.45.251.65 178.45.251.66 178.45.251.67 178.45.251.68 178.45.251.69 178.45.251.70 178.45.251.71 178.45.251.72 178.45.251.73 178.45.251.74 178.45.251.75 178.45.251.76 178.45.251.77 178.45.251.78 178.45.251.79 178.45.251.80 178.45.251.81 178.45.251.82 178.45.251.83 178.45.251.84 178.45.251.85 178.45.251.86 178.45.251.87 178.45.251.88 178.45.251.89 178.45.251.90 178.45.251.91 178.45.251.92 178.45.251.93 178.45.251.94 178.45.251.95 178.45.251.96 178.45.251.97 178.45.251.98 178.45.251.99 178.45.251.100 178.45.251.101 178.45.251.102 178.45.251.103 178.45.251.104 178.45.251.105 178.45.251.106 178.45.251.107 178.45.251.108 178.45.251.109 178.45.251.110 178.45.251.111 178.45.251.112 178.45.251.113 178.45.251.114 178.45.251.115 178.45.251.116 178.45.251.117 178.45.251.118 178.45.251.119 178.45.251.120 178.45.251.121 178.45.251.122 178.45.251.123 Top Saudi Arabia 84.235.77.1 84.235.77.2 84.235.77.3 84.235.77.4 84.235.77.5 84.235.77.6 84.235.77.7 84.235.77.8 84.235.77.9 84.235.77.10 84.235.77.11 84.235.77.12 84.235.77.13 84.235.77.14 84.235.77.15 84.235.77.16 84.235.77.17 84.235.77.18 84.235.77.19 84.235.77.20 84.235.77.21 84.235.77.22 84.235.77.23 84.235.77.24 84.235.77.25 84.235.77.26 84.235.77.27 84.235.77.28 84.235.77.29 84.235.77.30 84.235.77.31 84.235.77.32 84.235.77.33 84.235.77.34 84.235.77.35 84.235.77.36 84.235.77.37 84.235.77.38 84.235.77.39 84.235.77.40 84.235.77.41 84.235.77.42 84.235.77.43 84.235.77.44 84.235.77.45 84.235.77.46 84.235.77.47 84.235.77.48 84.235.77.49 84.235.77.50 84.235.77.51 84.235.77.52 84.235.77.53 84.235.77.54 84.235.77.55 84.235.77.56 84.235.77.57 84.235.77.58 84.235.77.59 84.235.77.60 84.235.77.61 84.235.77.62 84.235.77.63 84.235.77.64 84.235.77.65 84.235.77.66 84.235.77.67 84.235.77.68 84.235.77.69 84.235.77.70 84.235.77.71 84.235.77.72 84.235.77.73 84.235.77.74 84.235.77.75 84.235.77.76 84.235.77.77 84.235.77.78 84.235.77.79 84.235.77.80 84.235.77.81 84.235.77.82 84.235.77.83 84.235.77.84 84.235.77.85 84.235.77.86 84.235.77.87 84.235.77.88 84.235.77.89 84.235.77.90 84.235.77.91 84.235.77.92 84.235.77.93 84.235.77.94 84.235.77.95 84.235.77.96 84.235.77.97 84.235.77.98 84.235.77.99 84.235.77.100 84.235.77.101 84.235.77.102 84.235.77.103 84.235.77.104 84.235.77.105 84.235.77.106 84.235.77.107 84.235.77.108 84.235.77.109 84.235.77.110 84.235.77.111 84.235.77.112 84.235.77.113 84.235.77.114 84.235.77.115 84.235.77.116 84.235.77.117 84.235.77.118 84.235.77.119 84.235.77.120 84.235.77.121 84.235.77.122 84.235.77.123 84.235.77.124 84.235.77.125 84.235.77.126 84.235.77.127 84.235.77.128 84.235.77.129 84.235.77.130 84.235.77.131 84.235.77.132 84.235.77.133 84.235.77.134 84.235.77.135 84.235.77.136 84.235.77.137 84.235.77.138 84.235.77.139 84.235.77.140 84.235.77.141 84.235.77.142 84.235.77.143 84.235.77.144 84.235.77.145 84.235.77.146 84.235.77.147 84.235.77.148 84.235.77.149 84.235.77.150 84.235.77.151 84.235.77.152 84.235.77.153 84.235.77.154 84.235.77.155 84.235.77.156 84.235.77.157 84.235.77.158 84.235.77.159 84.235.77.160 84.235.77.161 84.235.77.162 84.235.77.163 84.235.77.164 84.235.77.165 84.235.77.166 84.235.77.167 84.235.77.168 84.235.77.169 84.235.77.170 84.235.77.171 84.235.77.172 84.235.77.173 84.235.77.174 84.235.77.175 84.235.77.176 84.235.77.177 84.235.77.178 84.235.77.179 84.235.77.180 84.235.77.181 84.235.77.182 84.235.77.183 84.235.77.184 84.235.77.185 84.235.77.186 84.235.77.187 84.235.77.188 84.235.77.189 84.235.77.190 84.235.77.191 84.235.77.192 84.235.77.193 84.235.77.194 84.235.77.195 84.235.77.196 84.235.77.197 84.235.77.198 84.235.77.199 84.235.77.200 84.235.77.201 84.235.77.202 84.235.77.203 84.235.77.204 84.235.77.205 84.235.77.206 84.235.77.207 84.235.77.208 84.235.77.209 84.235.77.210 84.235.77.211 84.235.77.212 84.235.77.213 84.235.77.214 84.235.77.215 84.235.77.216 84.235.77.217 84.235.77.218 84.235.77.219 84.235.77.220 84.235.77.221 84.235.77.222 84.235.77.223 84.235.77.224 84.235.77.225 84.235.77.226 84.235.77.227 84.235.77.228 84.235.77.229 84.235.77.230 84.235.77.231 84.235.77.232 84.235.77.233 84.235.77.234 84.235.77.235 84.235.77.236 84.235.77.237 84.235.77.238 84.235.77.239 84.235.77.240 84.235.77.241 84.235.77.242 84.235.77.243 84.235.77.244 84.235.77.245 84.235.77.246 84.235.77.247 84.235.77.248 84.235.77.249 84.235.77.250 84.235.77.251 Top Serbia 213.240.44.5 213.240.44.6 213.240.44.7 213.240.44.8 213.240.44.9 213.240.44.10 213.240.44.11 213.240.44.12 213.240.44.13 213.240.44.14 213.240.44.15 213.240.44.16 213.240.44.17 213.240.44.18 213.240.44.19 213.240.44.20 213.240.44.21 213.240.44.22 213.240.44.23 213.240.44.24 213.240.44.25 213.240.44.26 213.240.44.27 Top Singapore 203.116.165.129 203.116.165.130 203.116.165.131 203.116.165.132 203.116.165.133 203.116.165.134 203.116.165.135 203.116.165.136 203.116.165.137 203.116.165.138 203.116.165.139 203.116.165.140 203.116.165.141 203.116.165.142 203.116.165.143 203.116.165.144 203.116.165.145 203.116.165.146 203.116.165.147 203.116.165.148 203.116.165.149 203.116.165.150 203.116.165.151 203.116.165.152 203.116.165.153 203.116.165.154 203.116.165.155 203.116.165.156 203.116.165.157 203.116.165.158 203.116.165.159 203.116.165.160 203.116.165.161 203.116.165.162 203.116.165.163 203.116.165.164 203.116.165.165 203.116.165.166 203.116.165.167 203.116.165.168 203.116.165.169 203.116.165.170 203.116.165.171 203.116.165.172 203.116.165.173 203.116.165.174 203.116.165.175 203.116.165.176 203.116.165.177 203.116.165.178 203.116.165.179 203.116.165.180 203.116.165.181 203.116.165.182 203.116.165.183 203.116.165.184 203.116.165.185 203.116.165.186 203.116.165.187 203.116.165.188 203.116.165.189 203.116.165.190 203.116.165.191 203.116.165.192 203.116.165.193 203.116.165.194 203.116.165.195 203.116.165.196 203.116.165.197 203.116.165.198 203.116.165.199 203.116.165.200 203.116.165.201 203.116.165.202 203.116.165.203 203.116.165.204 203.116.165.205 203.116.165.206 203.116.165.207 203.116.165.208 203.116.165.209 203.116.165.210 203.116.165.211 203.116.165.212 203.116.165.213 203.116.165.214 203.116.165.215 203.116.165.216 203.116.165.217 203.116.165.218 203.116.165.219 203.116.165.220 203.116.165.221 203.116.165.222 203.116.165.223 203.116.165.224 203.116.165.225 203.116.165.226 203.116.165.227 203.116.165.228 203.116.165.229 203.116.165.230 203.116.165.231 203.116.165.232 203.116.165.233 203.116.165.234 203.116.165.235 203.116.165.236 203.116.165.237 203.116.165.238 203.116.165.239 203.116.165.240 203.116.165.241 203.116.165.242 203.116.165.243 203.116.165.244 203.116.165.245 203.116.165.246 203.116.165.247 203.116.165.248 203.116.165.249 203.116.165.250 203.116.165.251 203.116.165.252 203.116.165.253 203.116.165.254 203.116.165.255 Top Singapore 203.117.34.132 203.117.34.133 203.117.34.134 203.117.34.135 203.117.34.136 203.117.34.137 203.117.34.138 203.117.34.139 203.117.34.140 203.117.34.141 203.117.34.142 203.117.34.143 203.117.34.144 203.117.34.145 203.117.34.146 203.117.34.147 203.117.34.148 203.117.34.149 203.117.34.150 203.117.34.151 203.117.34.152 203.117.34.153 203.117.34.154 203.117.34.155 203.117.34.156 203.117.34.157 203.117.34.158 203.117.34.159 203.117.34.160 203.117.34.161 203.117.34.162 203.117.34.163 203.117.34.164 203.117.34.165 203.117.34.166 203.117.34.167 203.117.34.168 203.117.34.169 203.117.34.170 203.117.34.171 203.117.34.172 203.117.34.173 203.117.34.174 203.117.34.175 203.117.34.176 203.117.34.177 203.117.34.178 203.117.34.179 203.117.34.180 203.117.34.181 203.117.34.182 203.117.34.183 203.117.34.184 203.117.34.185 203.117.34.186 203.117.34.187 Top Slovakia 62.197.198.193 62.197.198.194 62.197.198.195 62.197.198.196 62.197.198.197 62.197.198.198 62.197.198.199 62.197.198.200 62.197.198.201 62.197.198.202 62.197.198.203 62.197.198.204 62.197.198.205 62.197.198.206 62.197.198.207 62.197.198.208 62.197.198.209 62.197.198.210 62.197.198.211 62.197.198.212 62.197.198.213 62.197.198.214 62.197.198.215 62.197.198.216 62.197.198.217 62.197.198.218 62.197.198.219 62.197.198.220 62.197.198.221 62.197.198.222 62.197.198.223 62.197.198.224 62.197.198.225 62.197.198.226 62.197.198.227 62.197.198.228 62.197.198.229 62.197.198.230 62.197.198.231 62.197.198.232 62.197.198.233 62.197.198.234 62.197.198.235 62.197.198.236 62.197.198.237 62.197.198.238 62.197.198.239 62.197.198.240 62.197.198.241 62.197.198.242 62.197.198.243 62.197.198.244 62.197.198.245 62.197.198.246 62.197.198.247 62.197.198.248 62.197.198.249 62.197.198.250 62.197.198.251 Top Slovakia 87.244.198.161 87.244.198.162 87.244.198.163 87.244.198.164 87.244.198.165 87.244.198.166 87.244.198.167 87.244.198.168 87.244.198.169 87.244.198.170 87.244.198.171 87.244.198.172 87.244.198.173 87.244.198.174 87.244.198.175 87.244.198.176 87.244.198.177 87.244.198.178 87.244.198.179 87.244.198.180 87.244.198.181 87.244.198.182 87.244.198.183 87.244.198.184 87.244.198.185 87.244.198.186 87.244.198.187 Top Taiwan 123.205.250.68 123.205.250.69 123.205.250.70 123.205.250.71 123.205.250.72 123.205.250.73 123.205.250.74 123.205.250.75 123.205.250.76 123.205.250.77 123.205.250.78 123.205.250.79 123.205.250.80 123.205.250.81 123.205.250.82 123.205.250.83 123.205.250.84 123.205.250.85 123.205.250.86 123.205.250.87 123.205.250.88 123.205.250.89 123.205.250.90 123.205.250.91 123.205.250.92 123.205.250.93 123.205.250.94 123.205.250.95 123.205.250.96 123.205.250.97 123.205.250.98 123.205.250.99 123.205.250.100 123.205.250.101 123.205.250.102 123.205.250.103 123.205.250.104 123.205.250.105 123.205.250.106 123.205.250.107 123.205.250.108 123.205.250.109 123.205.250.110 123.205.250.111 123.205.250.112 123.205.250.113 123.205.250.114 123.205.250.115 123.205.250.116 123.205.250.117 123.205.250.118 123.205.250.119 123.205.250.120 123.205.250.121 123.205.250.122 123.205.250.123 123.205.250.124 123.205.250.125 123.205.250.126 123.205.250.127 123.205.250.128 123.205.250.129 123.205.250.130 123.205.250.131 123.205.250.132 123.205.250.133 123.205.250.134 123.205.250.135 123.205.250.136 123.205.250.137 123.205.250.138 123.205.250.139 123.205.250.140 123.205.250.141 123.205.250.142 123.205.250.143 123.205.250.144 123.205.250.145 123.205.250.146 123.205.250.147 123.205.250.148 123.205.250.149 123.205.250.150 123.205.250.151 123.205.250.152 123.205.250.153 123.205.250.154 123.205.250.155 123.205.250.156 123.205.250.157 123.205.250.158 123.205.250.159 123.205.250.160 123.205.250.161 123.205.250.162 123.205.250.163 123.205.250.164 123.205.250.165 123.205.250.166 123.205.250.167 123.205.250.168 123.205.250.169 123.205.250.170 123.205.250.171 123.205.250.172 123.205.250.173 123.205.250.174 123.205.250.175 123.205.250.176 123.205.250.177 123.205.250.178 123.205.250.179 123.205.250.180 123.205.250.181 123.205.250.182 123.205.250.183 123.205.250.184 123.205.250.185 123.205.250.186 123.205.250.187 123.205.250.188 123.205.250.189 123.205.250.190 Top Taiwan 123.205.251.68 123.205.251.69 123.205.251.70 123.205.251.71 123.205.251.72 123.205.251.73 123.205.251.74 123.205.251.75 123.205.251.76 123.205.251.77 123.205.251.78 123.205.251.79 123.205.251.80 123.205.251.81 123.205.251.82 123.205.251.83 123.205.251.84 123.205.251.85 123.205.251.86 123.205.251.87 123.205.251.88 123.205.251.89 123.205.251.90 123.205.251.91 123.205.251.92 123.205.251.93 123.205.251.94 123.205.251.95 123.205.251.96 123.205.251.97 123.205.251.98 123.205.251.99 123.205.251.100 123.205.251.101 123.205.251.102 123.205.251.103 123.205.251.104 123.205.251.105 123.205.251.106 123.205.251.107 123.205.251.108 123.205.251.109 123.205.251.110 123.205.251.111 123.205.251.112 123.205.251.113 123.205.251.114 123.205.251.115 123.205.251.116 123.205.251.117 123.205.251.118 123.205.251.119 123.205.251.120 123.205.251.121 123.205.251.122 123.205.251.123 Top Taiwan 163.28.116.1 163.28.116.2 163.28.116.3 163.28.116.4 163.28.116.5 163.28.116.6 163.28.116.7 163.28.116.8 163.28.116.9 163.28.116.10 163.28.116.11 163.28.116.12 163.28.116.13 163.28.116.14 163.28.116.15 163.28.116.16 163.28.116.17 163.28.116.18 163.28.116.19 163.28.116.20 163.28.116.21 163.28.116.22 163.28.116.23 163.28.116.24 163.28.116.25 163.28.116.26 163.28.116.27 163.28.116.28 163.28.116.29 163.28.116.30 163.28.116.31 163.28.116.32 163.28.116.33 163.28.116.34 163.28.116.35 163.28.116.36 163.28.116.37 163.28.116.38 163.28.116.39 163.28.116.40 163.28.116.41 163.28.116.42 163.28.116.43 163.28.116.44 163.28.116.45 163.28.116.46 163.28.116.47 163.28.116.48 163.28.116.49 163.28.116.50 163.28.116.51 163.28.116.52 163.28.116.53 163.28.116.54 163.28.116.55 163.28.116.56 163.28.116.57 163.28.116.58 163.28.116.59 Top Taiwan 163.28.83.143 163.28.83.144 163.28.83.145 163.28.83.146 163.28.83.147 163.28.83.148 163.28.83.149 163.28.83.150 163.28.83.151 163.28.83.152 163.28.83.153 163.28.83.154 163.28.83.155 163.28.83.156 163.28.83.157 163.28.83.158 163.28.83.159 163.28.83.160 163.28.83.161 163.28.83.162 163.28.83.163 163.28.83.164 163.28.83.165 163.28.83.166 163.28.83.167 163.28.83.168 163.28.83.169 163.28.83.170 163.28.83.171 163.28.83.172 163.28.83.173 163.28.83.174 163.28.83.175 163.28.83.176 163.28.83.177 163.28.83.178 163.28.83.179 163.28.83.180 163.28.83.181 163.28.83.182 163.28.83.183 163.28.83.184 163.28.83.185 163.28.83.186 163.28.83.187 Top Taiwan 202.39.143.1 202.39.143.2 202.39.143.3 202.39.143.4 202.39.143.5 202.39.143.6 202.39.143.7 202.39.143.8 202.39.143.9 202.39.143.10 202.39.143.11 202.39.143.12 202.39.143.13 202.39.143.14 202.39.143.15 202.39.143.16 202.39.143.17 202.39.143.18 202.39.143.19 202.39.143.20 202.39.143.21 202.39.143.22 202.39.143.23 202.39.143.24 202.39.143.25 202.39.143.26 202.39.143.27 202.39.143.28 202.39.143.29 202.39.143.30 202.39.143.31 202.39.143.32 202.39.143.33 202.39.143.34 202.39.143.35 202.39.143.36 202.39.143.37 202.39.143.38 202.39.143.39 202.39.143.40 202.39.143.41 202.39.143.42 202.39.143.43 202.39.143.44 202.39.143.45 202.39.143.46 202.39.143.47 202.39.143.48 202.39.143.49 202.39.143.50 202.39.143.51 202.39.143.52 202.39.143.53 202.39.143.54 202.39.143.55 202.39.143.56 202.39.143.57 202.39.143.58 202.39.143.59 202.39.143.60 202.39.143.61 202.39.143.62 202.39.143.63 202.39.143.64 202.39.143.65 202.39.143.66 202.39.143.67 202.39.143.68 202.39.143.69 202.39.143.70 202.39.143.71 202.39.143.72 202.39.143.73 202.39.143.74 202.39.143.75 202.39.143.76 202.39.143.77 202.39.143.78 202.39.143.79 202.39.143.80 202.39.143.81 202.39.143.82 202.39.143.83 202.39.143.84 202.39.143.85 202.39.143.86 202.39.143.87 202.39.143.88 202.39.143.89 202.39.143.90 202.39.143.91 202.39.143.92 202.39.143.93 202.39.143.94 202.39.143.95 202.39.143.96 202.39.143.97 202.39.143.98 202.39.143.99 202.39.143.100 202.39.143.101 202.39.143.102 202.39.143.103 202.39.143.104 202.39.143.105 202.39.143.106 202.39.143.107 202.39.143.108 202.39.143.109 202.39.143.110 202.39.143.111 202.39.143.112 202.39.143.113 202.39.143.114 202.39.143.115 202.39.143.116 202.39.143.117 202.39.143.118 202.39.143.119 202.39.143.120 202.39.143.121 202.39.143.122 202.39.143.123 Top Taiwan 203.211.0.4 203.211.0.5 203.211.0.6 203.211.0.7 203.211.0.8 203.211.0.9 203.211.0.10 203.211.0.11 203.211.0.12 203.211.0.13 203.211.0.14 203.211.0.15 203.211.0.16 203.211.0.17 203.211.0.18 203.211.0.19 203.211.0.20 203.211.0.21 203.211.0.22 203.211.0.23 203.211.0.24 203.211.0.25 203.211.0.26 203.211.0.27 203.211.0.28 203.211.0.29 203.211.0.30 203.211.0.31 203.211.0.32 203.211.0.33 203.211.0.34 203.211.0.35 203.211.0.36 203.211.0.37 203.211.0.38 203.211.0.39 203.211.0.40 203.211.0.41 203.211.0.42 203.211.0.43 203.211.0.44 203.211.0.45 203.211.0.46 203.211.0.47 203.211.0.48 203.211.0.49 203.211.0.50 203.211.0.51 203.211.0.52 203.211.0.53 203.211.0.54 203.211.0.55 203.211.0.56 203.211.0.57 203.211.0.58 203.211.0.59 Top Taiwan 203.66.124.129 203.66.124.130 203.66.124.131 203.66.124.132 203.66.124.133 203.66.124.134 203.66.124.135 203.66.124.136 203.66.124.137 203.66.124.138 203.66.124.139 203.66.124.140 203.66.124.141 203.66.124.142 203.66.124.143 203.66.124.144 203.66.124.145 203.66.124.146 203.66.124.147 203.66.124.148 203.66.124.149 203.66.124.150 203.66.124.151 203.66.124.152 203.66.124.153 203.66.124.154 203.66.124.155 203.66.124.156 203.66.124.157 203.66.124.158 203.66.124.159 203.66.124.160 203.66.124.161 203.66.124.162 203.66.124.163 203.66.124.164 203.66.124.165 203.66.124.166 203.66.124.167 203.66.124.168 203.66.124.169 203.66.124.170 203.66.124.171 203.66.124.172 203.66.124.173 203.66.124.174 203.66.124.175 203.66.124.176 203.66.124.177 203.66.124.178 203.66.124.179 203.66.124.180 203.66.124.181 203.66.124.182 203.66.124.183 203.66.124.184 203.66.124.185 203.66.124.186 203.66.124.187 203.66.124.188 203.66.124.189 203.66.124.190 203.66.124.191 203.66.124.192 203.66.124.193 203.66.124.194 203.66.124.195 203.66.124.196 203.66.124.197 203.66.124.198 203.66.124.199 203.66.124.200 203.66.124.201 203.66.124.202 203.66.124.203 203.66.124.204 203.66.124.205 203.66.124.206 203.66.124.207 203.66.124.208 203.66.124.209 203.66.124.210 203.66.124.211 203.66.124.212 203.66.124.213 203.66.124.214 203.66.124.215 203.66.124.216 203.66.124.217 203.66.124.218 203.66.124.219 203.66.124.220 203.66.124.221 203.66.124.222 203.66.124.223 203.66.124.224 203.66.124.225 203.66.124.226 203.66.124.227 203.66.124.228 203.66.124.229 203.66.124.230 203.66.124.231 203.66.124.232 203.66.124.233 203.66.124.234 203.66.124.235 203.66.124.236 203.66.124.237 203.66.124.238 203.66.124.239 203.66.124.240 203.66.124.241 203.66.124.242 203.66.124.243 203.66.124.244 203.66.124.245 203.66.124.246 203.66.124.247 203.66.124.248 203.66.124.249 203.66.124.250 203.66.124.251 Top Taiwan 210.61.221.65 210.61.221.66 210.61.221.67 210.61.221.68 210.61.221.69 210.61.221.70 210.61.221.71 210.61.221.72 210.61.221.73 210.61.221.74 210.61.221.75 210.61.221.76 210.61.221.77 210.61.221.78 210.61.221.79 210.61.221.80 210.61.221.81 210.61.221.82 210.61.221.83 210.61.221.84 210.61.221.85 210.61.221.86 210.61.221.87 210.61.221.88 210.61.221.89 210.61.221.90 210.61.221.91 210.61.221.92 210.61.221.93 210.61.221.94 210.61.221.95 210.61.221.96 210.61.221.97 210.61.221.98 210.61.221.99 210.61.221.100 210.61.221.101 210.61.221.102 210.61.221.103 210.61.221.104 210.61.221.105 210.61.221.106 210.61.221.107 210.61.221.108 210.61.221.109 210.61.221.110 210.61.221.111 210.61.221.112 210.61.221.113 210.61.221.114 210.61.221.115 210.61.221.116 210.61.221.117 210.61.221.118 210.61.221.119 210.61.221.120 210.61.221.121 210.61.221.122 210.61.221.123 210.61.221.124 210.61.221.125 210.61.221.126 210.61.221.127 210.61.221.128 210.61.221.129 210.61.221.130 210.61.221.131 210.61.221.132 210.61.221.133 210.61.221.134 210.61.221.135 210.61.221.136 210.61.221.137 210.61.221.138 210.61.221.139 210.61.221.140 210.61.221.141 210.61.221.142 210.61.221.143 210.61.221.144 210.61.221.145 210.61.221.146 210.61.221.147 210.61.221.148 210.61.221.149 210.61.221.150 210.61.221.151 210.61.221.152 210.61.221.153 210.61.221.154 210.61.221.155 210.61.221.156 210.61.221.157 210.61.221.158 210.61.221.159 210.61.221.160 210.61.221.161 210.61.221.162 210.61.221.163 210.61.221.164 210.61.221.165 210.61.221.166 210.61.221.167 210.61.221.168 210.61.221.169 210.61.221.170 210.61.221.171 210.61.221.172 210.61.221.173 210.61.221.174 210.61.221.175 210.61.221.176 210.61.221.177 210.61.221.178 210.61.221.179 210.61.221.180 210.61.221.181 210.61.221.182 210.61.221.183 210.61.221.184 210.61.221.185 210.61.221.186 210.61.221.187 Top Taiwan 60.199.175.1 60.199.175.2 60.199.175.3 60.199.175.4 60.199.175.5 60.199.175.6 60.199.175.7 60.199.175.8 60.199.175.9 60.199.175.10 60.199.175.11 60.199.175.12 60.199.175.13 60.199.175.14 60.199.175.15 60.199.175.16 60.199.175.17 60.199.175.18 60.199.175.19 60.199.175.20 60.199.175.21 60.199.175.22 60.199.175.23 60.199.175.24 60.199.175.25 60.199.175.26 60.199.175.27 60.199.175.28 60.199.175.29 60.199.175.30 60.199.175.31 60.199.175.32 60.199.175.33 60.199.175.34 60.199.175.35 60.199.175.36 60.199.175.37 60.199.175.38 60.199.175.39 60.199.175.40 60.199.175.41 60.199.175.42 60.199.175.43 60.199.175.44 60.199.175.45 60.199.175.46 60.199.175.47 60.199.175.48 60.199.175.49 60.199.175.50 60.199.175.51 60.199.175.52 60.199.175.53 60.199.175.54 60.199.175.55 60.199.175.56 60.199.175.57 60.199.175.58 60.199.175.59 60.199.175.60 60.199.175.61 60.199.175.62 60.199.175.63 60.199.175.64 60.199.175.65 60.199.175.66 60.199.175.67 60.199.175.68 60.199.175.69 60.199.175.70 60.199.175.71 60.199.175.72 60.199.175.73 60.199.175.74 60.199.175.75 60.199.175.76 60.199.175.77 60.199.175.78 60.199.175.79 60.199.175.80 60.199.175.81 60.199.175.82 60.199.175.83 60.199.175.84 60.199.175.85 60.199.175.86 60.199.175.87 60.199.175.88 60.199.175.89 60.199.175.90 60.199.175.91 60.199.175.92 60.199.175.93 60.199.175.94 60.199.175.95 60.199.175.96 60.199.175.97 60.199.175.98 60.199.175.99 60.199.175.100 60.199.175.101 60.199.175.102 60.199.175.103 60.199.175.104 60.199.175.105 60.199.175.106 60.199.175.107 60.199.175.108 60.199.175.109 60.199.175.110 60.199.175.111 60.199.175.112 60.199.175.113 60.199.175.114 60.199.175.115 60.199.175.116 60.199.175.117 60.199.175.118 60.199.175.119 60.199.175.120 60.199.175.121 60.199.175.122 60.199.175.123 60.199.175.124 60.199.175.125 60.199.175.126 60.199.175.127 60.199.175.128 60.199.175.129 60.199.175.130 60.199.175.131 60.199.175.132 60.199.175.133 60.199.175.134 60.199.175.135 60.199.175.136 60.199.175.137 60.199.175.138 60.199.175.139 60.199.175.140 60.199.175.141 60.199.175.142 60.199.175.143 60.199.175.144 60.199.175.145 60.199.175.146 60.199.175.147 60.199.175.148 60.199.175.149 60.199.175.150 60.199.175.151 60.199.175.152 60.199.175.153 60.199.175.154 60.199.175.155 60.199.175.156 60.199.175.157 60.199.175.158 60.199.175.159 60.199.175.160 60.199.175.161 60.199.175.162 60.199.175.163 60.199.175.164 60.199.175.165 60.199.175.166 60.199.175.167 60.199.175.168 60.199.175.169 60.199.175.170 60.199.175.171 60.199.175.172 60.199.175.173 60.199.175.174 60.199.175.175 60.199.175.176 60.199.175.177 60.199.175.178 60.199.175.179 60.199.175.180 60.199.175.181 60.199.175.182 60.199.175.183 60.199.175.184 60.199.175.185 60.199.175.186 60.199.175.187 Top Taiwan 61.219.131.65 61.219.131.66 61.219.131.67 61.219.131.68 61.219.131.69 61.219.131.70 61.219.131.71 61.219.131.72 61.219.131.73 61.219.131.74 61.219.131.75 61.219.131.76 61.219.131.77 61.219.131.78 61.219.131.79 61.219.131.80 61.219.131.81 61.219.131.82 61.219.131.83 61.219.131.84 61.219.131.85 61.219.131.86 61.219.131.87 61.219.131.88 61.219.131.89 61.219.131.90 61.219.131.91 61.219.131.92 61.219.131.93 61.219.131.94 61.219.131.95 61.219.131.96 61.219.131.97 61.219.131.98 61.219.131.99 61.219.131.100 61.219.131.101 61.219.131.102 61.219.131.103 61.219.131.104 61.219.131.105 61.219.131.106 61.219.131.107 61.219.131.108 61.219.131.109 61.219.131.110 61.219.131.111 61.219.131.112 61.219.131.113 61.219.131.114 61.219.131.115 61.219.131.116 61.219.131.117 61.219.131.118 61.219.131.119 61.219.131.120 61.219.131.121 61.219.131.122 61.219.131.123 61.219.131.193 61.219.131.194 61.219.131.195 61.219.131.196 61.219.131.197 61.219.131.198 61.219.131.199 61.219.131.200 61.219.131.201 61.219.131.202 61.219.131.203 61.219.131.204 61.219.131.205 61.219.131.206 61.219.131.207 61.219.131.208 61.219.131.209 61.219.131.210 61.219.131.211 61.219.131.212 61.219.131.213 61.219.131.214 61.219.131.215 61.219.131.216 61.219.131.217 61.219.131.218 61.219.131.219 61.219.131.220 61.219.131.221 61.219.131.222 61.219.131.223 61.219.131.224 61.219.131.225 61.219.131.226 61.219.131.227 61.219.131.228 61.219.131.229 61.219.131.230 61.219.131.231 61.219.131.232 61.219.131.233 61.219.131.234 61.219.131.235 61.219.131.236 61.219.131.237 61.219.131.238 61.219.131.239 61.219.131.240 61.219.131.241 61.219.131.242 61.219.131.243 61.219.131.244 61.219.131.245 61.219.131.246 61.219.131.247 61.219.131.248 61.219.131.249 61.219.131.250 61.219.131.251 Top Thailand 1.179.248.4 1.179.248.5 1.179.248.6 1.179.248.7 1.179.248.8 1.179.248.9 1.179.248.10 1.179.248.11 1.179.248.12 1.179.248.13 1.179.248.14 1.179.248.15 1.179.248.16 1.179.248.17 1.179.248.18 1.179.248.19 1.179.248.20 1.179.248.21 1.179.248.22 1.179.248.23 1.179.248.24 1.179.248.25 1.179.248.26 1.179.248.27 1.179.248.28 1.179.248.29 1.179.248.30 1.179.248.31 1.179.248.32 1.179.248.33 1.179.248.34 1.179.248.35 1.179.248.36 1.179.248.37 1.179.248.38 1.179.248.39 1.179.248.40 1.179.248.41 1.179.248.42 1.179.248.43 1.179.248.44 1.179.248.45 1.179.248.46 1.179.248.47 1.179.248.48 1.179.248.49 1.179.248.50 1.179.248.51 1.179.248.52 1.179.248.53 1.179.248.54 1.179.248.55 1.179.248.56 1.179.248.57 1.179.248.58 1.179.248.59 1.179.248.68 1.179.248.69 1.179.248.70 1.179.248.71 1.179.248.72 1.179.248.73 1.179.248.74 1.179.248.75 1.179.248.76 1.179.248.77 1.179.248.78 1.179.248.79 1.179.248.80 1.179.248.81 1.179.248.82 1.179.248.83 1.179.248.84 1.179.248.85 1.179.248.86 1.179.248.87 1.179.248.88 1.179.248.89 1.179.248.90 1.179.248.91 1.179.248.92 1.179.248.93 1.179.248.94 1.179.248.95 1.179.248.96 1.179.248.97 1.179.248.98 1.179.248.99 1.179.248.100 1.179.248.101 1.179.248.102 1.179.248.103 1.179.248.104 1.179.248.105 1.179.248.106 1.179.248.107 1.179.248.108 1.179.248.109 1.179.248.110 1.179.248.111 1.179.248.112 1.179.248.113 1.179.248.114 1.179.248.115 1.179.248.116 1.179.248.117 1.179.248.118 1.179.248.119 1.179.248.120 1.179.248.121 1.179.248.122 1.179.248.123 1.179.248.132 1.179.248.133 1.179.248.134 1.179.248.135 1.179.248.136 1.179.248.137 1.179.248.138 1.179.248.139 1.179.248.140 1.179.248.141 1.179.248.142 1.179.248.143 1.179.248.144 1.179.248.145 1.179.248.146 1.179.248.147 1.179.248.148 1.179.248.149 1.179.248.150 1.179.248.151 1.179.248.152 1.179.248.153 1.179.248.154 1.179.248.155 1.179.248.156 1.179.248.157 1.179.248.158 1.179.248.159 1.179.248.160 1.179.248.161 1.179.248.162 1.179.248.163 1.179.248.164 1.179.248.165 1.179.248.166 1.179.248.167 1.179.248.168 1.179.248.169 1.179.248.170 1.179.248.171 1.179.248.172 1.179.248.173 1.179.248.174 1.179.248.175 1.179.248.176 1.179.248.177 1.179.248.178 1.179.248.179 1.179.248.180 1.179.248.181 1.179.248.182 1.179.248.183 1.179.248.184 1.179.248.185 1.179.248.186 1.179.248.187 1.179.248.196 1.179.248.197 1.179.248.198 1.179.248.199 1.179.248.200 1.179.248.201 1.179.248.202 1.179.248.203 1.179.248.204 1.179.248.205 1.179.248.206 1.179.248.207 1.179.248.208 1.179.248.209 1.179.248.210 1.179.248.211 1.179.248.212 1.179.248.213 1.179.248.214 1.179.248.215 1.179.248.216 1.179.248.217 1.179.248.218 1.179.248.219 1.179.248.220 1.179.248.221 1.179.248.222 1.179.248.223 1.179.248.224 1.179.248.225 1.179.248.226 1.179.248.227 1.179.248.228 1.179.248.229 1.179.248.230 1.179.248.231 1.179.248.232 1.179.248.233 1.179.248.234 1.179.248.235 1.179.248.236 1.179.248.237 1.179.248.238 1.179.248.239 1.179.248.240 1.179.248.241 1.179.248.242 1.179.248.243 1.179.248.244 1.179.248.245 1.179.248.246 1.179.248.247 1.179.248.248 1.179.248.249 1.179.248.250 1.179.248.251 Top Thailand 1.179.249.4 1.179.249.5 1.179.249.6 1.179.249.7 1.179.249.8 1.179.249.9 1.179.249.10 1.179.249.11 1.179.249.12 1.179.249.13 1.179.249.14 1.179.249.15 1.179.249.16 1.179.249.17 1.179.249.18 1.179.249.19 1.179.249.20 1.179.249.21 1.179.249.22 1.179.249.23 1.179.249.24 1.179.249.25 1.179.249.26 1.179.249.27 1.179.249.28 1.179.249.29 1.179.249.30 1.179.249.31 1.179.249.32 1.179.249.33 1.179.249.34 1.179.249.35 1.179.249.36 1.179.249.37 1.179.249.38 1.179.249.39 1.179.249.40 1.179.249.41 1.179.249.42 1.179.249.43 1.179.249.44 1.179.249.45 1.179.249.46 1.179.249.47 1.179.249.48 1.179.249.49 1.179.249.50 1.179.249.51 1.179.249.52 1.179.249.53 1.179.249.54 1.179.249.55 1.179.249.56 1.179.249.57 1.179.249.58 1.179.249.59 1.179.249.68 1.179.249.69 1.179.249.70 1.179.249.71 1.179.249.72 1.179.249.73 1.179.249.74 1.179.249.75 1.179.249.76 1.179.249.77 1.179.249.78 1.179.249.79 1.179.249.80 1.179.249.81 1.179.249.82 1.179.249.83 1.179.249.84 1.179.249.85 1.179.249.86 1.179.249.87 1.179.249.88 1.179.249.89 1.179.249.90 1.179.249.91 1.179.249.92 1.179.249.93 1.179.249.94 1.179.249.95 1.179.249.96 1.179.249.97 1.179.249.98 1.179.249.99 1.179.249.100 1.179.249.101 1.179.249.102 1.179.249.103 1.179.249.104 1.179.249.105 1.179.249.106 1.179.249.107 1.179.249.108 1.179.249.109 1.179.249.110 1.179.249.111 1.179.249.112 1.179.249.113 1.179.249.114 1.179.249.115 1.179.249.116 1.179.249.117 1.179.249.118 1.179.249.119 1.179.249.120 1.179.249.121 1.179.249.122 1.179.249.123 1.179.249.132 1.179.249.133 1.179.249.134 1.179.249.135 1.179.249.136 1.179.249.137 1.179.249.138 1.179.249.139 1.179.249.140 1.179.249.141 1.179.249.142 1.179.249.143 1.179.249.144 1.179.249.145 1.179.249.146 1.179.249.147 1.179.249.148 1.179.249.149 1.179.249.150 1.179.249.151 1.179.249.152 1.179.249.153 1.179.249.154 1.179.249.155 1.179.249.156 1.179.249.157 1.179.249.158 1.179.249.159 1.179.249.160 1.179.249.161 1.179.249.162 1.179.249.163 1.179.249.164 1.179.249.165 1.179.249.166 1.179.249.167 1.179.249.168 1.179.249.169 1.179.249.170 1.179.249.171 1.179.249.172 1.179.249.173 1.179.249.174 1.179.249.175 1.179.249.176 1.179.249.177 1.179.249.178 1.179.249.179 1.179.249.180 1.179.249.181 1.179.249.182 1.179.249.183 1.179.249.184 1.179.249.185 1.179.249.186 1.179.249.187 1.179.249.196 1.179.249.197 1.179.249.198 1.179.249.199 1.179.249.200 1.179.249.201 1.179.249.202 1.179.249.203 1.179.249.204 1.179.249.205 1.179.249.206 1.179.249.207 1.179.249.208 1.179.249.209 1.179.249.210 1.179.249.211 1.179.249.212 1.179.249.213 1.179.249.214 1.179.249.215 1.179.249.216 1.179.249.217 1.179.249.218 1.179.249.219 1.179.249.220 1.179.249.221 1.179.249.222 1.179.249.223 1.179.249.224 1.179.249.225 1.179.249.226 1.179.249.227 1.179.249.228 1.179.249.229 1.179.249.230 1.179.249.231 1.179.249.232 1.179.249.233 1.179.249.234 1.179.249.235 1.179.249.236 1.179.249.237 1.179.249.238 1.179.249.239 1.179.249.240 1.179.249.241 1.179.249.242 1.179.249.243 1.179.249.244 1.179.249.245 1.179.249.246 1.179.249.247 1.179.249.248 1.179.249.249 1.179.249.250 1.179.249.251 Top Thailand 1.179.250.4 1.179.250.5 1.179.250.6 1.179.250.7 1.179.250.8 1.179.250.9 1.179.250.10 1.179.250.11 1.179.250.12 1.179.250.13 1.179.250.14 1.179.250.15 1.179.250.16 1.179.250.17 1.179.250.18 1.179.250.19 1.179.250.20 1.179.250.21 1.179.250.22 1.179.250.23 1.179.250.24 1.179.250.25 1.179.250.26 1.179.250.27 1.179.250.28 1.179.250.29 1.179.250.30 1.179.250.31 1.179.250.32 1.179.250.33 1.179.250.34 1.179.250.35 1.179.250.36 1.179.250.37 1.179.250.38 1.179.250.39 1.179.250.40 1.179.250.41 1.179.250.42 1.179.250.43 1.179.250.44 1.179.250.45 1.179.250.46 1.179.250.47 1.179.250.48 1.179.250.49 1.179.250.50 1.179.250.51 1.179.250.52 1.179.250.53 1.179.250.54 1.179.250.55 1.179.250.56 1.179.250.57 1.179.250.58 1.179.250.59 1.179.250.68 1.179.250.69 1.179.250.70 1.179.250.71 1.179.250.72 1.179.250.73 1.179.250.74 1.179.250.75 1.179.250.76 1.179.250.77 1.179.250.78 1.179.250.79 1.179.250.80 1.179.250.81 1.179.250.82 1.179.250.83 1.179.250.84 1.179.250.85 1.179.250.86 1.179.250.87 1.179.250.88 1.179.250.89 1.179.250.90 1.179.250.91 1.179.250.92 1.179.250.93 1.179.250.94 1.179.250.95 1.179.250.96 1.179.250.97 1.179.250.98 1.179.250.99 1.179.250.100 1.179.250.101 1.179.250.102 1.179.250.103 1.179.250.104 1.179.250.105 1.179.250.106 1.179.250.107 1.179.250.108 1.179.250.109 1.179.250.110 1.179.250.111 1.179.250.112 1.179.250.113 1.179.250.114 1.179.250.115 1.179.250.116 1.179.250.117 1.179.250.118 1.179.250.119 1.179.250.120 1.179.250.121 1.179.250.122 1.179.250.123 1.179.250.132 1.179.250.133 1.179.250.134 1.179.250.135 1.179.250.136 1.179.250.137 1.179.250.138 1.179.250.139 1.179.250.140 1.179.250.141 1.179.250.142 1.179.250.143 1.179.250.144 1.179.250.145 1.179.250.146 1.179.250.147 1.179.250.148 1.179.250.149 1.179.250.150 1.179.250.151 1.179.250.152 1.179.250.153 1.179.250.154 1.179.250.155 1.179.250.156 1.179.250.157 1.179.250.158 1.179.250.159 1.179.250.160 1.179.250.161 1.179.250.162 1.179.250.163 1.179.250.164 1.179.250.165 1.179.250.166 1.179.250.167 1.179.250.168 1.179.250.169 1.179.250.170 1.179.250.171 1.179.250.172 1.179.250.173 1.179.250.174 1.179.250.175 1.179.250.176 1.179.250.177 1.179.250.178 1.179.250.179 1.179.250.180 1.179.250.181 1.179.250.182 1.179.250.183 1.179.250.184 1.179.250.185 1.179.250.186 1.179.250.187 1.179.250.196 1.179.250.197 1.179.250.198 1.179.250.199 1.179.250.200 1.179.250.201 1.179.250.202 1.179.250.203 1.179.250.204 1.179.250.205 1.179.250.206 1.179.250.207 1.179.250.208 1.179.250.209 1.179.250.210 1.179.250.211 1.179.250.212 1.179.250.213 1.179.250.214 1.179.250.215 1.179.250.216 1.179.250.217 1.179.250.218 1.179.250.219 1.179.250.220 1.179.250.221 1.179.250.222 1.179.250.223 1.179.250.224 1.179.250.225 1.179.250.226 1.179.250.227 1.179.250.228 1.179.250.229 1.179.250.230 1.179.250.231 1.179.250.232 1.179.250.233 1.179.250.234 1.179.250.235 1.179.250.236 1.179.250.237 1.179.250.238 1.179.250.239 1.179.250.240 1.179.250.241 1.179.250.242 1.179.250.243 1.179.250.244 1.179.250.245 1.179.250.246 1.179.250.247 1.179.250.248 1.179.250.249 1.179.250.250 1.179.250.251 Top Thailand 1.179.251.4 1.179.251.5 1.179.251.6 1.179.251.7 1.179.251.8 1.179.251.9 1.179.251.10 1.179.251.11 1.179.251.12 1.179.251.13 1.179.251.14 1.179.251.15 1.179.251.16 1.179.251.17 1.179.251.18 1.179.251.19 1.179.251.20 1.179.251.21 1.179.251.22 1.179.251.23 1.179.251.24 1.179.251.25 1.179.251.26 1.179.251.27 1.179.251.28 1.179.251.29 1.179.251.30 1.179.251.31 1.179.251.32 1.179.251.33 1.179.251.34 1.179.251.35 1.179.251.36 1.179.251.37 1.179.251.38 1.179.251.39 1.179.251.40 1.179.251.41 1.179.251.42 1.179.251.43 1.179.251.44 1.179.251.45 1.179.251.46 1.179.251.47 1.179.251.48 1.179.251.49 1.179.251.50 1.179.251.51 1.179.251.52 1.179.251.53 1.179.251.54 1.179.251.55 1.179.251.56 1.179.251.57 1.179.251.58 1.179.251.59 1.179.251.68 1.179.251.69 1.179.251.70 1.179.251.71 1.179.251.72 1.179.251.73 1.179.251.74 1.179.251.75 1.179.251.76 1.179.251.77 1.179.251.78 1.179.251.79 1.179.251.80 1.179.251.81 1.179.251.82 1.179.251.83 1.179.251.84 1.179.251.85 1.179.251.86 1.179.251.87 1.179.251.88 1.179.251.89 1.179.251.90 1.179.251.91 1.179.251.92 1.179.251.93 1.179.251.94 1.179.251.95 1.179.251.96 1.179.251.97 1.179.251.98 1.179.251.99 1.179.251.100 1.179.251.101 1.179.251.102 1.179.251.103 1.179.251.104 1.179.251.105 1.179.251.106 1.179.251.107 1.179.251.108 1.179.251.109 1.179.251.110 1.179.251.111 1.179.251.112 1.179.251.113 1.179.251.114 1.179.251.115 1.179.251.116 1.179.251.117 1.179.251.118 1.179.251.119 1.179.251.120 1.179.251.121 1.179.251.122 1.179.251.123 1.179.251.140 1.179.251.141 1.179.251.142 1.179.251.143 1.179.251.144 1.179.251.145 1.179.251.146 1.179.251.147 1.179.251.148 1.179.251.149 1.179.251.150 1.179.251.151 1.179.251.152 1.179.251.153 1.179.251.154 1.179.251.155 1.179.251.156 1.179.251.157 1.179.251.158 1.179.251.159 1.179.251.160 1.179.251.161 1.179.251.162 1.179.251.163 1.179.251.164 1.179.251.165 1.179.251.166 1.179.251.167 1.179.251.168 1.179.251.169 1.179.251.170 1.179.251.171 1.179.251.172 1.179.251.173 1.179.251.174 1.179.251.175 1.179.251.176 1.179.251.177 1.179.251.178 1.179.251.179 1.179.251.180 1.179.251.181 1.179.251.182 1.179.251.183 1.179.251.184 1.179.251.185 1.179.251.186 1.179.251.187 1.179.251.196 1.179.251.197 1.179.251.198 1.179.251.199 1.179.251.200 1.179.251.201 1.179.251.202 1.179.251.203 1.179.251.204 1.179.251.205 1.179.251.206 1.179.251.207 1.179.251.208 1.179.251.209 1.179.251.210 1.179.251.211 1.179.251.212 1.179.251.213 1.179.251.214 1.179.251.215 1.179.251.216 1.179.251.217 1.179.251.218 1.179.251.219 1.179.251.220 1.179.251.221 1.179.251.222 1.179.251.223 1.179.251.224 1.179.251.225 1.179.251.226 1.179.251.227 1.179.251.228 1.179.251.229 1.179.251.230 1.179.251.231 1.179.251.232 1.179.251.233 1.179.251.234 1.179.251.235 1.179.251.236 1.179.251.237 1.179.251.238 1.179.251.239 1.179.251.240 1.179.251.241 1.179.251.242 1.179.251.243 1.179.251.244 1.179.251.245 1.179.251.246 1.179.251.247 1.179.251.248 1.179.251.249 1.179.251.250 1.179.251.251 Top Thailand 1.179.252.68 1.179.252.69 1.179.252.70 1.179.252.71 1.179.252.72 1.179.252.73 1.179.252.74 1.179.252.75 1.179.252.76 1.179.252.77 1.179.252.78 1.179.252.79 1.179.252.80 1.179.252.81 1.179.252.82 1.179.252.83 1.179.252.84 1.179.252.85 1.179.252.86 1.179.252.87 1.179.252.88 1.179.252.89 1.179.252.90 1.179.252.91 1.179.252.92 1.179.252.93 1.179.252.94 1.179.252.95 1.179.252.96 1.179.252.97 1.179.252.98 1.179.252.99 1.179.252.100 1.179.252.101 1.179.252.102 1.179.252.103 1.179.252.104 1.179.252.105 1.179.252.106 1.179.252.107 1.179.252.108 1.179.252.109 1.179.252.110 1.179.252.111 1.179.252.112 1.179.252.113 1.179.252.114 1.179.252.115 1.179.252.116 1.179.252.117 1.179.252.118 1.179.252.119 1.179.252.120 1.179.252.121 1.179.252.122 1.179.252.123 1.179.252.132 1.179.252.133 1.179.252.134 1.179.252.135 1.179.252.136 1.179.252.137 1.179.252.138 1.179.252.139 1.179.252.140 1.179.252.141 1.179.252.142 1.179.252.143 1.179.252.144 1.179.252.145 1.179.252.146 1.179.252.147 1.179.252.148 1.179.252.149 1.179.252.150 1.179.252.151 1.179.252.152 1.179.252.153 1.179.252.154 1.179.252.155 1.179.252.156 1.179.252.157 1.179.252.158 1.179.252.159 1.179.252.160 1.179.252.161 1.179.252.162 1.179.252.163 1.179.252.164 1.179.252.165 1.179.252.166 1.179.252.167 1.179.252.168 1.179.252.169 1.179.252.170 1.179.252.171 1.179.252.172 1.179.252.173 1.179.252.174 1.179.252.175 1.179.252.176 1.179.252.177 1.179.252.178 1.179.252.179 1.179.252.180 1.179.252.181 1.179.252.182 1.179.252.183 1.179.252.184 1.179.252.185 1.179.252.186 1.179.252.187 1.179.252.196 1.179.252.197 1.179.252.198 1.179.252.199 1.179.252.200 1.179.252.201 1.179.252.202 1.179.252.203 1.179.252.204 1.179.252.205 1.179.252.206 1.179.252.207 1.179.252.208 1.179.252.209 1.179.252.210 1.179.252.211 1.179.252.212 1.179.252.213 1.179.252.214 1.179.252.215 1.179.252.216 1.179.252.217 1.179.252.218 1.179.252.219 1.179.252.220 1.179.252.221 1.179.252.222 1.179.252.223 1.179.252.224 1.179.252.225 1.179.252.226 1.179.252.227 1.179.252.228 1.179.252.229 1.179.252.230 1.179.252.231 1.179.252.232 1.179.252.233 1.179.252.234 1.179.252.235 1.179.252.236 1.179.252.237 1.179.252.238 1.179.252.239 1.179.252.240 1.179.252.241 1.179.252.242 1.179.252.243 1.179.252.244 1.179.252.245 1.179.252.246 1.179.252.247 1.179.252.248 1.179.252.249 1.179.252.250 1.179.252.251 Top Thailand 1.179.253.4 1.179.253.5 1.179.253.6 1.179.253.7 1.179.253.8 1.179.253.9 1.179.253.10 1.179.253.11 1.179.253.12 1.179.253.13 1.179.253.14 1.179.253.15 1.179.253.16 1.179.253.17 1.179.253.18 1.179.253.19 1.179.253.20 1.179.253.21 1.179.253.22 1.179.253.23 1.179.253.24 1.179.253.25 1.179.253.26 1.179.253.27 1.179.253.28 1.179.253.29 1.179.253.30 1.179.253.31 1.179.253.32 1.179.253.33 1.179.253.34 1.179.253.35 1.179.253.36 1.179.253.37 1.179.253.38 1.179.253.39 1.179.253.40 1.179.253.41 1.179.253.42 1.179.253.43 1.179.253.44 1.179.253.45 1.179.253.46 1.179.253.47 1.179.253.48 1.179.253.49 1.179.253.50 1.179.253.51 1.179.253.52 1.179.253.53 1.179.253.54 1.179.253.55 1.179.253.56 1.179.253.57 1.179.253.58 1.179.253.59 1.179.253.76 1.179.253.77 1.179.253.78 1.179.253.79 1.179.253.80 1.179.253.81 1.179.253.82 1.179.253.83 1.179.253.84 1.179.253.85 1.179.253.86 1.179.253.87 1.179.253.88 1.179.253.89 1.179.253.90 1.179.253.91 1.179.253.92 1.179.253.93 1.179.253.94 1.179.253.95 1.179.253.96 1.179.253.97 1.179.253.98 1.179.253.99 1.179.253.100 1.179.253.101 1.179.253.102 1.179.253.103 1.179.253.104 1.179.253.105 1.179.253.106 1.179.253.107 1.179.253.108 1.179.253.109 1.179.253.110 1.179.253.111 1.179.253.112 1.179.253.113 1.179.253.114 1.179.253.115 1.179.253.116 1.179.253.117 1.179.253.118 1.179.253.119 1.179.253.120 1.179.253.121 1.179.253.122 1.179.253.123 Top Thailand 118.174.25.4 118.174.25.5 118.174.25.6 118.174.25.7 118.174.25.8 118.174.25.9 118.174.25.10 118.174.25.11 118.174.25.12 118.174.25.13 118.174.25.14 118.174.25.15 118.174.25.16 118.174.25.17 118.174.25.18 118.174.25.19 118.174.25.20 118.174.25.21 118.174.25.22 118.174.25.23 118.174.25.24 118.174.25.25 118.174.25.26 118.174.25.27 118.174.25.28 118.174.25.29 118.174.25.30 118.174.25.31 118.174.25.32 118.174.25.33 118.174.25.34 118.174.25.35 118.174.25.36 118.174.25.37 118.174.25.38 118.174.25.39 118.174.25.40 118.174.25.41 118.174.25.42 118.174.25.43 118.174.25.44 118.174.25.45 118.174.25.46 118.174.25.47 118.174.25.48 118.174.25.49 118.174.25.50 118.174.25.51 118.174.25.52 118.174.25.53 118.174.25.54 118.174.25.55 118.174.25.56 118.174.25.57 118.174.25.58 118.174.25.59 118.174.25.68 118.174.25.69 118.174.25.70 118.174.25.71 118.174.25.72 118.174.25.73 118.174.25.74 118.174.25.75 118.174.25.76 118.174.25.77 118.174.25.78 118.174.25.79 118.174.25.80 118.174.25.81 118.174.25.82 118.174.25.83 118.174.25.84 118.174.25.85 118.174.25.86 118.174.25.87 118.174.25.88 118.174.25.89 118.174.25.90 118.174.25.91 118.174.25.92 118.174.25.93 118.174.25.94 118.174.25.95 118.174.25.96 118.174.25.97 118.174.25.98 118.174.25.99 118.174.25.100 118.174.25.101 118.174.25.102 118.174.25.103 118.174.25.104 118.174.25.105 118.174.25.106 118.174.25.107 118.174.25.108 118.174.25.109 118.174.25.110 118.174.25.111 118.174.25.112 118.174.25.113 118.174.25.114 118.174.25.115 118.174.25.116 118.174.25.117 118.174.25.118 118.174.25.119 118.174.25.120 118.174.25.121 118.174.25.122 118.174.25.123 118.174.25.132 118.174.25.133 118.174.25.134 118.174.25.135 118.174.25.136 118.174.25.137 118.174.25.138 118.174.25.139 118.174.25.140 118.174.25.141 118.174.25.142 118.174.25.143 118.174.25.144 118.174.25.145 118.174.25.146 118.174.25.147 118.174.25.148 118.174.25.149 118.174.25.150 118.174.25.151 118.174.25.152 118.174.25.153 118.174.25.154 118.174.25.155 118.174.25.156 118.174.25.157 118.174.25.158 118.174.25.159 118.174.25.160 118.174.25.161 118.174.25.162 118.174.25.163 118.174.25.164 118.174.25.165 118.174.25.166 118.174.25.167 118.174.25.168 118.174.25.169 118.174.25.170 118.174.25.171 118.174.25.172 118.174.25.173 118.174.25.174 118.174.25.175 118.174.25.176 118.174.25.177 118.174.25.178 118.174.25.179 118.174.25.180 118.174.25.181 118.174.25.182 118.174.25.183 118.174.25.184 118.174.25.185 118.174.25.186 118.174.25.187 118.174.25.196 118.174.25.197 118.174.25.198 118.174.25.199 118.174.25.200 118.174.25.201 118.174.25.202 118.174.25.203 118.174.25.204 118.174.25.205 118.174.25.206 118.174.25.207 118.174.25.208 118.174.25.209 118.174.25.210 118.174.25.211 118.174.25.212 118.174.25.213 118.174.25.214 118.174.25.215 118.174.25.216 118.174.25.217 118.174.25.218 118.174.25.219 118.174.25.220 118.174.25.221 118.174.25.222 118.174.25.223 118.174.25.224 118.174.25.225 118.174.25.226 118.174.25.227 118.174.25.228 118.174.25.229 118.174.25.230 118.174.25.231 118.174.25.232 118.174.25.233 118.174.25.234 118.174.25.235 118.174.25.236 118.174.25.237 118.174.25.238 118.174.25.239 118.174.25.240 118.174.25.241 118.174.25.242 118.174.25.243 118.174.25.244 118.174.25.245 118.174.25.246 118.174.25.247 118.174.25.248 118.174.25.249 118.174.25.250 118.174.25.251 Top IP 地址来源：http://www.kookle.co.nr","tags":[{"name":"Prose","slug":"Prose","permalink":"http://seniorzhai.github.io/tags/Prose/"}]},{"title":"LayoutInflater的inflate函数","date":"2014-06-11T05:24:20.000Z","path":"2014/06/11/LayoutInflater的inflate函数/","text":"LayoutInflater的作用是将layout的xml布局文件实例化为View类对象。获取LayoutInflater的方法有如下三种 12345678910111213141516171819LayoutInflater inflater=(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);View layout = inflater.inflate(R.layout.main, null); LayoutInflater inflater = LayoutInflater.from(context); (该方法实质就是第一种方法，可参考源代码) View layout = inflater.inflate(R.layout.main, null); LayoutInflater inflater = getLayoutInflater();（在Activity中可以使用，实际上是View子类下window的一个函数）View layout = inflater.inflate(R.layout.main, null);","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Xcode插件 Extend Plug-in","date":"2014-05-26T04:53:46.000Z","path":"2014/05/26/Xcode插件-Extend-Plug-in/","text":"安装 在线安装 12ruby -e &quot;$(curl -fsSkL raw.github.com/mxcl/homebrew/go)&quot;brew install uncrustify 下载安装 下载XEP-*.pkg和PrjEnv.pfg 安装XEP 把PrjEnv.cfg拷贝到项目的根目录(.xcodeproj文件所在的目录) 配置FULLUSERNAME和VERSION就可以生成@author和@since标签 修改代码格式化配置 如果想修改格式化的形式，修改 uncrustify.cfg ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/XEP.xcplugin/Contents/Resources 卸载 123cd ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-insrm -rf XEP.xcpluginbrew uninstall uncrustify 快捷键 格式化：control+shift+F(有效对象为代码、文件、项目目录) 生成注释：control+shift+J,以光标所在当前行往上查找可识别对象并生成对就注释（有原来有以双斜杠开头的注释会自动加到注释的描述中去). 整个文件生成注释:control+command+shift+J,同2功能，查找当前打开的文档，给所有对象生成的注释 复制一行：control+option+up/down(光标所在行)","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"日期选择器","date":"2014-05-24T04:36:18.000Z","path":"2014/05/24/日期选择器/","text":"UIDatePicker,用来选择日期的控件，也可作为倒计时控件。继承了UICtroller,可在Interface Builder中为UIDatePicker的Valre Changed事件绑定IBAction事件处理方法，也可在代码中为该控件绑定事件处理方法。 常用属性 Mode Date:控件仅显示日期，不显示时间。 Time:控件仅显示时间，不显示日期。 Date and Time:控件同时显示日期和时间。 Count Down Timer:控件仅显示为倒计时器。 Locale 设置UIDatePicker的国际化Locale，通常不需要手动设置，与手机的运行配置一致。 Interval 仅当该UIDatePicker控件设置采用Time、Date and Time和Count Down Timer这三种模式时有效，该属性设置UIDatePicker控件上两个时间的间隔。 Constraints 该属性设置最小时间和最大时间，如果设置了该属性值，用户无法通过该UIDatePicker控件选择超过该范围的日期和时间 Timer 仅当该UIDatePicker控件采用Count Down Timer模式时有效，该属性设置该控件作为倒计时控件时剩下的时间。 示例代码123456789101112131415161718-(void)viewDidLoad&#123; [super viewDidLoad];&#125;-(IBAction)clicked:(id)sender&#123; NSDate* seleced = [self.dataPicker date]; NSDateFormatter* dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@&quot;yyyy年MM月dd日 HH:mm+0800&quot;]; NSString* destDateString = [dateFormatter stringFromDate:selected]; NSString *message = [NSString stringWithFormat:@&quot;你选择的日期和时间是：%@&quot;，destDateString]; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;日期和时间&quot; message:message delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"表格(UITableView)和表格控制器(UITableViewController)","date":"2014-05-23T04:37:25.000Z","path":"2014/05/23/表格(UITableView)和表格控制器(UITableViewController)/","text":"UITableView实质是一个列表（单列表格） UITable继承了UIScrollView，主要封装了UITabelViewCell单元格控件。所以，UITabelView默认是可以对单元格进行滚动，默认情况下，所有的UITabelViewController实例被自动设为UIScrollView委托。 设置属性 Style Plain:指定该表格使用最普通的风格。 Grouped:指定该表格使用分组风格。 Separator 分割条样式：可选择Single Line(单线)和Single Line Etched(被蚀刻的单线) 分隔条颜色 Selection No Selection:不允许选中 Single Selection:只允许单选 允许多选 Editing No Selection During Editing:编辑状态时不允许选中 Single Selection During Editing:编辑状态时只允许单选 Multiple Selection During Editing:编辑状态时允许多选 属性和方法 style:只读属性，用于返回该表格的样式，可以返回UITabelViewStylePlain(普通)和UITabelViewStyleGrounped(分组)两个样式。 rowHeight:该属性用于返回或设置表格的行高，通常来说，建议实现表格对应的委托对象的tabelView:heightForRowAtIndexPath:方法来设置行高。 separatorStyle:该属性用于返回或设置表格的分割线样式。它支持UITabelViewCell SeparatorStyleNone(无分隔线)、UITabelViewCellSeparatorStyleSingleLine(单线分隔条)和UITableViewCellSeparatorStyleSingleLineEtched(被蚀刻的单线分隔条)这三个枚举值。 separatorColor:该属性用于设置分隔条的颜色。 backgroundView:该属性用于返回或设置表格的背景控件，它可以设置一个任意的UIView控件，该控件自动缩放到匹配该表格。 tabelHeaderView:该属性可设置或返回该表格的页眉控件。 tabelFooterView:该属性可设置或返回该表格的页脚控件。 numberOfRowsInSection:该方法返回指定分区包含的行数。 numberOfSections:该方法返回表格所包含的分区数。 设置数据UITableViewDataSource对象 tabelView:cellForRowAtIndexPath:必需方法，该方法返回的UITabelViewCell对象，将作为指定IndexPath对应表格行的控件。 tabelView:numberOfRowsInSection:必需方法，该方法返回的NSInteger值，决定指定分区包含的表格行数量。 numberOfSectionInTableView:可选方法，该方法返回的NSInteger值决定该表格所包含的分区数量。如果不实现该方法，该表格默认只包含一个分区。 UITableViewCell三个可配置的属性 textLabel:该属性是一个UILabel控件，代表UITableViewCell显示的标题。 detailTextLabel:该属性是一个UILabel控件，代表该UITableViewCell显示的详细内容。 image:该属性是一个UIImageView对象，代表UITabelViewCell坐标的图标。 UITableViewCell4种不同的风格 UITableViewCellStyleSubtitle:detailTextLabel字体略小，显示在textLabel的下方。 UITableViewCellStyleDefault:detailTextLabel，只显示textLabel。 UITableViewCellStyleValue1：deltailTextLabel以淡蓝色显示，显示在表格的右边。 UITableViewCellStyleValue2：deltailTextLabel以淡蓝色、小字体显示，detailTextLabel以大字体显示在表格右边，不显示image控件。 UITableView访问表格控件的表格行和分区的方法 -cellForRowAtIndexPath:返回该表格中指定NSIndexPath对应的表格栏 -indexPathForCell:获取该表格中指定表格行对应的NSIndexPath -indexPathForRowAtPoint:返回该表格中指定点所在的NSIndexPath -indexPathForRowInRect:返回该表格中指定区域内所有NSIndexPath组成的数组 -visibleCells:返回该表格中所有可见区域内的表格行组成的数组 -indexPathsForVisibleRows:返回该表格中多有可见区域内的表格行对应的NSIndexPath组成的数组 UITableView控制表格控件滚动的方法 scrollToRowAtIndexPath:atScrollPosition:animated:控件该表格滚动到指定的NSIndexPath对应的表格行的顶端、中间或下方。 -scrollToNearestSelectedRowAtScrollPosition:animated:控件该表格滚动到选中表格行的顶端、中间或下方。 UITableView配置表格被选中状态的属性 allowsSelection:该属性控制表格是否被运行选中 allowsMultipleSelection:该属性控制表格是否被允许多选 allowsSelectionDuringEditing:该属性控制该表格出于编辑状态时是否允许被选中。 allowsMultipleSelectionDuringEdting:该属性控制控制该表格处于编辑状态时是否允许多选。 UITableview操作表格被选中的方法 -indexPathForSelectedRow:获取选中表格行对应的NSIndexPath -indexPathsForSelecedRows:获取所有被选中表格行对应的NSIndexPath组成的数组 -selectRowAtIndexPath:animated:scrollPosition:控制该表格选中指定的NSIndexPath对应的表格行，最后一个参数控制是否滚动到被选中行的顶端、中间和底部 -deselectRowAtIndexPath:animated:取消选中该表格中指定NSIndexPath对应的表格行。 要响应表格行的选中事件，需要委托实现UITableViewDelegate，其中定义了如下方法： -tableView:willSelectRowAtIndexPath:当用户将要选中表格中某行时激发的方法 -tableView:didSelectRowAtIndexPath:当用户完成选中某行时激发的方法 -tableView:willDeselectRowAtIndexPath:当用户将要取消选中某行激发的方法 -tableView:didDeselectRowAtIndexPath:当用户取消选中某行时激发的方法","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Android体系架构和开发库","date":"2014-05-09T05:23:31.000Z","path":"2014/05/09/Android体系架构和开发库/","text":"Android的体系架构鼓励组建重用，允许开发者发布共享Activity、Service并且访问其他应用程序的数据，还可以根据开发者制定的安全限制进行管理。 剖析Android体系架构第一个列表将向开发者展示应用服务，这些服务是Android的架构基石。你也可以称它为所有的Android应用程序的支柱框架，为所有开发应用提供支持。 - Activity Manager:控制界面的生命周期，包括管理活动(Activity)栈 - Views:Views为应用程序构建用户界面。 - Notification Manager:提供一贯的非侵入式的机制来通知用户。 - Content Providers:让开发者在不同应用之间共享数据。 - Resource Manager:支持非代码资源，如字符串和图形被外部化。 Android库Android也提供了大量的API开发应用程序。 android.util:核心工具包种包含底层类，字符串格式化和XML解析工具、底层类 android.os:操作系统包提供了访问基本的操作系统服务，如消息传递、进程通信、时钟功能和调试。 android.graphics:图形API提供了支持画布、颜色和回执图元的低级别的图形类并且支持绘制画布。 android.text:用于显示和歇息文本的处理工具 android.database:在数据库处理游标时提供底层类支持 android.content:content API管理数据访问，提供服务来管理资源、内容提供者（content provider）和包 android.view:视图是核心的用户接口类，所有用户界面元素使用的是一系列视图，以构成用户交互的组件 android.widget:内置在View包内，小部件类是”这里是我们前面创建的“用户界面元素，可以在自己的应用程序中使用 com.google.android.maps:高级API，它提供了访问本地地图控件，可以在自己的应用程序中使用，包括MapView的控制、用于标注和控制您的前途地图的叠加以及MapController类 android.app:一个高层次的包，允许访问应用程序模型。该应用程序包括Activity和Service的API等是Android应用程序的基础 android.provider:方便开发者访问标准的内容提供者（比如联系人数据库），provider包提供类给开发者访问标准的数据库 android.telephony:telephony API让开发者直接接触电话底层，开发者可以打电话、接电话、显示通话记录、通话状态和短消息 android.webkit:WebKit的软件包功能的API与基于Web的内容的工作，其中包括一个WebView的控件在您的活动中嵌入浏览器和cookie管理器 除了在Android API，Android栈还包括一组的C/C++库，可通过应用程序框架发布出来。 OpenGl:用于支持基于OpenGL ES1.0 API、3D图像库 FreeType:支持位图和矢量字体渲染 SGL:用于提供2D图形和矢量字体渲染 ibc:标准C库，为基于Linux的嵌入式设备进行了优化 SQLite:用于存储应用程序数据的轻量级的关系数据库引擎 SSL:支持使用安全套接字层加密协议进行安全互联网通信 高级Android开发库 android.location:基于位置的服务的API，使应用程序访问设备的当前物理位置，基于位置的服务提供通的访问使用任何位置固定的硬件或技术设备上可用的位置信息。 android.media:没提API提供了用于播放音频和视频没提文件，包括流媒体和录制的支持。 android.opengl:Android提供使用的OpenGLass ES API，你可以用它来创建动态3D用户界面为你的应用程序的强大的3D渲染引擎 android.hardware:如果有可能，硬件API公开的传感器硬件，包括摄像头、加速计和指南针传感器 android.bluetooth,android.net.wifi,android.telephony:Android也提供了硬件平台，包括蓝牙、Wi-Fi和电话硬件的低级别的访问","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"eoe社区Android客户端项目分析","date":"2014-05-07T05:22:50.000Z","path":"2014/05/07/eoe社区Android客户端项目分析/","text":"一、工程目录结构src存放java源文件src ├ cn.eoe.app –存放程序全局性类的包├ cn.eoe.app.adapter –存放适配器的实现类的包 ├ cn.eoe.app.adapter.base –存放适配器基类的包├ cn.eoe.app.biz –存放ＤＡＯ类的包├ cn.eoe.app.config －－存放常量，配置和api接口等类的包├ cn.eoe.app.db –关于sqlite操作相关的类的包├ cn.eoe.app.db.biz –详细的增删改查类的包，暂时仅有一个类├ cn.eoe.app.entity –实体类包├ cn.eoe.app.entity.base –实体类基类包├ cn.eoe.app.https –网络访问相关类的包├ cn.eoe.app.indicator –导航相关的类包├ cn.eoe.app.slidingmenu –滑动菜单相关类包├ cn.eoe.app.ui –界面相关的包，activity的类├ cn.eoe.app.ui.base –activity相关的基类包├ cn.eoe.app.utils –工具类包├ cn.eoe.app.view –Fragment相关类的包├ cn.eoe.app.widget –自定义view组件包 ├ com.google.zxing.camera –第三方定义，控制摄像头包├ com.google.zxing.decoding – 二维码图像解码包├ com.google.zxing.view – 自定义View，控制拍摄取景框和动画等 libslibs目录存放项目引用的第三方jar包 ├ android-support-v4.jar –v4兼容包├ jackson-all-1.9.2.jar –解析json的包├ umeng_sdk.jar –友盟的sdk├ zxing-1.6.jar –二维码处理的包 二、Api接口数据分析http://http://api.eoe.name/client/top1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; \"response\": &#123; \"date\": 1399446965, \"categorys\": [ &#123; \"name\": \"精选教程\", \"url\": \"http://api.eoe.name//client/wiki?k=lists&amp;t=top\" &#125;, &#123; \"name\": \"精选资讯\", \"url\": \"http://api.eoe.name//client/news?k=lists&amp;t=top\" &#125;, &#123; \"name\": \"精选博客\", \"url\": \"http://api.eoe.name//client/blog?k=lists&amp;t=top\" &#125; ], \"list\": [ &#123; \"name\": \"精选教程\", \"more_url\": \"http://api.eoe.name//client/news?k=lists&amp;pageNum=2&amp;t=top\", \"items\": [ &#123; \"id\": \"17739\", \"thumbnail_url\": \"\", \"title\": \"给准备跳槽的互联网从业人员提个醒\", \"time\": \"1394029410\", \"short_content\": \" 早春三月，又到了一年一度的跳槽高峰。虽然东楼目...\", \"detail_url\": \"http://api.eoe.name/client/news?k=show&amp;id=17739\" &#125;, …… ] &#125;, &#123; \"more_url\": \"http://api.eoe.name/client/wiki?k=lists&amp;pageNum=2&amp;t=top\", \"name\": \"精选资讯\", \"items\": [ &#123; \"title\": \"创建你的第一个Android项目\", \"id\": \"242\", \"time\": \"1353410798\", \"detail_url\": \"http://api.eoe.name/client/wiki?k=show&amp;id=242\" &#125;, …… ] &#125;, &#123; \"name\": \"精选博客\", \"more_url\": \"http://api.eoe.name//client/blog?k=lists&amp;pageNum=2&amp;t=top\", \"items\": [ &#123; \"id\": \"3348\", \"name\": \"过期的白砂糖\", \"head_image_url\": \"http://bbs.eoe.name/uc_server/avatar.php?uid=739935&amp;size=small\", \"title\": \"GitHub上最火的40个Android开源项目（一）\", \"time\": \"1367809230\", \"short_content\": \"GitHub上最火的40个Android开源项目（一）GitHub上最...\", \"detail_url\": \"http://api.eoe.name/client/blog?k=show&amp;id=3348\" &#125;, …… ] &#125; ] &#125;&#125; date:日期 categorys:类别（分别是精选教程、精选资讯、精选博客） list:文章列表 name:名字 more_url:更多文章URL items:文章数组 分析下文章数组的数据 精选教程item id:文章的id thumbnail_url:缩略图url title:标题 short_content:内容梗概 detil_url:文章的url 精选资讯item title:标题 time:发表时间 detail_url:文章url id:文章id 精选博客 id:文章id name:作者名称 head_image_url:作者头像 title:文章标题 time:发表时间 short_content:文章梗概 detail_url:文章url http://api.eoe.cn/client/news?k=lists&amp;t=top资讯推介1234567891011121314151617&#123; &quot;response&quot;: &#123; &quot;name&quot;: &quot;推荐资讯&quot;, &quot;more_url&quot;: &quot;http://api.eoe.cn//client/news?k=lists&amp;pageNum=2&amp;t=top&quot;, &quot;items&quot;: [ &#123; &quot;id&quot;: &quot;17739&quot;, &quot;thumbnail_url&quot;: &quot;&quot;, &quot;title&quot;: &quot;给准备跳槽的互联网从业人员提个醒&quot;, &quot;time&quot;: &quot;1394029410&quot;, &quot;short_content&quot;: &quot; 早春三月，又到了一年一度的跳槽高峰。虽然东楼目...&quot;, &quot;detail_url&quot;: &quot;http://api.eoe.cn/client/news?k=show&amp;id=17739&quot; &#125;, …… ] &#125;&#125; 格式基本相同 推介博客http://api.eoe.cn/client/blog?k=lists&amp;t=top123456789101112131415161718&#123; \"response\": &#123; \"name\": \"推荐博客\", \"more_url\": \"http://api.eoe.cn//client/blog?k=lists&amp;pageNum=2&amp;t=top\", \"items\": [ &#123; \"id\": \"3348\", \"name\": \"过期的白砂糖\", \"head_image_url\": \"http://www.eoeandroid.com/uc_server/avatar.php?uid=739935&amp;size=small\", \"title\": \"GitHub上最火的40个Android开源项目（一）\", \"time\": \"1367809230\", \"short_content\": \"GitHub上最火的40个Android开源项目（一）GitHub上最...\", \"detail_url\": \"http://api.eoe.cn/client/blog?k=show&amp;id=3348\" &#125;, …… ] &#125;&#125; 推荐教程http://api.eoe.cn/client/wiki?k=lists&amp;t=top123456789101112131415&#123; \"response\": &#123; \"more_url\": \"http://api.eoe.cn/client/wiki?k=lists&amp;pageNum=2&amp;t=top\", \"name\": \"推荐教程\", \"items\": [ &#123; \"title\": \"创建你的第一个Android项目\", \"id\": \"242\", \"time\": \"1353410798\", \"detail_url\": \"http://api.eoe.cn/client/wiki?k=show&amp;id=242\" &#125;, …… ] &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Volley","date":"2014-05-07T05:21:53.000Z","path":"2014/05/07/Volley/","text":"使用Volley下载Volley源码并build jar包。1234$ git clone https://android.googlesource.com/platform/frameworks/volley$ cd volley$ android update project -p ./$ ant jar 把生成的jar包引用到项目中去。","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Android-Universal-Image-Loader","date":"2014-05-05T05:21:03.000Z","path":"2014/05/05/Android-Universal-Image-Loader/","text":"介绍Android-Universal-Image-Loader是一个开源的图片异步加载库，该项目的目的是提供一个可重复使用的图像异步加载、缓存和显示的工具。该库非常强大，国内外有很多有名的App都在使用。 特点 多线程的图像加载 尽可能多的配置选项（线程池，加载器，解析器，内存/磁盘缓存，显示参数等等） 可以添加图片加载监听器 可以自定义显示每一张图片时都带不同参数 支持Widget Android 1.5以上支持 使用方法1.Android Manifest1234567&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;user-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;application android:name=\"MyApplication\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 2.Application class12345678910public class MyApplication extends Application&#123; @Override public void onCreate() &#123; super.onCreate; ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext()) ... .build(); ImageLoader.getInstance().init(config); &#125; &#125; Configuration所有的选项都是可选的，只选择你真正制定的去配置。123456789101112131415161718192021File cacheDir = StrongeUtils.getCacheDiretory(context);ImageLoaderConfiguration config = new ImageLoaderConfiguration.Bulider(context).memoryCacheExtraOptions(480,800) //如果图片尺寸大于了这个参数，那么就会按照这个参数对图片大小进行限制并缓存，默认是屏幕大小.discCacheExtraOptions(480, 800, CompressFormat.JPEG, 75, null).taskExecutor(...).taskExecutorForCachedImages(...).threadPoolSize(3) // default.threadPriority(Thread.NORM_PRIORITY - 1) // default.tasksProcessingOrder(QueueProcessingType.FIFO) // default.denyCacheImageMultipleSizesInMemory().memoryCache(new LruMemoryCache(2 * 1024 * 1024)).memoryCacheSize(2 * 1024 * 1024).memoryCacheSizePercentage(13) // default.discCache(new UnlimitedDiscCache(cacheDir)) // default.discCacheSize(50 * 1024 * 1024).discCacheFileCount(100).discCacheFileNameGenerator(new HashCodeFileNameGenerator()) // default.imageDownloader(new BaseImageDownloader(context)) // default.imageDecoder(new BaseImageDecoder()) // default.defaultDisplayImageOptions(DisplayImageOptions.createSimple()) // default.writeDebugLogs().build(); Display Options显示参数可以分别被每一个显示任务调用(ImageLoader.displayImage(…))123456789101112131415161718DisplayImageOptions options = new DisplayImageOptions.Builder() .showImageOnLoading(R.drawable.ic_stub) // 在显示真正的图片前，会加载这些资源 .showImageForEmptyUri(R.drawable.ic_empty) // 空的Url .showImageOnFail(R.drawable.ic_error) // 错误时加载 .resetViewBeforeLoading(false) // default .delayBeforeLoading(1000) // 延时1000ms加载图片 .cacheInMemory(false) // default .cacheOnDisc(false) // default .preProcessor(...) .postProcessor(...) .extraForDownloader(...) .considerExifParams(false) // default .imageScaleType(ImageScaleType.IN_SAMPLE_POWER_OF_2) // default .bitmapConfig(Bitmap.Config.ARGB_8888) // default .decodingOptions(...) .displayer(new SimpleBitmapDisplayer()) // default .handler(new Handler()) // default .build(); 可接受的URL12345String imageUri = &quot;http://site.com/image.png&quot;; // from WebString imageUri = &quot;file:///mnt/sdcard/image.png&quot;; // from SD cardString imageUri = &quot;content://media/external/audio/albumart/13&quot;; // from content providerString imageUri = &quot;assets://image.png&quot;; // from assetsString imageUri = &quot;drawable://&quot; + R.drawable.image; // from drawables (only images, non-9patch) 完整版123456789101112131415161718192021222324252627282930313233343536// Load image, decode it to Bitmap and display Bitmap in ImageViewimageLoader.displayImage(imageUri, imageView, displayOptions, new ImageLoadingListener() &#123; @Override public void onLoadingStarted(String imageUri, View view) &#123; ... &#125; @Override public void onLoadingFailed(String imageUri, View view, FailReason failReason) &#123; ... &#125; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; ... &#125; @Override public void onLoadingCancelled(String imageUri, View view) &#123; ... &#125;&#125;,new ImageLoadingProgressListener()&#123; @Override public void onProgressUpdate(String imageUri, View view, int current, int total) &#123; ... &#125;&#125;);ImageSize targetSize = new ImageSize(120, 80); // result Bitmap will be fit to this sizeimageLoader.loadImage(imageUri, targetSize, displayOptions, new SimpleImageLoadingListener() &#123; @Override public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) &#123; // Do whatever you want with Bitmap &#125;&#125;);// 同步解码BitmapBitmap bmp = imageLoader.loadImageSync(imageUri, targetSize, displayOptions); 用户信息1.缓存默认情况下不启用。如果你想加载的图像会在内存或磁盘上的缓存，那么你应该在DisplayImageOptions启用缓存这种方式：123456789101112DisplayImageOptions defaultOptions = new DisplayImageOptions.Builder() ... .cacheInMemory(true) .cacheOnDisc(true) ... .build();ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(getApplicationContext()) ... .defaultDisplayImageOptions(defaultOptions) ... .build();ImageLoader.getInstance().init(config);","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"精灵帧缓存","date":"2014-05-05T03:34:42.000Z","path":"2014/05/05/精灵帧缓存/","text":"简介SpriteFrameCache 主要服务于多张碎图合并出来的纹理图片。这种纹理在一张大图中包含了多张小图，直接通过TextureCache引用会有诸多不便，因而衍生出来精灵框帧的处理方式，即把截取好的纹理信息保存在一个精灵框帧内，精灵通过切换不同的框帧来显示出不同的图案。 SpriteFrameCacheSpriteFrameCache的内部封装了一个Map _spriteFrames对象。key为帧的名称。SpriteFrameCache一般用来处理plist文件(这个文件指定了每个独立的精灵在这张“大图”里面的位置和大小)，该文件对应一张包含多个精灵的大图，plist文件可以使用TexturePacker制作。 SpriteFrameCache的常用接口和TextureCache类似，不再赘述了，唯一需要注意的是添加精灵帧的配套文件一个plist文件和一张大的纹理图。下面列举了SpriteFrameCache常用的方法：（详细API请看SpriteFrameCache API） 获取单例的SpriteFrameCache对象。sharedSpriteFrameCache方法在3.0中已经弃用。1SpriteFrameCache* cache = SpriteFrameCache::getInstance(); 销毁SpriteFrameCache对象。1SpriteFrameCache::destroyInstance(); 使用SpriteFrameCache获取指定的精灵帧，创建精灵对象。1234SpriteFrameCache *frameCache = SpriteFrameCache::getInstance(); frameCache-&gt;addSpriteFramesWithFile(\"boy.plist\",\"boy.png\");//boy.png里集合了boy1.png,boy2.png这些小图 auto frame_sp = Sprite::createWithSpriteFrameName(\"boy1.png\");//从SpriteFrameCache缓存中找到boy1.png这张图片. this-&gt;addChild(frame_sp,2); SpriteFrameCache vs. TextureCache SpriteFrameCache精灵框帧缓存。顾名思义，这里缓存的是精灵帧SpriteFrame，它主要服务于多张碎图合并出来的纹理图片。这种纹理在一张大图中包含了多张小图，直接通过TextureCache引用会有诸多不便，因而衍生出来精灵框帧的处理方式，即把截取好的纹理信息保存在一个精灵框帧内，精灵通过切换不同的框帧来显示出不同的图案。 跟TextureCache功能一样，将SpriteFrame缓存起来，在下次使用的时候直接去取。不过跟TextureCache不同的是，如果内存池中不存在要查找的图片，它会提示找不到，而不会去本地加载图片。 TextureCache时最底层也是最有效的纹理缓存，缓存的是加载到内存中的纹理资源，也就是图片资源。 SpriteFrameCache精灵框帧缓存，缓存的时精灵帧。 SpriteFrameCache是基于TextureCache上的封装。缓存的是精灵帧，是纹理指定区域的矩形块。各精灵帧都在同一纹理中，通过切换不同的框帧来显示出不同的图案。","tags":[{"name":"Sprite","slug":"Sprite","permalink":"http://seniorzhai.github.io/tags/Sprite/"},{"name":"精灵帧","slug":"精灵帧","permalink":"http://seniorzhai.github.io/tags/精灵帧/"}]},{"title":"动画引擎Pop介绍","date":"2014-05-04T05:08:08.000Z","path":"2014/05/04/动画引擎Pop介绍/","text":"几天前Facebook开源了旗下应用Paper所使用的动画引擎Pop。使用动态动画(dynamic animations)而不是传统的静态动画(static animations)，Pop使常见的滑动(scrolling)、弹跳(bouncing)、折叠(unfolding)等效果充满了活力，也使Paper给人耳目一新的感觉。 为什么需要Pop从第一代iPhone开始，iOS系统在对静态动画(static animations)方面的支持就很出色。苹果提供的Core Animation framework，使我们方便的使用线性动画(linear)、淡入效果(ease-in)、淡出效果(ease-out)等动画。 手势交互的革新迎来了新的一轮软件设计的浪潮。人们可以用手指直接操作屏幕上的元素，(而不是想以前，需要一支笔)，这就降低了交互的间接性（反着说，就是交互更直接），于是，人们又提出更进一步的要求：既然触屏可以得到处理，那么不同速度的划屏操作也应该得到处理。 当我们在2010年连个创办Push Pop Press公司的时候，我们的目标就是创造一种可行的、基于物理效果(physics-everywhere)的体验。我们在寻求一种可以使人们非常愉悦、轻松的使用整个应用的解决方案，就像我们使用UIScrollView那样的顺滑。 Popular就是这种理念的最新表现，它使你可以使用你熟悉而且强大的Core Animation进行编程，并且它能够捕获手势操作的速度，更好的反应用户的意图。Paper给我们了一个重新定义这种理念和其背后的动画引擎的机会。 目标Pop在三个不同的纬度提供了相应的工具。第一，我们想使一些常见动画在使用上更加的简单便利，除了iOS内建的4种静态动画(static animations),Pop增加三种原始的动画类型：弹簧效果(spring)，衰变效果(decay)和自定义效果(custom)。 弹簧效果和衰变效果是动态动画，正是它们让Paper充满了活力动感。弹簧动画使Paper上的元素优雅的弹跳(attractive bounce)。衰变动画可以使元素的移动(movement)缓慢的停止。这两种动画都是把速度作为输入，并且在处理用户手势时的理想方案之一。 第二，Pop是一个可灵活扩展的库。自定义动画(custom animation)允许开发者插自己的动画代码，使你可以容易的创造出独特的动画效果。通过把动画从展示层(display)解耦，Pop是一个适用范围更广的库，你可以对任何对象属性做动态的改变，就像做动画那样。 第三，我们的目标是构建一个开发者有好但是功能强大的编程模型。比如，Core Animation开发者应该对下面的API比较熟悉：1234567891011121314151617@interface CALayer/* Attach an animation to the layer. */- (void)addAnimation:(CAAnimation *)anim forKey:(NSString *)key;/* Remove all animation attached to the layer. */- (void)removeAllAnimations;/* Remove any animation attached to the layer for &apos;key&apos;. */- (void)removeAnimationForKey:(NSString *)key;/* Returns an array containing the keys of all animations currently attached to the receiver. */- (NSArray *)animationKeys;/* Returns the animation added to the layer with identifier &apos;key&apos;, or nil if no such animation exists. */- (CAAnimation *)animationForKey:(NSString *)key;@end 开发者可以通过这些接口，使用Core Animation来开始和结束动画。最显著的一点是，它也支持查询正在中的动画，这是终端动画和构建流畅的用户界面的关键。下面是Popular实现相同功能提供的API：123456789101112131415161718@interface NSObject (pop)/* Attach an animation to the layer. */- (void)pop_addAnimation:(POPAnimation *)anim forKey:(NSString *)kay;/* Remove all animations attached to the layer. */- (void)pop_removeAllAnimations;/* Remove any animation attached to the layer for &apos;key&apos;. */- (void)pop_removeAnimationForKey:(NSString *)key;/* Returns an array containing the keys of all animations currently attached to the receiver. */- (NSArray *)pop_animationKeys;/* Returns the animation added to the layer with identifier &apos;key&apos;, or nil if no such animation exists. */- (POPAnimation *)pop_animationForKey:(NSString *)key;@end 最基本的动画类型是POPAnimation，由于Pop是在NSObject上扩展的类别，所以可以在任何对象上做动画。除了上面提到的区别外，这些API接口形式在其他方面都没有什么区别。 下面的例子展示了如何对layer的bounds属性做弹簧动画：1234POPSpringAnimation *anim = [POPSpringAnimation animation];anim.property = [POPAnimatableProperty propertyWithName:kPOPLayerBounds];anim.toValue = [NSValue valueWithCGRect:CGRectMake(0,0,400,400)];[layer pop_addAnimation:anim forKey:@&quot;size&quot;]; 如果你会使用Core Animation构建动画，那么你也会用Pop，它们在使用上是相同的。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UIGestureRecognizer","date":"2014-04-30T05:07:17.000Z","path":"2014/04/30/UIGestureRecognizer/","text":"UITapGestureRecognizer（点一下） UIPinchGestureRecognizer（两指往内或往外拨动，就是常用的缩放） UIRotationGestureRecognizer（旋转） UISwipeGestureRecognizer（滑动） UIPanGestureRecognizer（拖动，慢速移动） UILongPressGestureRecognizer（长按） UIGestureRecognizer的继承关系如下： 使用手势的步骤 创建手势实例，指定一个回调方法，当手势开始，改变或结束时，回调方法被调用。 添加到需要识别的View中，每个手势只能对应一个View，当屏幕触摸在View的边界内，如果手势和预定的一样，就会回调方法。 ps:一个手势只能对应一个View，但一个View可以对应多个手势。 Pan拖动手势123456UIImageView *snakeImageView = [[UIImageView alloc] initWithImage:[UIImage imageName:@&quot;snake.png&quot;]];snakeImageView.frame = CGReckMake(50,50,100,160);UIPanGestureRecognizer *panGestureRecongnizer = [[UIPanGestureRecoginizer alloc] initWithTarget:self action:@selector(handlePan:)];[snakeImageView addGestureRecognizer:panGestureRecongnizer];[self.view setBackgroundColor:[UIColor whiteColor]];[self.view addSubview:snakeImageView]; 添加手势回调方法123456- (void) handlePan:(UIPanGestureRecognizer*) recognizer&#123; CGPoint translation = [recognizer translationInView:self.view]; recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x,recognizer.view.center.y + translation.y); [recognizer setTranslation:CGPointZero inView:self.view];&#125; Pinch缩放手势12345678UIPinchGestureRecoginzer *pinchGestureRecognizer = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(handlePinch:&quot;)];[snakeImageView addGestureRecognizer:pinchGestureRecognizer];- (void)handlePinch:(UIPinchGestureRecongnizer*) recognizer&#123; recognizer.view.transform = CGAffineTransformScale(recognizer.view.transform,recognizer.scale, recognizer.scale); recognizer.scale = 1;&#125; Rotation旋转手势12345678UIRotationGestureRecognizer *rotateRecognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(handleRotate:)]; [snakeImageView addGestureRecognizer:rotateRecognizer];- (void) handleRotate:(UIRotationGestureRecognizer*) recognizer &#123; recognizer.view.transform = CGAffineTransformRotate(recognizer.view.transform, recognizer.rotation); recognizer.rotation = 0; &#125; 多个View添加手势12345678910111213141516171819202122232425- (void)viewDidLoad &#123; [super viewDidLoad]; UIImageView *snakeImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;snake.png&quot;]]; UIImageView *dragonImageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;dragon.png&quot;]]; snakeImageView.frame = CGRectMake(120, 120, 100, 160); dragonImageView.frame = CGRectMake(50, 50, 100, 160); [self.view addSubview:snakeImageView]; [self.view addSubview:dragonImageView]; for (UIView *view in self.view.subviews) &#123; UIPanGestureRecognizer *panGestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePan:)]; UIPinchGestureRecognizer *pinchGestureRecognizer = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(handlePinch:)]; UIRotationGestureRecognizer *rotateRecognizer = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(handleRotate:)]; [view addGestureRecognizer:panGestureRecognizer]; [view addGestureRecognizer:pinchGestureRecognizer]; [view addGestureRecognizer:rotateRecognizer]; [view setUserInteractionEnabled:YES]; &#125; [self.view setBackgroundColor:[UIColor whiteColor]]; &#125; 监听手势12345678910111213141516171819202122232425- (void) handlePan:(UIPanGestureRecognizer*) recognizer &#123; CGPoint translation = [recognizer translationInView:self.view]; recognizer.view.center = CGPointMake(recognizer.view.center.x + translation.x, recognizer.view.center.y + translation.y); [recognizer setTranslation:CGPointZero inView:self.view]; if (recognizer.state == UIGestureRecognizerStateEnded) &#123; CGPoint velocity = [recognizer velocityInView:self.view]; CGFloat magnitude = sqrtf((velocity.x * velocity.x) + (velocity.y * velocity.y)); CGFloat slideMult = magnitude / 200; NSLog(@&quot;magnitude: %f, slideMult: %f&quot;, magnitude, slideMult); float slideFactor = 0.1 * slideMult; // Increase for more of a slide CGPoint finalPoint = CGPointMake(recognizer.view.center.x + (velocity.x * slideFactor), recognizer.view.center.y + (velocity.y * slideFactor)); finalPoint.x = MIN(MAX(finalPoint.x, 0), self.view.bounds.size.width); finalPoint.y = MIN(MAX(finalPoint.y, 0), self.view.bounds.size.height); [UIView animateWithDuration:slideFactor*2 delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123; recognizer.view.center = finalPoint; &#125; completion:nil]; &#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"判断手机为小米还是魅族","date":"2014-04-24T05:20:19.000Z","path":"2014/04/24/判断手机为小米还是魅族/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.io.IOException;public final class MIUIUtils&#123; private static final String KEY_MIUI_VERSION_CODE = \"ro.miui.ui.version.code\"; private static final String KEY_MIUI_VERSION_NAME = \"ro.miui.ui.version.name\"; private static final String KEY_MIUI_INTERNAL_STORAGE = \"ro.miui.internal.storage\"; public static boolean isMIUI() &#123; try &#123; final BuildProperties prop = BuildProperties.newInstance(); return prop.getProperty(KEY_MIUI_VERSION_CODE, null) != null || prop.getProperty(KEY_MIUI_VERSION_NAME, null) != null || prop.getProperty(KEY_MIUI_INTERNAL_STORAGE, null) != null; &#125; catch (final IOException e) &#123; return false; &#125; &#125;&#125;//工具类import android.os.Environment;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.Collection;import java.util.Enumeration;import java.util.Map.Entry;import java.util.Properties;import java.util.Set;public class BuildProperties&#123; private final Properties properties; private BuildProperties() throws IOException &#123; properties = new Properties(); properties.load(new FileInputStream(new File(Environment.getRootDirectory(), \"build.prop\"))); &#125; public boolean containsKey(final Object key) &#123; return properties.containsKey(key); &#125; public boolean containsValue(final Object value) &#123; return properties.containsValue(value); &#125; public Set&lt;Entry&lt;Object, Object&gt;&gt; entrySet() &#123; return properties.entrySet(); &#125; public String getProperty(final String name) &#123; return properties.getProperty(name); &#125; public String getProperty(final String name, final String defaultValue) &#123; return properties.getProperty(name, defaultValue); &#125; public boolean isEmpty() &#123; return properties.isEmpty(); &#125; public Enumeration&lt;Object&gt; keys() &#123; return properties.keys(); &#125; public Set&lt;Object&gt; keySet() &#123; return properties.keySet(); &#125; public int size() &#123; return properties.size(); &#125; public Collection&lt;Object&gt; values() &#123; return properties.values(); &#125; public static BuildProperties newInstance() throws IOException &#123; return new BuildProperties(); &#125;&#125;import android.os.Build;import java.lang.reflect.Method;pulic final class FlymeUtils&#123; public static boolean isFlyme()&#123; try&#123; // Invoke Build.hasSmartBar() Invoke Method method = Build.class.getMethod(\"hasSmartBar\"); return method != null; &#125;catch(final Exception e)&#123; return false; &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Bootstrap风格按钮","date":"2014-04-21T05:06:36.000Z","path":"2014/04/21/Bootstrap风格按钮/","text":"如何使用 将UIButton+Bootstrap,NSString+FontAwesome,FontAwesome.ttf文件添加进工程 导入UIButton+Bootstrap.h 在Info.plist中的Fonts provided by application中包含FontAwesome.ttf 创建自定义的UIButoon(把type属性设置为Custom)设置风格12[yourButton primaryStyle];[yourOtherButton successStyle]; 设置图标12[yourButton addAwesomeIcon:FAIconBookmark beforeTitle:YES];[yourOtherButton addAwesomeIcon:FAIconCalendar beforeTitle:NO];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Android自定义工具类","date":"2014-04-16T05:19:40.000Z","path":"2014/04/16/Android自定义工具类/","text":"CommonUtil boolean hasSDCard() 判断设备是否存在SD卡 String getRootFilePath() 返回文件系统的根目录，存在SD卡返回SD卡目录 boolean checkNetState(Context context) 判断是否存在网络 void showToask(Context context,String tip) 显示Toast通知 int getScreenWidth(Context context)\\int getScreenHeight(Context context) 返回屏幕的宽\\长 FileHelper boolean fileIsExist(String filePath) 判断文件是否存在 InputStream readFile(String filePath) 获取文件的input流 boolean createDirectory(String filePath) 创建文件目录 boolean deleteDirectroy(String filePath) 删除文件目录 boolean writeFile(String filePath,InputStream inputStream) 写入字符串到某文件","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"工具类","slug":"工具类","permalink":"http://seniorzhai.github.io/tags/工具类/"},{"name":"自定义","slug":"自定义","permalink":"http://seniorzhai.github.io/tags/自定义/"}]},{"title":"Action Bar","date":"2014-04-14T05:18:52.000Z","path":"2014/04/14/Action-Bar/","text":"添加Action BarAndroid 3.0及以上版本Android 3.0（API level 11）开始，所有使用Theme.Holo主题的Activity都内置了action bar，此主题是targetSdkVersion或minSdkVersion属性大于等于11时的默认主题。123&lt;manifest ...&gt; &lt;uses-sdk android:minSdkVersion=\"11\" .../&gt;&lt;/manifest&gt; 如果创建一个自定义主题，需呀确保它使用一个Theme.Holo主题作为父主题 支持Android 2.1及以上版本可以通过天剑Support库或者v7 appcompat库集成Action Bar到低版本 activity继承ActionBarActivity 1public class MainActivity extends ActionBarActivity &#123;...&#125; 在mainfest文件中设置application或设置单独的activity的主题为Theme.AppCompat 1&lt;activity android:theme=\"@style/Theme.AppCompat.Light\" ... &gt; 移除action bar可以把该Activity的主题设置为Theme.Holo.NoActionBar1&lt;activity android:theme=@\"android:style/Theme.Holo.NoActionBar\"&gt; 也可以在运行时通过调用hide()来隐藏action bar12ActionBar actionBar = getActionBar();actionBar.hide(); 也可以用show()来重新显示ActionBar。 添加Action项当acitivity第一次被启动时，系统会调用activity中的onCreateOptionsMenu()来构建Action和滑动菜单。菜单项通过XML格式的菜单资源来包装。在此XML文件中，通过将元素声明为带android:showAsAction=&quot;ifRoom&quot;属性，你可以让一个菜单项显示为action项。通过这种方式，菜单项将会仅当有空间时才显示在action bar中，便于快速访问。如果没有空间的话，菜单项将会显示在滑动菜单中。如果菜单项同时具有标题和文本——带有android:title和android:icon属性——则action项默认只显示图标。如果需要显示文本标题，只要在android:showAsAction属性中加入withText即可1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=@\"+id/menu_save\" android:icon=@\"drawable/ic_menu_save\" android:title=@\"string/menu_save\" android:showAsAction=\"ifRoom|withText\"/&gt;&lt;/menu&gt; 在Activity中实现onCreateOptionMenu()回调方法来inflate菜单资源从而获取Menu对象。1234567@Overridepublic boolean onCreateOptionsMenu(Menu menu)&#123; MenuInflater inflater = getMenuInflater(); inflater.inflate(R.menu.main_action_menu,menu); return super.onCreateOptionsMenu(menu);&#125; 用户选中一个action项，activity将会收到一个对onPtionsItemSelected()调用，并传入android:id属性给出的ID——选项菜单中的所有项都会被收到该回调方法。12345678910111213@Overridepublic boolean onOptionsItemSelected(MenuItem item)&#123; switch (item.getItemId())&#123; case R.id.action_search: openSearch(); return true; case R.id.action_settings: openSettings(); return true; default: return super.onOptionsItemSelected(item); &#125;&#125; 使用split action barAndroid 4.0(API level 14)及以上版本时，action bar增加一个名为”split action bar”的模式。启用split action bar后，如果在窄屏上（比如纵向显示的手持设备）运行activity，屏幕底部将会显示一个单独的bar，用于显示所有的action项，把action bar拆分开、让多个action项分开显示，可以确保在窄屏上以合理的间隔显示所有的action项，并为顶部的导航条和标题栏留下足够的空间。启用split action bar只要把uiOptions=”splitActionBarWhenNarrow”加入你的或manifest元素即可。 用应用程序图标导航默认情况下，应用程序图标显示在action bar的左侧。如果需要，可以把让图标成为一个action项。作为用户对图标Action的响应，应用程序必须执行以下两件事之一： 返回应用程序的初始home activity 应用程序向上回退至上一层当用户触摸图标时，系统会调用Activity的onOptionsItemSelected()方法，并带入android.R.id.homeID，作为响应，你应该启动home activity或让用户回到应用程序的上一侧。如果你把返回home activity作为应用程序图标的响应，则你应该在Intent中包含FLAG_ACTIVITY_CLEAR_TOP标志。如果你要启动的Activity已经存在于当前任务中了，则用这个标志，可以将所有在其之上的Activity都销毁，并把该activity推到前台。因为回到home等同于返回的Action，通常不应该创建一个新的home activity实例，所以加入这个标志是非常重要的。否则的话，当前的任务栈中可能会有一长串activity，其中包含了home activity的多个实例。123456789101112@Overridepublic boolean onOptionsItemSeleted(MenuItem item) &#123; switch(item.getItemId()) &#123; case android.R.id.home: Intent intent = new Intent(this,HomeActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLER_TOP); startActivity(intent); return true; &#125; default: return super.onPtionsItemSelected(item);&#125; 用户可以从其他应用程序中进入当前Activity，这时你也许还想加入FLAG_ACTIVITY_NEW_TASK标志，次标志表示，不管用户导航至home还是返回上一层，新的activity都不加入当前任务栈，而是放入一个属于你的应用程序的栈。比如说，如果用户通过其他应用提交一个itent，启动了一个属于你的应用的activity，然后选中了action bar图标来回到home或向上回退一级，FLAG_ACTIVITY_CLEAR_TOP标志将会启动属于你的应用程序任务中的Activity(而不是当前任务)。系统或是启动一个新的任务并把这个你的这个新activity作为根activity，或者，假如后台任务中存在该activity的实例的话，则把任务推到前台，该activity会收到onNewIntent()。因此，如果你的activity要从其他应用接收intent(声明了任何通用的intent过来器)，你通常应该在intent中加入FLAG_ACTIVITY_NEW_TASK：1intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK); 如果用图标来返回home activity，请注意自Android 4.0(API level 14)开始，你必须显式地调用setHomeButtonEnabled(true)将图标用作action项（之前的版本中，图标默认就是作为action项使用的）。 向上导航调用ActionBar的setDisplayHomeAsEnabled(true)12345678protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); setContentView(R.id.main); ActionBar actionBar = getActionBar(); actionBar.setDisplayHomeAsUpEnabled(true); ...&#125; 当用户触摸图标时，系统会调用activity的onOptionsItemSelected()方法，并带入android.R.id.homeID.记得在Intent上使用FLAG_ACTIVITY_CLEAR_TOP标志，这样就不会创建已存在的父activity的新实例。在manifest文件中声明父Activity1234567891011121314&lt;application ...&gt; &lt;activity android:name=\"com.example.myfirstapp.MainActivity\" ...&gt; ... &lt;/activity&gt; &lt;activity android:name=\"com.example.myfirstapp.DisplayMessageActivity\" android:label=\"@string/title_activity_display_message\" android:parentActivityName=\"com.example.myfirstapp.MainActivity\" &gt; &lt;meta-data android:name=\"android.support.PARENT_ACTIVITY\" android:value=\"com.example.myfirstapp.MainActivity\" /&gt; &lt;/activity&gt;&lt;/application&gt; ActionBar风格化Android的基本主题有暗、淡两个 在manifest文件中设置application或activity的android:theme属性1&lt;application android:theme=\"@android:style/Theme.Holo.Light\" ... /&gt; 使用Support库时，必须使用Theme.AppCompat主题替代 Theme.AppCompat，一个“暗”的主题 Theme.AppCompat.Light，一个“淡”的主题 Theme.AppCompat.Light.DarkActionBar，一个带有“暗” action bar 的“淡”主题自定义为了自定义主题，通过重写actionBarStyle属性来改变action bar的背景。通过指定一个drawable资源来重写background属性。 Android 3.0可以这样写res/values/themes.xml1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;!-- the theme applied to the application or activity --&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@android:style/Theme.Holo.Light.DarkActionBar\"&gt; &lt;item name=\"android:actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar styles --&gt; &lt;style name=\"MyActionBar\" parent=\"@android:style/Widget.Holo.Light.ActionBar.Solid.Inverse\"&gt; &lt;item name=\"android:background\"&gt;@drawable/actionbar_background&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 然后，将你的主题应该到你的 app 全局或单个的 activity 之中：1&lt;application android:theme=\"@style/CustomActionBarTheme\" ... /&gt; Android 2.1 版本可以这么写res/values/themes.xml1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;!-- the theme applied to the application or activity --&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@style/Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;item name=\"android:actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar styles --&gt; &lt;style name=\"MyActionBar\" parent=\"@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse\"&gt; &lt;item name=\"android:background\"&gt;@drawable/actionbar_background&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"background\"&gt;@drawable/actionbar_background&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 然后，将你的主题应该到你的 app 全局或单个的 activity 之中：1&lt;application android:theme=\"@style/CustomActionBarTheme\" ... /&gt; 自定义本文颜色 action bar的标题：指定textColor属性 action bar的页签：重写 actionBarTabTextStyle action bar按钮：重写 actionMenuTextColorAndroid 3.012345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;!-- the theme applied to the application or activity --&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@style/Theme.Holo\"&gt; &lt;item name=\"android:actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;item name=\"android:actionBarTabTextStyle\"&gt;@style/MyActionBarTabText&lt;/item&gt; &lt;item name=\"android:actionMenuTextColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar styles --&gt; &lt;style name=\"MyActionBar\" parent=\"@style/Widget.Holo.ActionBar\"&gt; &lt;item name=\"android:titleTextStyle\"&gt;@style/MyActionBarTitleText&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar title text --&gt; &lt;style name=\"MyActionBarTitleText\" parent=\"@style/TextAppearance.Holo.Widget.ActionBar.Title\"&gt; &lt;item name=\"android:textColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar tabs text styles --&gt; &lt;style name=\"MyActionBarTabText\" parent=\"@style/Widget.Holo.ActionBar.TabText\"&gt; &lt;item name=\"android:textColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; Android 2.11234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;!-- the theme applied to the application or activity --&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@style/Theme.AppCompat\"&gt; &lt;item name=\"android:actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;item name=\"android:actionBarTabTextStyle\"&gt;@style/MyActionBarTabText&lt;/item&gt; &lt;item name=\"android:actionMenuTextColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"actionBarStyle\"&gt;@style/MyActionBar&lt;/item&gt; &lt;item name=\"actionBarTabTextStyle\"&gt;@style/MyActionBarTabText&lt;/item&gt; &lt;item name=\"actionMenuTextColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar styles --&gt; &lt;style name=\"MyActionBar\" parent=\"@style/Widget.AppCompat.ActionBar\"&gt; &lt;item name=\"android:titleTextStyle\"&gt;@style/MyActionBarTitleText&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"titleTextStyle\"&gt;@style/MyActionBarTitleText&lt;/item&gt; &lt;/style&gt; &lt;!-- ActionBar title text --&gt; &lt;style name=\"MyActionBarTitleText\" parent=\"@style/TextAppearance.AppCompat.Widget.ActionBar.Title\"&gt; &lt;item name=\"android:textColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;!-- The textColor property is backward compatible with the Support Library --&gt; &lt;/style&gt; &lt;!-- ActionBar tabs text --&gt; &lt;style name=\"MyActionBarTabText\" parent=\"@style/Widget.AppCompat.ActionBar.TabText\"&gt; &lt;item name=\"android:textColor\"&gt;@color/actionbar_text&lt;/item&gt; &lt;!-- The textColor property is backward compatible with the Support Library --&gt; &lt;/style&gt;&lt;/resources&gt; 自定义Tab Indicator重写actionBarTabStyrle指定navigation tabs123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_focused=\"false\" android:state_selected=\"false\" android:state_pressed=\"false\" android:drawable=\"@drawable/tab_unselected\" /&gt; &lt;item android:state_focused=\"false\" android:state_selected=\"true\" android:state_pressed=\"false\" android:drawable=\"@drawable/tab_selected\" /&gt; &lt;item android:state_focused=\"true\" android:state_selected=\"false\" android:state_pressed=\"false\" android:drawable=\"@drawable/tab_unselected_focused\" /&gt; &lt;item android:state_focused=\"true\" android:state_selected=\"true\" android:state_pressed=\"false\" android:drawable=\"@drawable/tab_selected_focused\" /&gt; &lt;item android:state_focused=\"false\" android:state_selected=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/tab_unselected_pressed\" /&gt; &lt;item android:state_focused=\"false\" android:state_selected=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/tab_selected_pressed\" /&gt; &lt;item android:state_focused=\"true\" android:state_selected=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/tab_unselected_pressed\" /&gt; &lt;item android:state_focused=\"true\" android:state_selected=\"true\" android:state_pressed=\"true\" android:drawable=\"@drawable/tab_selected_pressed\" /&gt;&lt;/selector&gt; Android 3.012345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@style/Theme.Holo\"&gt; &lt;item name=\"android:actionBarTabStyle\"&gt;@style/MyActionBarTabs&lt;/item&gt; &lt;/style&gt; &lt;style name=\"MyActionBarTabs\" parent=\"@style/Widget.Holo.ActionBar.TabView\"&gt; &lt;!-- tab indicator --&gt; &lt;item name=\"android:background\"&gt;@drawable/actionbar_tab_indicator&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; Android 2.11234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@style/Theme.AppCompat\"&gt; &lt;item name=\"android:actionBarTabStyle\"&gt;@style/MyActionBarTabs&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"actionBarTabStyle\"&gt;@style/MyActionBarTabs&lt;/item&gt; &lt;/style&gt; &lt;style name=\"MyActionBarTabs\" parent=\"@style/Widget.AppCompat.ActionBar.TabView\"&gt; &lt;item name=\"android:background\"&gt;@drawable/actionbar_tab_indicator&lt;/item&gt; &lt;item name=\"background\"&gt;@drawable/actionbar_tab_indicator&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; Action Bar 覆盖叠加 启动叠加模式 自定义主题 设置android:windowActionBarOverlay的属性为true 1234567891011121314151617&lt;!-- android 3.0--&gt;&lt;resources&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@android:style/Theme.Holo\"&gt; &lt;item name=\"android:windowActionBarOverlay\"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt;&lt;!-- android 2.1 --&gt;&lt;resources&gt; &lt;style name=\"CustomActionBarTheme\" parent=\"@android:style/Theme.AppCompat\"&gt; &lt;item name=\"android:windowActionBarOverlay\"&gt;true&lt;/item&gt; &lt;!-- Support library compatibility --&gt; &lt;item name=\"windowActionBarOverlay\"&gt;true&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 指定布局的顶部边距 1234567&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingTop=\"?android:attr/actionBarSize\"&gt; &lt;!-- Support库中 移除android:前缀 paddingTop=\"?attr/actionBarSize\" --&gt; ...&lt;/RelativeLayout&gt; 添加一个Action Viewaction view是一个显示于action bar中的widget，用于替代某个action项按钮. 在菜单资源中声明一个action view项，使用android:actionLayout或android:actionViewClass属性指定一个layout资源或所需的widget类即可。比如：12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=@\"+id/menu_search\" android:title=@\"string/menu_search\" android:icon=@\"drawable/ic_menu_search\" android:showAsAction=\"ifRomm|collapseActionView\" android:actionViewClass=\"android.widget.SearchView\" /&gt;&lt;/menu&gt; 注意，android:showAsAction属性还包含了collapseActionView。这是可选项，表示action view应该折叠进入按钮中，当用户选中了按钮，action view就会展开。否则，action viewm默认就是可见的。action view可以通过下单项的ID调用findItem()，然后调用getActionView()。12345678@Overridepublic boolean onCreateOptionsMenu(Menu menu)&#123; getMenuInflater().inflate(R.menu.options,menu); SearchView searchView = (SavechView)menu.findItem(R.id.menu_search).getActionView(); // ... return super.onCreateOptionsMenu(menu);&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"AliasActivity","date":"2014-04-10T05:18:13.000Z","path":"2014/04/10/AliasActivity/","text":"存根Activity，用这个Activity来加载其他的Activity，为了重复使用Activity使用，它的子类必须实现onCreate()方法。可以在onCreate()方法中调用finish()方法，这时Activity跳过生命周期直接调用onDestroy()方法。activity-alias具体属性有： android:targetActivity 目标Activity，这个属性的值必须是声明 android:name alias的唯一标识 android:enabled 是否运行aliasActivity加载targetActivity，缺省为true android:exported 是否运行其他的Application通过使用aliasActivity来加载targetActivity 1234567891011121314151617181920&lt;activity android:name=\"com.example.aliasactivitydemo.MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;activity-alias android:name=\"AndroidAlias\" android:targetActivity=\"MainActivity\" android:label=\"Alias\" android:icon=\"@drawable/ic_launcher\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity-alias&gt; 示例 ExpendableListActivity一个具有可展开list，其中的item通过ExpandableListAdapter接口来绑定数据源。当用户选择其中某一项时可以自己去定义处理方法。ExpendableListActivity含有一个ExpandableView对象，用两层的方法来展示数据，第一层是组，第二层是子项。使用自定义的xml来制定布局，则ExpandableListView一定要用”@id/android:list”作为id，另外使用一个id@“@id/android/empty”来表示空的list. main.xml123456789101112&lt;ExpandableListView android:id=\"@id/android:list\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:layout_weight=\"1\" android:drawSelectorOnTop=\"false\" /&gt;&lt;TextView android:id=\"@id/android:empty\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:text=\"No data\"/&gt; child.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;TextView android:id=\"@+id/child\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:padding=\"50px\" android:paddingTop=\"5px\" android:paddingBottom=\"5px\" android:textSize=\"20px\" android:text=\"NO data\"/&gt;&lt;/LinearLayout&gt; group.xml123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;TextView android:id=\"@+id/group\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:padding=\"60px\" android:paddingTop=\"10px\" android:paddingBottom=\"10px\" android:textSize=\"26px\" android:text=\"No data\" /&gt;&lt;/LinearLayout&gt; MainActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243List&lt;Map&lt;String,String&gt;&gt; groups = new ArrayList&lt;Map&lt;String,String&gt;&gt;(); Map&lt;String, String&gt; group1 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; group2 = new HashMap&lt;String, String&gt;(); group1.put(\"group\", \"DOTA\"); group2.put(\"group\",\"DiaBlo\"); groups.add(group1); groups.add(group2); // List&lt;Map&lt;String, String&gt;&gt; child1 = new ArrayList&lt;Map&lt;String,String&gt;&gt;(); Map&lt;String, String&gt; childData1 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; childData2 = new HashMap&lt;String, String&gt;(); childData1.put(\"child\", \"Dota1\"); childData2.put(\"child\", \"Dota2\"); child1.add(childData1); child1.add(childData2); // List&lt;Map&lt;String, String&gt;&gt; child2 = new ArrayList&lt;Map&lt;String,String&gt;&gt;(); Map&lt;String, String&gt; child2Data1 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; child2Data2 = new HashMap&lt;String, String&gt;(); Map&lt;String, String&gt; child2Data3 = new HashMap&lt;String, String&gt;(); child2Data1.put(\"child\", \"DiaBlo1\"); child2Data2.put(\"child\", \"DiaBlo2\"); child2Data3.put(\"child\", \"DiaBlo3\"); child2.add(child2Data1); child2.add(child2Data2); child2.add(child2Data3); // List&lt;List&lt;Map&lt;String,String&gt;&gt;&gt; childs = new ArrayList&lt;List&lt;Map&lt;String,String&gt;&gt;&gt;(); childs.add(child1); childs.add(child2); SimpleExpandableListAdapter adapter = new SimpleExpandableListAdapter( this, //context groups, //一级目录数据 R.layout.group, //一级目录样式布局文件 new String[]&#123;\"group\"&#125;, //指定一级目录数据的key new int[]&#123;R.id.group&#125;, //指定一级目录数据显示控件的id childs, //二级目录的数据 R.layout.child, //二级目录样式布局文件 new String[]&#123;\"child\"&#125;, //指定二级目录数据的 new int[]&#123;R.id.child&#125; //指定二级目录数据显示控件的 ); setListAdapter(adapter); 示例","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"NSURLConnection","date":"2014-04-09T05:05:53.000Z","path":"2014/04/09/NSURLConnection/","text":"先创建一个NSURL 在通过NSURL创建NSURLRequest，可以指定缓存规则和超时时间 创建NSURLConnection实例，指定NSURLRequest和delegate对象，如果创建失败，则返回nil，如果创建成功则创建一个NSMutableData的实例用来存储数据。 123456789101112131415161718192021222324252627282930NSURLRequest *request = [NSUELRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.sina.com.cn/&quot;] cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:10.0];NSURLConnection *connection = [[NSURLConnection alloc] initWithRequest:request delegate:self];if(connection)&#123; // 创建成功&#125;else&#123; // 创建失败&#125;# pragma mark- NSUrlConnectionDelegate methods- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //接受一个服务端回话，再次一般初始化接受数据的对象&#125;- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; // 每个中间data&#125;- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; // 连接结束&#125;- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; // 链接错误&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Shutdown","date":"2014-04-08T06:56:32.000Z","path":"2014/04/08/Shutdown/","text":"Shutdown命令，h/r/s分别代表关机、重启、睡眠，再加上执行时间（yymmddhhmm）即可 比如sudo shutdown -h 1404081900","tags":[{"name":"Prose","slug":"Prose","permalink":"http://seniorzhai.github.io/tags/Prose/"}]},{"title":"NSFile常用方法","date":"2014-04-08T05:05:07.000Z","path":"2014/04/08/NSFile常用方法/","text":"1、常见的NSFileManager文件方法 -(NSData *)contentsAtPath:path //从一个文件读取数据 -(BOOL)createFileAtPath: path contents:(NSData *)data attributes:attr //向一个文件写入数据 -(BOOL)removeItemAtPath:path error:err //删除一个文件 -(BOOL)moveItemAtPath：from toPath:to error:err //重命名或者移动一个文件（to不能是已存在的） -(BOOL)copyItemAtPath:from toPath:to error:err //复制文件（to不能是已存在的） -(BOOL)contentsEqualAtPath:path andPath:path2 //比较两个文件的内容 -(BOOL)fileExistAtPath:path //测试文件是否存在 -(BOOL)isReadableFileAtPath:path //测试文件是否存在，并且是否能执行读操作 -(BOOL)isWriteableFileAtPath:path //测试文件是否存在，并且是否能执行写操作 -(NSDictionary *)attributesOfItemAtPath:path error:err //获取文件的属性 -(BOOL)setAttributesOfItemAtPath:attr error:err //更改文件的属性 2.使用目录 -(NSString *)currentDirectoryPath //获取当前目录 -(BOOL)changeCurrentDirectoryPath:path //更改当前目录 -(BOOL)copyItemAtPath:from toPath:to error:err //复制目录结构（to不能是已存在的） -(BOOL)createDirectoryAtPath:path withIntermediateDirectories:(BOOL)flag attribute:attr //创建一个新目录 -(BOOL)fileExistAtPath:path isDirectory:(BOOL*)flag //测试文件是不是目录（flag中储存结果YES/NO） -(NSArray *)contentsOfDirectoryAtPath:path error:err //列出目录内容 -(NSDirectoryEnumerator *)enumeratorAtPath:path //枚举目录的内容 -(BOOL)removeItemAtPath:path error:err //删除空目录 -(BOOL)moveItemAtPath:from toPath:to error:err //重命名或移动一个目录（to不能是已存在的） 3、常用路径工具方法 +(NSString *)pathWithComponens:components //根据components中的元素构造有效路径 -(NSArray *)pathComponents //析构路径，获得组成此路径的各个部分 -(NSString *)lastPathComponent //提取路径的最后一个组成部分 -(NSString *)pathExtension //从路径的最后一个组成部分中提取其扩展名 -(NSString *)stringByAppendingPathComponent:path //将path添加到现有路径的末尾 -(NSString *)stringByAppendingPathExtension:ext //将指定的扩展名添加到路径的最后一个组成部分 -(NSString *)stringByDeletingLastPathComponent //删除路径的最后一个组成部分 -(NSString *)stringByDeletingPathExtension //从文件的最后一部分删除扩展名 -(NSString *)stringByExpandingTileInPath //将路径中代字符扩展成用户主目录（~）或指定用户的主目录（~user） -(NSString *)stringByresolvingSymlinksInPath //尝试解析路径中的符号链接 -(NSString *)stringByStandardizingPath //通过尝试解析~、..（父目录符号）、.（当前目录符号）和符号链接来标准化路径 4、常用的路径工具函数 NSString* NSUserName(void) //返回当前用户的登录名 NSString* NSFullUserName(void) //返回当前用户的完整用户名 NSString* NSHomeDirectory(void) //返回当前用户主目录的路径 NSString NSHomeDirectoryForUser(NSString user) //返回用户user的主目录 NSString* NSTemporaryDirectory(void) //返回可用于创建临时文件的路径目录 5、常用的IOS目录 Documents（NSDocumentDirectory） //用于写入应用相关数据文件的目录，在ios中写入这里的文件能够与iTunes共享并访问，存储在这里的文件会自动备份到云端 Library/Caches（NSCachesDirectory） //用于写入应用支持文件的目录，保存应用程序再次启动需要的信息。iTunes不会对这个目录的内容进行备份 tmp（use NSTemporaryDirectory（）） //这个目录用于存放临时文件，只程序终止时需要移除这些文件，当应用程序不再需要这些临时文件时，应该将其从这个目录中删除 Library/Preferences //这个目录包含应用程序的偏好设置文件，使用 NSUserDefault类进行偏好设置文件的创建、读取和修改","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"autoresizingMask","date":"2014-04-08T05:04:32.000Z","path":"2014/04/08/autoresizingMask/","text":"在 UIView 中有一个autoresizingMask的属性，它对应的是一个枚举的值（如下），属性的意思就是自动调整子控件与父控件中间的位置，宽高。123456789enum &#123; UIViewAutoresizingNone = 0, UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0, UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1, UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2, UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3, UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4, UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5&#125;; UIViewAutoresizingNone就是不自动调整。UIViewAutoresizingFlexibleLeftMargin 自动调整与superView左边的距离，保证与superView右边的距离不变。UIViewAutoresizingFlexibleRightMargin 自动调整与superView的右边距离，保证与superView左边的距离不变。UIViewAutoresizingFlexibleTopMargin 自动调整与superView顶部的距离，保证与superView底部的距离不变。UIViewAutoresizingFlexibleBottomMargin 自动调整与superView底部的距离，也就是说，与superView顶部的距离不变。UIViewAutoresizingFlexibleWidth 自动调整自己的宽度，保证与superView左边和右边的距离不变。UIViewAutoresizingFlexibleHeight 自动调整自己的高度，保证与superView顶部和底部的距离不变。UIViewAutoresizingFlexibleLeftMargin |UIViewAutoresizingFlexibleRightMargin 自动调整与superView左边的距离，保证与左边的距离和右边的距离和原来距左边和右边的距离的比例不变。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"PendulemView","date":"2014-04-08T05:03:45.000Z","path":"2014/04/08/PendulemView/","text":"PendulemView 123pendulum = [[PendulumView alloc] initWithFrame:self.view.bounds ballColor:ballColor ballDiameter:35]; pendulum.hidesWhenStopped = NO; [self.view addSubview:pendulum];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"SONFillAnimation","date":"2014-04-01T05:02:43.000Z","path":"2014/04/01/SONFillAnimation/","text":"SONFillAnimation是将一个UIView以指定网格动画显示的类。 用法123456SONFillAnimation *animation = [[SONFillAnimation alloc] initWithNumberOfRows:3 columns:3 animationType:SONFillAnimationTypeDefault];animation.direction = SONFillAnimationDirectionLeftToRightAndTopDown;animation.duration = 0.3;animation.xDelay = 0.1;animation.yDelay = 0.2;[animation animateView:view completion:^&#123;&#125;]; numberOfRows指行数，numberOfColumns指列数xDelay指横向网格之间延迟的属性，yDelay指纵向网格之间延迟的属性anchorPoint指定每个网格的锚点direction指定顺序方向 您可以指定以下其中一个方向： SONFillAnimationDirectionLeftToRightAndTopDown SONFillAnimationDirectionLeftToRightAndBottomUp SONFillAnimationDirectionRightToLeftAndTopDown SONFillAnimationDirectionRightToLeftAndBottomUp SONFillAnimationDirectionRandom animationType是一个属性，表示一个类型的动画。 您可以指定在以下的animationType： SONFillAnimationTypeDefault SONFillAnimationTypeFoldOut SONFillAnimationTypeFoldIn SONFillAnimationTypeCustom setRotationVector:::是定义为FoldIn/折页动画旋转向量的方法。如果动画类型是自定义的，就不需要设置这个值。默认值是（0，-1,0）。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"AVOS Cloud","date":"2014-04-01T05:02:01.000Z","path":"2014/04/01/AVOS-Cloud/","text":"在Podfile中添加1pod &apos;AVOSCloud&apos; 使用UI相关的相关功能，就添加1pod &apos;AVOSCloundUI&apos; SNS组件的相关功能，就添加1pod &apos;AVOSCloundSNS&apos; 在AppDelegate.m文件，添加下列导入语句到头部1# import &lt;AVOSClound/AVOSCloud.h&gt;; 在application:didFinishLaunchingWithOptions函数内添加1[AVOSClound setApplicationId:@&quot;&quot; clientKey:@&quot;&quot;]; 要跟踪应用的打开情况，添加下列代码1[AVAnalytics trackAppOpenedWithLaunchOptions:launchOptions]; 对象AVObject 在AVOS Cloud上，数据存储是围绕AVObject进行的。每个AVObject都包含了与JSON兼容的key-value对应的数据。数据是schema-free的，不需要在每个AVObject上提前制定存在哪些键，只要直接设定对应的key-value即可。key必须是字母数字或下划线组成的字符串，自定义的键不能以__开头。值可以是字符串、数字、布尔值、甚至是数组和字典。注意：在iOS SDK中，uuid是保留字段，不能作为key来使用。 保存对象12345AVObject *gameScore = [AVObject objectWithClassName:@&quot;GameScore&quot;];[gameScore setObject:[NSNumber numberWithInt:1337] forKey:@&quot;score&quot;];[gameScore setObject:@&quot;Steve&quot; forKey:@&quot;playerName&quot;];[gameScore setObject:[NSNumber numberWithBool:NO] forKey:@&quot;cheatMode&quot;];[gameScore save];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"分辨率适配","date":"2014-04-01T03:33:46.000Z","path":"2014/04/01/分辨率适配/","text":"setDesignResolutionSize(with,height,resolutionPolicy)适配模式： EXACT_FIT 游戏所有内容全部拉伸，内容铺满 NO_BORDER 一个方向上铺满屏幕 SHOW_ALL 保证设计区域全部显示，但是可能会有黑边 FIXED_WIDTH 保证设计分辨率的宽度不变，根据屏幕分辨率修正设计分辨率的高度 FIXED_HEIGHT 保证设计分辨率的高度不变，根据屏幕分辨率修正设计分辨率的宽度","tags":[{"name":"分辨率","slug":"分辨率","permalink":"http://seniorzhai.github.io/tags/分辨率/"}]},{"title":"NSUserDefaults","date":"2014-03-31T05:01:31.000Z","path":"2014/03/31/NSUserDefaults/","text":"NSUserDefaults类提供了一个与默认系统进行交互的编程接口。 使用创建一个user defaults1NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults]; 添加数据1[userDefaults setObject:nameField.text forKey:UserDefayltNameKey]; 也可以是基本数据类型int、float、bool等，有相应的方法1[userDefaults setBool:YES forKey:UserDefaultBoolKey]; 读取数据12[userDefaults objectForKey:UserDefaultNameKey];[userDefaults boolForKey:UserDefaultBoolKey]; 注：NSUserDefaults非常好用，并不需要用户在程序中设置NSUserDefaults的全局变量，需要在哪里使用NSUserDefaults的数据，那么就在哪里创建一个NSUserDefaults对象，然后进行读或者写操作。针对同一个关键字对应的对象或者数据，可以对它进行重写，重写之后关键字就对应新的对象或者数据，旧的对象或者数据会被自动清理。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Cocos2d-X 坐标系详解","date":"2014-03-31T03:32:49.000Z","path":"2014/03/31/Cocos2d-X-坐标系详解/","text":"Cocos2d-x坐标系和Open GL坐标系相同，都是起源于笛卡尔坐标系。 笛卡尔坐标系笛卡尔坐标系中定义右手系原点在左下角，x向右，y向上，z向外 屏幕坐标系和Cocos2d坐标系iOS、Android、Windows Phone在开发应用时使用的是标准屏幕坐标系，原点为屏幕左上角，x向右，y向下。 世界坐标系(World Coordinate)和本地坐标系(Node Local)世界坐标系也叫绝对坐标系，是游戏开发中建立的概念，因此，“世界”指游戏世界。Cocos2d中的元素是由父子关系的层级结构，我们通过Node的setPosition设定元素的位置使用的就是相对与父类节点的本地坐标系而非世界坐标系。 本地坐标系也叫相对坐标系，是和节点相关联的坐标系。每个节点都有独立的坐标系，当节点移动或改变方向时，和该节点关联的坐标系将随之移动或改变方向。 锚点(Anchor Point) Anchor Point的两个参数都在0~1之间。它们表示的并不是像素点，而是乘数因子。(0.5, 0.5)表示Anchor Point位于节点长度乘0.5和宽度乘0.5的地方，即节点的中心 在Cocos2d-x中Layer的Anchor Point为默认值(0, 0)，其他Node的默认值为(0.5, 0.5)。我们用以下代码为例，使用默认Anchor Point值，将红色层放在屏幕左下角，绿色层添加到红色层上： 1234auto red = LayerColor::create(Color4B(255,100,100,128),visibleSize.width/2,visibleSize.height/2);auto green = LayerColor::create(Color4B(100,255,100,128),visibleSize.width/4,visibleSize.height/4);red-&gt;addChild(greeen);this-&gt;addChild(red,0); 我们用以下代码为例，将红色层的Anchor Point设为中点放在屏幕中央，绿色层添加到红色层上，绿色层锚点为右上角： 注：因为Layer比较特殊，它默认忽略锚点，所以要调用ignoreAnchorPointForPosition()接口来改变锚点，关于ignoreAnchorPointForPosition()接口的使用说明，我们将在后面详细讲解。1234567891011auto red = LayerColor::create(Color4B(255, 100, 100, 128), visibleSize.width/2, visibleSize.height/2);red-&gt;ignoreAnchorPointForPosition(false);red-&gt;setAnchorPoint(Point(0.5, 0.5));red-&gt;setPosition(Point(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y)); auto green = LayerColor::create(Color4B(100, 255, 100, 128), visibleSize.width/4, visibleSize.height/4);green-&gt;ignoreAnchorPointForPosition(false);green-&gt;setAnchorPoint(Point(1, 1));red-&gt;addChild(green); this-&gt;addChild(red, 0); 忽略锚点(Ignore Anchor Point)Ignore Anchor Point全称是ignoreAnchorPointForPosition，作用是将锚点固定在一个地方。 如果设置其值为true，则图片资源的Anchor Pont固定为左下角，否则即为所设置的位置。 我们用以下代码为例，将两个层的ignoreAnchorPointForPosition设为true，并将绿色的层添加到红色的层上：12345678910auto red = LayerColor::create(Color4B(255, 100, 100, 128), visibleSize.width/2, visibleSize.height/2);red-&gt;ignoreAnchorPointForPosition(true);red-&gt;setPosition(Point(visibleSize.width/2 + origin.x, visibleSize.height/2 + origin.y)); auto green = LayerColor::create(Color4B(100, 255, 100, 128), visibleSize.width/4, visibleSize.height/4);green-&gt;ignoreAnchorPointForPosition(true); red-&gt;addChild(green); this-&gt;addChild(red, 0); VertexZ，PositionZ和zOrder VerextZ是OpenGL坐标系中的Z值 PositionZ是Cocos2d-x坐标系中Z值 zOrder是Cocos2d-x本地坐标系中Z值在实际开发中我们只需关注zOrder。 可以通过setPositionZ接口来设置PositionZ。 以下是setPositionZ接口的说明：1Sets the &apos;z&apos; coordinate in the position. It is the OpenGL Z vertex value. 即PositionZ的值即为opengl的z值VertexZ。同样节点的PositionZ也是决定了该节点的渲染顺序，值越大，但是与zOrder不同的区别在于，PositionZ是全局渲染顺序即在根节点上的渲染顺序，而zOrder则是局部渲染顺序，即该节点在其父节点上的渲染顺序，与Node的层级有关。用以下事例来说明:1234567891011auto red = LayerColor::create(Color4B(255, 100, 100, 255), visibleSize.width/2, visibleSize.height/2); red-&gt;ignoreAnchorPointForPosition(false); red-&gt;setPosition(Point(visibleSize.width / 2, visibleSize.height / 2)); auto green = LayerColor::create(Color4B(100, 255, 100, 255), visibleSize.width/4, visibleSize.height/4); green-&gt;ignoreAnchorPointForPosition(false); green-&gt;setPosition(Point(visibleSize.width / 2, visibleSize.height / 2 - 100)); red-&gt;setPositionZ(1); green-&gt;setPositionZ(0); this-&gt;addChild(red, 0); this-&gt;addChild(green, 1); 触摸点(Touch position)在处理触摸事件时需要重写以下四个函数：1234virtual bool onTouchBegan(Touch *touch,Event *event);virtual void onTouchEnded(Touch *touch,Event *event);virtual void onTouchCancel(Touch *touch,Event *event);virtual void onTouchMoved(Touch *touch,Event *event); 在函数中获取到touch，在设计游戏逻辑时需要用到触摸点在Cocos2d坐标系中的位置，就需要将touch的坐标转换成OpenGL坐标系中的点坐标。 Touch position是屏幕坐标系中的点，OpenGL postion是cocos2d-x用到OpenGL坐标系上的点坐标，通常我们在开发中会使用两个接口getLocation()和getLocationInView()来进行相应坐标转换工作。 在开发中一班使用getLocation()获取触摸点的GL坐标，而getLocationo()内部实现是通过Director::getInstance()-&gt;convertToGL(_point);返回GL坐标。 此外，关于世界坐标系和本地坐标系的互相转换，在Node中定义了以下四个常用的坐标转换的相关方法。12345678// 把基于当前节点的本地坐标系下的坐标转换到世界坐标系中Point convertToNodeSpace(const Point&amp; worldPoint) const;// 把世界坐标转换到当前节点的本地坐标系中Point convertToWorldSpace(const Point&amp; nodePoint) const;// 基于Anchor Point把基于当前节点的本地坐标系下的坐标转换到Point convertToNodeSpaceAR(const Point&amp; worldPoint) const;// 基于Anchor Point把世界坐标转换到当前节点的本地坐标系中Point convertToWorldSpaceAr(const Point&amp; nodePoint) const; 例子：12345678910111213141516auto *sprite1 = Sprite::create(\"HelloWorld.png\");sprite1-&gt;setPosistion(ccp(20,40));sprite1-&gt;setAnchorPoint(ccp(0,0));this-&gt;addChild(sprite1);// 此时添加到的是世界坐标系，也就是OpenGL坐标系auto *sprite2 = Sprite::create(\"HelloWorld\");sprite2-&gt;setPosition(ccp(-5,-20));sprite2-&gt;setAnchorPoint(ccp(1,1));this-&gt;addChild(sprite2);// 此时添加到的是世界坐标系，也就是OpenGL坐标系//将sprite2这个节点的坐标ccp(5,-20)转换成sprite1节点下的本地坐标系统的位置坐标Point point1 = sprite1-&gt;convertToNodeSpace(sprite1-&gt;getPosition());Point point2 = sprite-&gt;convertToWorldSpce(sprite2-&gt;getPosition());// 将sprite2这个节点的坐标ccp(5,-20)转换成sprite1节点下的世界坐标系统的位置坐标log(\"postion = (%f,%f)\",point1.x,point1.y);log(\"postion = (%f,%f)\",point2.x,point2.y); 其中:Point point1 = sprite1-&gt;convertToNodeSpace(sprite2-&gt;getPosition()); 相当于sprite2这个节点添加到（实际没有添加，只是这样理解）sprite1这个节点上，那么就需要使用sprite1这个节点的节点坐标系统，这个节点的节点坐标系统的原点在（20，40），而sprite1的坐标是（-5，-20），那么经过变换之后，sprite1的坐标就是（-25，-60）。 其中:Point point2 = sprite1-&gt;convertToWorldSpace(sprite2-&gt;getPosition()); 此时的变换是将sprite2的坐标转换到sprite1的世界坐标系下，而其中世界坐标系是没有变化的，始终都是和OpenGL等同，只不过sprite2在变换的时候将sprite1作为了”参照“而已。所以变换之后sprite2的坐标为:（15，20）。","tags":[{"name":"坐标系","slug":"坐标系","permalink":"http://seniorzhai.github.io/tags/坐标系/"}]},{"title":"AFNetworking","date":"2014-03-26T05:00:34.000Z","path":"2014/03/26/AFNetworking/","text":"AFNetworking是一个非常流行的网络库，适用于iOS以及Mac OS X，具有良好的架构，丰富的api，以及模块化化构建方式，使得使用起来非常轻松。 使用CocoaPods安装Podfile12platform :ios, &apos;7.0&apos;pod &quot;AFNetworking&quot;, &quot;~&gt; 2.0&quot; 环境要求Xcode 5、iOS 6.0及以上、Mac OS 10.8以上 用法AFHTTPRequestOperationManagerAFHTTPRequestOperationManager封装了Web应用程式HTTP通信的功能，包括编辑请求、响应序列化、网络可达性监控和安全系，以及请求管理的常见模式。 GET请求123456AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];[manager GET:@&quot;http://example.com/resources.json&quot; parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@&quot;JSON: %@&quot;, responseObject);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@&quot;Error: %@&quot;, error);&#125;]; POST请求1234567AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];NSDictionary *parameters = @&#123;@&quot;foo&quot;:@&quot;bar&quot;&#125;;[manager GET:@&quot;http://example.com/resources.json&quot; parameters:nil success:^(AFHTTPRequestOperation *operation, id responseObject) &#123; NSLog(@&quot;JSON: %@&quot;, responseObject);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123; NSLog(@&quot;Error: %@&quot;, error);&#125;]; POST多部分请求12345678910AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];NSDictionary *parameters = @&#123;@&quot;foo&quot;:@&quot;bar&quot;&#125;;NSURL *filePath = [NSURL fileURLWithPath:@&quot;file://path/to/image.png&quot;];[manager POST:@&quot;http://example.com/resources.json&quot; parameters:parametes construtingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData)&#123; [formData appendPartWithFileUrl:filePath name:@&quot;image&quot; error:nil];&#125; success:^(AFHTTPRequestOperation *operation,id responseObject)&#123; NSLog(@&quot;Success:%@&quot;,responseObject);&#125;failure:^(AFHTTPRequestOperation *operation,NSError *error))&#123; NSLog(@&quot;Error:%@&quot;,error);&#125;]; AFURLSessionManagerAFURLSessionManager根据指定的NSURLSessionConfiguration对象创建、管理NSURLSession，实现了&lt;NSURLSessionTaskDelegate&gt;，&lt;NSURLSessionDataDelegate&gt;，&lt;NSURLSessionDownloadDelegate&gt;和&lt;NSURLSessionDelegate&gt;委托。 创建下载任务12345678910111213NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/download.zip&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) &#123; NSURL *documentsDirectoryPath = [NSURL fileURLWithPath:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]]; return [documentsDirectoryPath URLByAppendingPathComponent:[response suggestedFilename]];&#125; completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) &#123; NSLog(@&quot;File downloaded to: %@&quot;, filePath);&#125;];[downloadTask resume]; 创建上传任务123456789101112131415NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/upload&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURL *filePath = [NSURL fileURLWithPath:@&quot;file://path/to/image.png&quot;];NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@&quot;Error: %@&quot;, error); &#125; else &#123; NSLog(@&quot;Success: %@ %@&quot;, response, responseObject); &#125;&#125;];[uploadTask resume]; 创建上传任务多任务请求1234567891011121314NSMutableURLRequest *requst = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@&quot;POST&quot; URLString:@&quot;http://example.com/upload&quot; parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123; [formData appendPartWithFileURL:[NSURL fileURLWithPath:@&quot;file://path/to/image.jpg&quot;] name:@&quot;file&quot; fileName:@&quot;filename.jpg&quot; mimeType:@&quot;image/jpeg&quot; error:nil];&#125;error:nil];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfigguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSProgress *progress = nil;NSURLSessionUploadTask *uploadTask = [Manager uploadTaskWithStreamedRequest:request progress:&amp;progress completionHandler:^(NSURLResponse *response,id responseObject,NSError *error)&#123; if(error)&#123; NSLog(@&quot;Error:%@&quot;,error); &#125;else&#123; NSLog(@&quot;%@,%@&quot;,response,responseObject); &#125;&#125;];[uploadTask resume]; 创建数据任务123456789101112131415NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@&quot;http://example.com/upload&quot;];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@&quot;Error: %@&quot;, error); &#125; else &#123; NSLog(@&quot;%@ %@&quot;, response, responseObject); &#125;&#125;];[dataTask resume];[ dataTask 简历]; 请求序列化创建序列化URL字符串12NSString * URLString = @&quot;http://example.com&quot;;NSDictionary * parmeters = @&#123;@&quot;foo&quot;:@&quot;bar&quot;,@&quot;baz&quot;:@[@1,@2,@3]&#125;; 查询参数列表1[[AFHTTPRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:URLString parameters:parameters]; POST http://example.com/ Content-Type: application/x-www-form-urlencoded foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3 JSON参数1[[AFJSONRequestSerializer serializer] requestWithMethod:@&quot;POST&quot; URLString:URLString parameters:parameters]; POST http://example.com/ Content-Type: application/json {&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [1,2,3]} 网络可达性管理AFNetworkReachabilityManager监控网络的可达性。123[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@&quot;Reachability: %@&quot;, AFStringFromNetworkReachabilityStatus(status));&#125;]; 可达URL的主机12345678910111213141516NSURL *baseURL = [NSURL URLWithString:@&quot;http://example.com/&quot;];AFHTTPRequestOperationManager *manager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:baseURL];NSOperationQueue *operationQueue = manager.operationQueue;[manager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; switch (status) &#123; case AFNetworkReachabilityStatusReachableViaWWAN: case AFNetworkReachabilityStatusReachableViaWiFi: [operationQueue setSuspended:NO]; break; case AFNetworkReachabilityStatusNotReachable: default: [operationQueue setSuspended:YES]; break; &#125;&#125;];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"一个简单的数据缓存类","date":"2014-03-24T04:59:56.000Z","path":"2014/03/24/一个简单的数据缓存类/","text":"这个类只有三个类方法+ (void) resetCache、+ (void) setObject:(NSData *)data forKey:(NSString *)key、+ (id) objectForKey:(NSString *)keyresetCache：清空当前的缓存setObject:(NSData *)data forKey:(NSString *)key：根据Key保存data到缓存中objectForKey:(NSString *)key：根据Key从缓存中获取data 方法实现首先我们需要实现一个方法，该方法用于返回缓存的完整目录核心的代码为NSArray* paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);用于获取沙盒内的缓存目录1234567+ (NSString *) cacheDirectory &#123;NSArray* paths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString* cacheDirectory = [paths objectAtIndex:0]; // 添加目录后缀 cacheDirectory = [cacheDirectory stringByAppendingPathComponent:@&quot;ZTCaches&quot;]; return cacheDirectory;&#125; 清空缓存也相对容易，只要把该目录的文件删除即可123+ (void) resetCache &#123; [[NSFileManager defaultManager] removeItemAtPath:[ZTCache cacheDirectory] error:nil];&#125; 根据Key将data存入缓存1234567891011121314151617+ (void) setObject:(NSData *)data forKey:(NSString *)key&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; NSString *filename = [self.cacheDirectory stringByAppendingPathComponent:key]; BOOL isDir = YES; // 如果缓存目录不存在需要创建缓存目录 if (![fileManager fileExistsAtPath:self.cacheDirectory isDirectory:&amp;isDir]) &#123; // 创建目录 [fileManager createDirectoryAtPath:self.cacheDirectory withIntermediateDirectories:NO attributes:nil error:nil]; &#125; NSError *error; @try &#123; [data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]; &#125; @catch (NSException *exception) &#123; // &#125;&#125; 根据Key从缓存中获取data12345678910111213141516171819+ (NSData *) objectForKey:(NSString *)key&#123; NSFileManager* fileManager = [NSFileManager defaultManager]; // 根据目录和Key创建一个完整的fileName NSString* filename = [self.cacheDirectory stringByAppendingPathComponent:key]; // 判断文件是否存在 if ([fileManager fileExistsAtPath:filename]) &#123; // 获取文件属性Dic，并取其中的最后修改时间属性 NSDate *modificationDate = [[fileManager attributesOfItemAtPath:filename error:nil] objectForKey:NSFileModificationDate]; // 如果最后修改时间与现在时间大于7天，删除文件 if ([modificationDate timeIntervalSinceNow] &gt; cacheTime) &#123; [fileManager removeItemAtPath:filename error:nil]; &#125;else&#123; // 从文件中读取data NSData *data = [NSData dataWithContentsOfFile:filename]; return data; &#125; &#125; return nil;&#125; 使用缓存类根据实际需要，调用获取缓存，URL用MD5进行加工变为短连接123456789101112131415161718192021- (void) loadImageFromURL:(NSString*)URL &#123; NSURL *imageURL = [NSURL URLWithString:URL]; NSString *key = [URL MD5Hash]; NSData *data = [ZTCache objectForKey:key]; // 如果存在将data传入imageView，否则添加一个异步任务 if (data) &#123; UIImage *image = [UIImage imageWithData:data]; _imageView.image = image; &#125; else &#123; _imageView.image = [UIImage imageNamed:@&quot;img_def&quot;]; dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0ul); dispatch_async(queue, ^&#123; NSData *data = [NSData dataWithContentsOfURL:imageURL]; [ZTCache setObject:data forKey:key]; UIImage *image = [UIImage imageWithData:data]; dispatch_sync(dispatch_get_main_queue(), ^&#123; _imageView.image = image; &#125;); &#125;); &#125;&#125; String+MD5实现如下123456789101112131415161718192021- (NSString *) MD5Hash &#123; CC_MD5_CTX md5; CC_MD5_Init (&amp;md5); CC_MD5_Update (&amp;md5, [self UTF8String], (CC_LONG)[self length]); unsigned char digest[CC_MD5_DIGEST_LENGTH]; CC_MD5_Final (digest, &amp;md5); NSString *s = [NSString stringWithFormat: @&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;, digest[0], digest[1], digest[2], digest[3], digest[4], digest[5], digest[6], digest[7], digest[8], digest[9], digest[10], digest[11], digest[12], digest[13], digest[14], digest[15]]; return s; &#125; 示例","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Android ADB常用命令","date":"2014-03-21T12:17:28.000Z","path":"2014/03/21/Android-ADB常用命令/","text":"查看已连接的设备1adb devices 会列出连接设备的ID，使用adb -s DEVICE_ID可以指定特定的设备 安装应用使用install命令来安装apk，如果设备上已经安装了应用，可以使用可选参数-r重新进行安装并保留所有数据1adb install -r APK_FILE 卸载应用1adb uninstall PACKAGE_NAME 启动Activity1adb shell am strat PACKAGE_NAME/ACTIVITY_IN_PACKAGE 进入设备命令行1adb shell 截取屏幕1adb shell screencap -p | perl -pe &apos;s/\\x0D\\x0A/\\x0A/g&apos; &gt; screen.png 解锁屏幕1adb shell input keyevent 82 日志用来在命令行中显示日志流1adb logcat 按标签过滤1adb logcat -s TAG_NAME1 TAH_NAME2 按优先级过滤123adb logcat &quot;*:PRIORITY&quot;# exampleadb logcat &quot;*:W&quot; 优先级设置如下： V:Verbose(最低优先级) D:Debug I:Info W:Warning E:Error F:Fatal S:Slient(最高优先级，在这个级别上不会打印任何信息) 按优先级和标签名过滤1adb logcat -s TAG_NAME_1:PRIORITY TAG_NAME_2:PRIORITY 使用grep过滤12adb logcat | grep &quot;SEARCH_TERM&quot;adb logcat | grep &quot;SEARCH_TERM_1\\|SEARCH_TERM_2&quot; 清楚logcat缓冲区1adb logcat -c","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Collection Views","date":"2014-03-21T04:59:00.000Z","path":"2014/03/21/Collection-Views/","text":"什么是UICollectionViewUICollectionView是一种新的数据展示方式，简单来说可以把他理解成多列的UITableView。比如iBooks，一个虚拟的书架上放着各类图书，排列整齐，亦或者iPad的iOS6中的原生时钟中的各个时钟，也是UICollectionView的最简单的一个布局。 最简单的UICollectionView就是一个GirdView，可以以多列的方式来将数据进行展示，标准的UICollection包含三个部分： Cells用于展示内容的主体，对于不同的cell可以指定不同尺寸和不同的内容 Supplementary Views追加视图，用来标记每个section的view Decoration Views装饰视图，每个section的背景 实现一个简单的UICollectionView和UITableView一样，UICollectionView同样采用datasource和delegate设计模式：datasource为View提供数据源，告诉View要实现什么及如何显示它们，delegate提供一些样式的小细节以及用户交互的相应。 UICollectionViewDataSource (NSInteger)collectionView:(UICollectionView *)view numberOfItemsInSection:(NSInteger)section:section的数量 (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section:某个section里有多少个item (UICollectionViewCell )collectionView:(UICollectionView )collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath:指定显示什么样的cell 实现了以上三个委托方法，基本上就可以保证CollectionView工作正常，同时还通过了Supplementary View方法 (UICollectionReusableView )collectionView:(UICollectionView )collectionView viewForSupplementaryElementOfKind:(NSString )kind atIndexPath:(NSIndexPath )indexPath 用于重用在UICollectionView中在请求数据源之前要注册CellView、SupplementaryView，可以通过以下方法进行注册-registerClass:forCellWithReuseIdentifier:-registerClass:forSupplementaryViewOfKind:withReuseIdentifier:-registerNib:forCellWithReuseIdentifier:-registerNib:forSupplementaryViewOfKind:withReuseIdentifier: UICollectionViewDelegate负责交互 cell的高亮 cell的选中状态 可以支持长按后的菜单用户点击cell的时候，现在会按照以下流程向delegate进行询问： collectionView:shouldHighlightItemAtIndexPath:是否应该高亮？ collectionView:didHighlightItemAtIndexPath:如果1回答是，那么高亮 collectionView:shouldSelectItemAtIndexPath:无论1结果如何，都询问是否可以被选中？ collectionView:didUnhighlightItemAtIndexPath:如果1回答是否，那么取消高亮 collectionView:didSelectItemAtIndexPath:如果3回答为是，那么选中cell 对应的高亮和选中状态分别由highlighted和selected两个属性表示。 关于cellUICollectionViewCell相比UITableViewCell没有太多的花头，首先不存在格式各样的默认的style。UICollectionViewCell结构上相对比较简单，由下至上： cell本身作为容器View 一个大小自动适应整个cell的backgroundView，用于cell默认的背景 selectedBackgroundView，是cell被选中时的背景 contentView，自定义内容应被加载这个View上。 UICollectionViewLayout负责各个cell、Supplementary View和Decoration Views进行组织，为了它们设定各自的属性，包括但不限于：位置、尺寸、透明度、层级关系、形状、等等… Layout决定了UICollectionView是如何显示在界面上的。在展示之前，一般需要生成合适的UICollectionViewLayout子类对象，并将其赋予CollectionView的collectionViewLayout属性。 默认常用的Layout是UICollectionViewFlowLayout，是一个直线对齐的Layout。 itemSize，定义了每一个item的大小。通过设定itemSize可以全局改变所有cell的尺寸，如果想要对某个cell定制尺寸，可以使用-collectionView:layout:sizeForItemAtIndexPath:方法。 间隔 指定每个item之间的间隔和每一行之间的间隔，和size类似，有全局属性，也可以对每一个item和每一个section做出设定： @property (CGSize) minimumInteritemSpacing @property (CGSize) minimumLineSpacing -collectionView:layout:minimumInteritemSpacingForSectionAtIndex: -collectionView:layout:minimumLineSpacingForSectionAtIndex: 滚动方向 由属性scrollDirection确定scroll View的方向，将影响Flow Layout的基本方向和由header及footer确定的section之间的宽度 UICollectionViewScrollDirectionVertical UICollectionViewScrollDirectionHorizontal Header和Footer尺寸 分为全局和部分，需要注意根据滚动方向不同，header和footer的高和宽中只有一个和会起作用，垂直滚动时section间宽度为该迟钝的高，而水平滚动时为宽度起作用 @property (CGSize) headerReferenceSize @property (CGSize) footerReferenceSize -collectionView:layout:referenceSizeForHeaderInSection: -collectionView:layout:referenceSizeForFooterInSection: 缩进 @property UIEdgeInsets sectionInset; -collectionView:layout:insetForSectionAtIndex:自定义UICollectionViewLayout 总结一个UICollectionView的实现包括两个必要部分：UICollectionViewDataSource和UICollectionViewLayout，和一个交互部分：UICollectionViewDelegate。而Apple给出的UICollectionViewFlowLayout已经是一个很强力的layout方案了。 UICollectionViewLayoutAttributesproperty列表： @property (nonatomic) CGRect frame @property (nonatomic) CGPoint center @property (nonatomic) CGSize size @property (nonatomic) CATransform3D transform3D @property (nonatomic) CGFloat alpha @property (nonatomic) NSInteger zIndex @property (nonatomic, getter=isHidden) BOOL hidden UICollectionViewLayoutAttributes的实例中包含了诸如边框，中心点，大小，形状，透明度，层次关系和是否隐藏等信息。当UICollectionView在获取布局时将针对每一个indexPath的部件（包括cell，追加视图和装饰视图），向其上的UICollectionViewLayout实例询问该部件的布局信息。这个布局信息，就以UICollectionViewLayoutAttributes的实例的方式给出。 UICollectionViewLayoutUICollectionViewLayout的功能为向UICollectionView提供布局信息，不仅包括cell的布局信息，也包括追加视图和装饰视图的布局信息。实现一个自定义layou的常规做法是继承UICollectionViewLayout类，然后重载下列方法。 (CGSize)collectioonViewContentSize 返回collctionView的内容尺寸 (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect 返回rect中的所有的元素的布局属性 返回的包括UICollectionViewLayoutAttributes的NSArray UICollctionViewLayoutAttributes可以是cell，追加视图或装饰视图的信息，通过不同的UICollectionViewLayoutAttributes初始化方法可以得到不同类型的UICollctionViewLayoutAttributes ayoutAttributesForCellWithIndexPath: layoutAttributesForSupplementaryViewOfKind:withIndexPath: layoutAttributesForDecorationViewOfKind:withIndexPath: (UICollectionViewLayoutAttributes )layoutAttributesForItemAtIndexPath:(NSIndexPath )indexPath 返回对应indexPath位置的cell布局属性 (UICollectionViewLayoutAttributes )layoutAttributesForDecorationViewOfKind:(NSString )decorationViewKind atIndexPath:(NSIndexPath *)indexPath 返回对应indexPath位置的追加视图的布局属性，如果没有追加视图可以不重载 (UICollectionViewLayoutAttributes )layoutAttributesForDecorationViewOfKind:(NSString )decorationViewKind atIndexPath:(NSIndexPath *)indexPath 返回对应于indexPath的位置的装饰视图的布局属性，如果没有装饰视图可不重载 (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds 当边界发生改变时，是否应该刷新布局。 在初始化一个UICollectionViewLayout实例后，会有一系列的准备方法被自动调用，以保证layout实例的正确 -(void)prepareLayout，默认下该方法是每都不做，但是在自己的子类实现中，一般在该方法中设定一些必要的layout的结构和初始需要的参数等。 -(CGSize)collectionViewContentSize，以确定collection应该占据的尺寸，注意这里的尺寸不是指可使部分的尺寸，而是所有内容所占的尺寸。 -(NSArray *)layoutAttributesForElementsInRect:(Rect)rect被调用，初始的layout外观将由该方法返回的UICollctionViewLayoutAttributes来决定。 另外，在需要更新layout时，需要给当前layout发送 -invalidateLayout，该消息会立即返回，并且预约在下一个loop的时候刷新当前layout。在-invalidateLayout后的下一个collectionView的刷新loop中，又会从prepareLayout开始，依次再调用-collectionViewContentSize和-layoutAttributesForElementsInRect来生成更新后的布局。 LineLayout——对于个别UICollectionViewLayoutAttributes的调整1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// LinrLayout.m# import &quot;LineLayout.h&quot;# define ITEM_SIZE 200.0# define ACTIVE_DISTANCE 200# define ZOOM_FACTOR 0.4@implementation LineLayout-(id)init&#123; self = [super init]; if (self) &#123; self.itemSize = CGSizeMake(ITEM_SIZE, ITEM_SIZE); self.scrollDirection = UICollectionViewScrollDirectionHorizontal; // 确定了缩进，此处为上方、下方各缩进200 self.sectionInset = UIEdgeInsetsMake(ITEM_SIZE, ITEM_SIZE/2, ITEM_SIZE, ITEM_SIZE/2); // 每个item在水平方向的最小间距 self.minimumLineSpacing = ITEM_SIZE/4; &#125; return self;&#125;// 边界改变时是否重新排版- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)oldBounds&#123; return YES;&#125;// 初始的layout外观将由该方法返回的UICollctionViewLayoutAttributes来决定-(NSArray*)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSArray* array = [super layoutAttributesForElementsInRect:rect]; CGRect visibleRect; visibleRect.origin = self.collectionView.contentOffset; visibleRect.size = self.collectionView.bounds.size; for (UICollectionViewLayoutAttributes* attributes in array) &#123; if (CGRectIntersectsRect(attributes.frame, rect)) &#123; CGFloat distance = CGRectGetMidX(visibleRect) - attributes.center.x; CGFloat normalizedDistance = distance / ACTIVE_DISTANCE; if (ABS(distance) &lt; ACTIVE_DISTANCE) &#123; CGFloat zoom = 1 + ZOOM_FACTOR*(1 - ABS(normalizedDistance)); attributes.transform3D = CATransform3DMakeScale(zoom, zoom, 1.0); attributes.zIndex = 1; &#125; &#125; &#125; return array;&#125;// 自动对齐到网格- (CGPoint)targetContentOffsetForProposedContentOffset:(CGPoint)proposedContentOffset withScrollingVelocity:(CGPoint)velocity&#123; // proposedContentOffset是没有对齐到网格时本来应该停下来的位置 CGFloat offsetAdjustment = MAXFLOAT; CGFloat horizontalCenter = proposedContentOffset.x + (CGRectGetWidth(self.collectionView.bounds) / 2.0); // 当前显示的区域 CGRect targetRect = CGRectMake(proposedContentOffset.x, 0.0, self.collectionView.bounds.size.width, self.collectionView.bounds.size.height); // 取当前显示的item NSArray* array = [super layoutAttributesForElementsInRect:targetRect]; // 对当前屏幕中的UICollectionViewLayoutAttributes逐个与屏幕中心进行比较，找出最接近中心的一个 for (UICollectionViewLayoutAttributes* layoutAttributes in array) &#123; CGFloat itemHorizontalCenter = layoutAttributes.center.x; if (ABS(itemHorizontalCenter - horizontalCenter) &lt; ABS(offsetAdjustment)) &#123; offsetAdjustment = itemHorizontalCenter - horizontalCenter; &#125; &#125; return CGPointMake(proposedContentOffset.x + offsetAdjustment, proposedContentOffset.y);&#125;@end 例子 CircleLayout——完全自定义的Layout，添加删除item，以及手势识别12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# import &quot;CircleLayout.h&quot;# define ITEM_SIZE 70@implementation CircleLayout// 准备计算需要的参数-(void)prepareLayout&#123; [super prepareLayout]; CGSize size = self.collectionView.frame.size; _cellCount = [[self collectionView] numberOfItemsInSection:0]; // 中心点 _center = CGPointMake(size.width / 2.0, size.height / 2.0); // 半径 _radius = MIN(size.width, size.height) / 2.5;&#125;// collctionView的内容大小就是collectionView的大小-(CGSize)collectionViewContentSize&#123; return [self collectionView].frame.size;&#125;// 通过所在的indexPath确定位置- (UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)path&#123; UICollectionViewLayoutAttributes* attributes = [UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:path]; attributes.size = CGSizeMake(ITEM_SIZE, ITEM_SIZE); // 配置attributes到圆周上 attributes.center = CGPointMake(_center.x + _radius * cosf(2 * path.item * M_PI / _cellCount), _center.y + _radius * sinf(2 * path.item * M_PI / _cellCount)); return attributes;&#125;// 用来在一开始给出一套UICollectionViewLayoutAttributes-(NSArray*)layoutAttributesForElementsInRect:(CGRect)rect&#123; NSMutableArray* attributes = [NSMutableArray array]; for (NSInteger i=0 ; i &lt; self.cellCount; i++) &#123; // NSIndexPath* indexPath = [NSIndexPath indexPathForItem:i inSection:0]; [attributes addObject:[self layoutAttributesForItemAtIndexPath:indexPath]]; &#125; return attributes;&#125;// 插入前，cell在圆心位置，全透明- (UICollectionViewLayoutAttributes *)initialLayoutAttributesForInsertedItemAtIndexPath:(NSIndexPath *)itemIndexPath&#123; UICollectionViewLayoutAttributes* attributes = [self layoutAttributesForItemAtIndexPath:itemIndexPath]; attributes.alpha = 0.0; attributes.center = CGPointMake(_center.x, _center.y); return attributes;&#125;// 删除时，cell在圆心位置，全透明，且只有原来的1/10大- (UICollectionViewLayoutAttributes *)finalLayoutAttributesForDeletedItemAtIndexPath:(NSIndexPath *)itemIndexPath&#123; UICollectionViewLayoutAttributes* attributes = [self layoutAttributesForItemAtIndexPath:itemIndexPath]; attributes.alpha = 0.0; attributes.center = CGPointMake(_center.x, _center.y); attributes.transform3D = CATransform3DMakeScale(0.1, 0.1, 1.0); return attributes;&#125;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# import &quot;ViewController.h&quot;# import &quot;Cell.h&quot;@implementation ViewController-(void)viewDidLoad&#123; self.cellCount = 20; // 添加一个手势识别 UITapGestureRecognizer* tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapGesture:)]; [self.collectionView addGestureRecognizer:tapRecognizer]; [self.collectionView registerClass:[Cell class] forCellWithReuseIdentifier:@&quot;MY_CELL&quot;]; [self.collectionView reloadData]; self.collectionView.backgroundColor = [UIColor greenColor];&#125;- (NSInteger)collectionView:(UICollectionView *)view numberOfItemsInSection:(NSInteger)section;&#123; return self.cellCount;&#125;- (UICollectionViewCell *)collectionView:(UICollectionView *)cv cellForItemAtIndexPath:(NSIndexPath *)indexPath;&#123; Cell *cell = [cv dequeueReusableCellWithReuseIdentifier:@&quot;MY_CELL&quot; forIndexPath:indexPath]; return cell;&#125;- (void)handleTapGesture:(UITapGestureRecognizer *)sender &#123; if (sender.state == UIGestureRecognizerStateEnded) &#123; CGPoint initialPinchPoint = [sender locationInView:self.collectionView]; NSIndexPath* tappedCellPath = [self.collectionView indexPathForItemAtPoint:initialPinchPoint]; // 点击处没有cell if (tappedCellPath!=nil) &#123; self.cellCount = self.cellCount - 1; [self.collectionView performBatchUpdates:^&#123; [self.collectionView deleteItemsAtIndexPaths:[NSArray arrayWithObject:tappedCellPath]]; &#125; completion:nil]; &#125; else &#123; self.cellCount = self.cellCount + 1; [self.collectionView performBatchUpdates:^&#123; [self.collectionView insertItemsAtIndexPaths:[NSArray arrayWithObject:[NSIndexPath indexPathForItem:0 inSection:0]]]; &#125; completion:nil]; &#125; &#125;&#125;@end 例子","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"KVO","date":"2014-03-20T04:57:05.000Z","path":"2014/03/20/KVO/","text":"KVO(Key-Value Observing)，Objective-C提供的一种机制，当制定的对象被修改时，对象就会接受到通知。 使用捕捉 注册，制定被观察者的属性 实现回调方法 移除观察 KVO涉及到的主要方法：1234// 三个参数分别是监听对象、监听属性、监听选项- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;// 删除监听器，监听的对象、监听的属性- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@implementation ViewController&#123; UILabel *_name; UILabel *_age; UIButton *_b1; UIButton *_b2;&#125;- (void)viewDidLoad&#123; [super viewDidLoad]; _myData= [[MyData alloc] init]; [_myData setValue:@&quot;name&quot; forKey:@&quot;name&quot;]; [_myData setValue:@&quot;22&quot; forKey:@&quot;age&quot;]; [_myData addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL]; [_myData addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:NULL]; CGSize size = self.view.bounds.size; _name = [[UILabel alloc]initWithFrame:CGRectMake(size.width/2 - 75, 100, 150, 30 )]; _name.textColor = [UIColor redColor]; _name.text = [_myData valueForKey:@&quot;name&quot;]; _name.textAlignment = NSTextAlignmentCenter; [self.view addSubview:_name]; _age = [[UILabel alloc]initWithFrame:CGRectMake(size.width/2 - 50, 140, 100, 30 )]; _age.textColor = [UIColor redColor]; _age.text = [[NSString alloc]initWithFormat:@&quot;%@&quot;,[_myData valueForKey:@&quot;age&quot;]]; _age.textAlignment = NSTextAlignmentCenter; [self.view addSubview:_age]; _b1 = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [_b1 setTitle:@&quot;Push&quot; forState:UIControlStateNormal]; _b1.frame = CGRectMake(size.width/2 - 50, size.height/2 + 100, 100, 30); [_b1 addTarget:self action:@selector(buttonAction1) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:_b1]; _b2 = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [_b2 setTitle:@&quot;Push&quot; forState:UIControlStateNormal]; _b2.frame = CGRectMake(size.width/2 - 50, size.height/2 + 140, 100, 30); [_b2 addTarget:self action:@selector(buttonAction2) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:_b2];&#125;-(void) buttonAction1&#123; unsigned int random = arc4random_uniform(999); _myData.name = [[NSString alloc]initWithFormat:@&quot;随机数字:%d&quot;,random];&#125;-(void) buttonAction2&#123; unsigned int age = arc4random_uniform(100); _myData.age = age;&#125;-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context&#123; if([keyPath isEqualToString:@&quot;age&quot;]) &#123; _age.text = [[NSString alloc]initWithFormat:@&quot;%@&quot;,[_myData valueForKey:@&quot;age&quot;]]; &#125; else if([keyPath isEqualToString:@&quot;name&quot;]) &#123; _name.text = _myData.name; &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Objective-C中随机数的用法","date":"2014-03-20T04:55:07.000Z","path":"2014/03/20/Objective-C中随机数的用法/","text":"arcrandom() 12// 获取1到x之间的整数的代码如下:int value = (arc4random() % x) + 1; random() 12// 需要初始化时设置种子srandom((unsigned int)time(time_t *)NULL); //初始化时，设置下种子就好了。 CCRANDOM_0_1() 123// cocos2d中使用 ，范围是[0,1]// [0,5] CCRANDOM_0_1() 取值范围是[0,1]float random = CCRANDOM_0_1() * 5; arc4random_uniform 推介使用12// 返回一个小于number的均匀分布的整数arc4random_uniform(number) 还存在其他一些arc4随机函数，详情查看","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Shimmer","date":"2014-03-20T04:54:24.000Z","path":"2014/03/20/Shimmer/","text":"shimmer是Facebook旗下应用Paper开源的加载效果，显示为一个闪闪发光的Label。 安装使用Cocoapods来安装FBShimmering库 命令行里运行pod search Shimmer 将上面的pod &#39;Shimmer&#39;, &#39;~&gt; 1.0.1&#39;copy，在你的工程下创建Podfile文件，并写入 123platform :ios, &apos;7.0&apos;pod &apos;Shimmer&apos;, &apos;~&gt; 1.0.1&apos; 在命令行切换到你的工程目录，运行pod install 用法创建一个FBShimmeringView或FBShimmeringLayer，添加您的内容。要开启闪烁，就设置shimmering属性为YES。例子：12345678910FBShimmeringView * shimmeringView = [[ FBShimmeringView alloc ] initWithFrame : self.view.bounds ]; [ self.view addSubview : shimmeringView ];UILabel * loadingLabel = [[ UILabel alloc ] initWithFrame : shimmeringView.bounds ]; loadingLabel.textAlignment = NSTextAlignmentCenter ; loadingLabel.text = NSLocalizedString ( @&quot;Shimmer&quot; , nil ); shimmeringView.contentView = loadingLabel ;/ /开始闪闪发光shimmeringView.shimmering = YES ; 示例链接示例：","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"使用Cocosd-console创建运行工程","date":"2014-03-19T03:31:51.000Z","path":"2014/03/19/使用Cocosd-console创建运行工程/","text":"运行环境 Android2.3及以上版本 iOS 5.0及以上版本 OS X 10.7及以上版本 Windows 7及以上版本 Ubuntu 12.04及以上版本 Cocos2d-X v3.0rc 软件需求 Xcode 4.6 gcc 4.7 Visual Studio 2012 Python 2.7.5 创建新工程切换到cocos的根目录1cocos new MyGame -p com.zoe.MyGame -l cpp -d ./MyProject MyGame:指定工程名 - p com.zoe.MyGame:指定Android的包名 -l cpp:指定项目的语言，可用cpp或者lua -d ./MyProject:指定存放目录成的项目的文件夹结构如下：编译运行新工程 1cocos run -s ./MyProject/MyGame -p ios -s:指定工程目录，必须是绝对目录且有效的 -p:选着运行平台，可选项有ios,android,win32,mac,linux","tags":[{"name":"console","slug":"console","permalink":"http://seniorzhai.github.io/tags/console/"}]},{"title":"Cocos2d-X V3.0 如何在Android上运行Cpp-tests","date":"2014-03-18T03:30:15.000Z","path":"2014/03/18/Cocos2d-X-V30-如何在Android上运行Cpp-tests/","text":"环境要求Mac OSX Cocos2d-x首先，要先下载好Cocos2d-x，并解压到你要放的位置。打开Cocos2D-X文件夹你应该看到如下的情况: JDK，SKD和NDK下载Java,安装后，通过java -version进行验证 下载SDK,NDK解压到你存放的位置 Python和antPython作为Mac的一等公民，Macbook上是默认自带了的。可以通过python --version验证：12-&gt; python --versionPython 2.7.5 如果没有安装可以通过brew install python进行安装如果brew也没有，可以到brew官网按照指定命令安装 之后我们还需要安装ant1brew install ant 通过ant -version进行验证12ant -versionApache Ant(TM) version 1.9.3 compiled on December 23 2013 初始化环境切换到./cocos2d-x的目录下（根据实际存放的位置）执行.\\setup.py或者python setup.py运行设置脚本根据提示分别填写NSK、SDK、ant的路径（根据实际存放位置，ant可以通过which ant命令查看位置） 最后，执行下面的命令完成设置1source ~/.bash_profile 编译切换到cocos2d-x的build目录下执行下面命令1python android-build.py -p 10 cpp-test","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"},{"name":"Cocos2d-X","slug":"Cocos2d-X","permalink":"http://seniorzhai.github.io/tags/Cocos2d-X/"},{"name":"Demo","slug":"Demo","permalink":"http://seniorzhai.github.io/tags/Demo/"}]},{"title":"Cocos2d-X V3.0 如何在iOS上运行Cpp-tests","date":"2014-03-18T03:29:08.000Z","path":"2014/03/18/Cocos2d-X-V30-如何在iOS上运行Cpp-tests/","text":"环境要求 Mac OS X 10.8以上版本 iOS 5.0及以上版本 Xcode 4.6.2及以上版本 运行 进入cocos2d-x/build双击运行cocos2d_tests.xcodeproj 选择cpp-tests iOS和模拟器 点击run运行cpp-tests 运行中 点击stop退出模拟器","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"},{"name":"Cocos2d-X","slug":"Cocos2d-X","permalink":"http://seniorzhai.github.io/tags/Cocos2d-X/"},{"name":"Demo","slug":"Demo","permalink":"http://seniorzhai.github.io/tags/Demo/"}]},{"title":"Android异步加载图片并缓存到本地软引用","date":"2014-03-13T05:16:45.000Z","path":"2014/03/13/Android异步加载图片并缓存到本地软引用/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362// FileCache.javaimport java.io.File;import android.content.Context;public class FileCache&#123; private FileCacheDir; public FileCache(Context context)&#123; if(android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED)) cacheDir = new File(android.os.Environmet.getExternalStrorageDirectory(),\"文件夹名称\"); else cacheDir = context.getCacheDir(); if(!cacheDir.exsts()) cache.mkdirs(); &#125; public File getFile(String url)&#123; String fileName = String.valueOf(url.hashCode()); File file = new File(cacheDir,fileName); return file; &#125; public void clear()&#123; File[] files = cacheDir.listFiles(); if(files == null) return; for(File file:files) &#123; file.delete(); &#125; &#125;&#125;// HttpUtil.javaimport java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileNotFoudException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.UnsupportedEncodingException;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.ProtocolException;import java.net.URL;import java.net.URLEncoder;import java.util.Map;/** * Http请求工具类 */ public class HttpUtil&#123; public static String getResponseStr(String path,Map&lt;String,String&gt;parameters)&#123; StringBuffer buffer = new StringBuffer(); URL url; try&#123; if(parameters!=null&amp;&amp;parameters.isEmpty())&#123; for(Map.Entry&lt;String,String&gt;entry:parameters.entrySet())&#123; buffer.append(entry.getKey()).append(\"=\").append(URLEncoder.encode(entry.getValue(),\"UTF-8\")).append(\"&amp;\"); &#125; buffer.deleteCharAt(buffer.length()-1); &#125; url = new URL(path); HttpURLConnection urlConnection = (HttpURLConnection)url.openConnection(); urlConnection.setConnectTimeout(3000); urlConnection.SetRequesMethod(\"POST\"); urlConnection.SetDoInput(true); urlConnection.SetDoOutput(true); // byte[] mydata = buffer.toString().getBytes(); urlConnection.setRequesProperty(\"Content-Type\",\"application.x-www-form-urlencoded\"); urlConnection.setRequesProperty(\"Content-Length\",String.valueOf(mydata.length)); // 获取输出流，向服务器输出数据 OutputStream outputStream = urlConnection.getOutputStream(); outputStream.write(mydata,0,mydata.length()); outputStream.close(); int responseCode = urlConnection.getResponseCode(); if(responseCode == 200)&#123; return changeInuptstream(urlConnection.getInputStream()); &#125;catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125;catch(MalformedURLException e)&#123; e.printStackTrace(); &#125;catch(ProtocolException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; retun null; &#125; private static String changeInputStream(InputStream inputStream)&#123; ByteArrayOutpoutStream outputStream = new ByteArrayOutputStream(); byte[] data = new byte[1024]; int len = 0; String result = \"\"; if(inputStream != null)&#123; try&#123; while((len = inputStream.read(data)) != -1)&#123; outputStream.write(data,0,len); &#125; result = new String(outputStream.toByteArray(),\"UTF-8\"); &#125;catch(IOException)&#123; e.printStacckTrace(); &#125; &#125; return result; &#125; public static InputStream getInputStream(String path)&#123; URL url; try&#123; url = new URL(path); HttpURLConnection urlConnection = (HttpURLConnection)url.open.Connection(); urlConnecation.setConnectTimeout(3000); urlConnecation.setRequestMethod(\"GET\"); urlConnecation.setDoInput(true); urlConnecation.connect(); if(urlConnection.getResponseCode == 200) return urlConnection.getInputStream(); &#125;catch(MalformedURLException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;catch(Exception e)&#123; e.printStacjTrace(); &#125; return null; &#125; public satatic byte[] readStream(InputStream inStream)throwsException&#123; ByteArrayOutputStream outSteam = newByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = -1; while((len = inStream.read(buffer)) != -1)&#123; outStream.write(buffer,0,len); &#125; outStream.close(); inStream.close(); return outStream.toByteArray(); &#125; public static void copyStream(String url,File f)&#123; FileOutputStream fileOutputStream = null; InputStream inputStream = null; try&#123; inputStream = getInputStream(url); byte[] data = new byte[1024]; int len = 0; fileOutputStream = new FileOutputStream(f); while((len = inputStream.read(data)) != -1)&#123; fileOutputStream.write(data,0,len); &#125; &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125;finally&#123; if(inputStream != null)&#123; try&#123; inputStream.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;// MemoryCache.javaimport java.lang.ref.SoftReference;import java.util.Collections;import jave.util.HashMap;import java.util.Map;import android.graphics.Bitmap;public class MemoryCache&#123; private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cache = Collections.sycnchronizedMap(newHashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;());//软引用 public Bitmapget(String id)&#123; if(!cache.containsKey(id)) return null; SoftReference&lt;Bitmap&gt; ref = cache.get(id); return ref.get(); &#125; public void put(String id,Bitmap bitmap)&#123; cache.put(id,newSoftReferce&lt;Bitmap&gt;(bitmap)); &#125; public void clear()&#123; cache.clear(); &#125;&#125;// ImageLoader.javaimport java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.UnsupportedEncodingException;import java.io.net.URLEncoder;import java.io.util.Collections;import java.util.Map;import java.util.WeakHashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import android.app.Activity;import android.content.Context;import android.graphics.Bitmap;import android.grapgics.BitmapFactory;import android.grapgics.drawable.BitmapDrawable;import android.widget.ImageView;public class ImageLoader&#123; private MemoryCachemoryCache = new MemoryCache(); private FileCache fileCache; private Map&lt;ImageView,String&gt; imageViews = Collections.synchronizedMap(new WeakHashMap&lt;ImageView,String&gt;()); private ExecutorService executorService; private boolean isSrc; public ImageLoader(Context context,boolean flag)&#123; fileCache = new FileCache(context); executorService = Executors.newFixedThreadPool(5); isSrc = flag; &#125; final int stub_id = R.drawable.ic_launcher; public void DisplayImage(String url,ImageView imageView)&#123; String u1 = url.substring(0,url.lastIndexOf(\"/\")+1); String u2 = url.substring(url,lastIndexOf(\"/\")+1); try&#123; u2 = URLEncoder.encode(u2,\"UTF-8\"); &#125;catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; url = u1 +u2; imageViews.put(imageView,rul); Bitmap bitmap = memoryCache.get(url); if(bitmap != null)&#123; if(isSrc) imageView.setImageBitmap(bitmap); else imageView.setBackgroundDrawable(new BitmapDrawable(bitmap)); &#125;else&#123; queuePhoto(url,imageView); if(isSrc) imageView.setImageResouce(stub_id); else imageView.setBackgroundResource(stub_id); &#125; &#125; private void ququePhoto(String url,ImageView imageView)&#123; PhotoToLoad p = new PhotoToLoad(url,imageView); executoService.submit(new PhotoSLoader(p)); &#125; private Bitmap getBitmap(String url)&#123; try&#123; File f = filCache.getFile(url); // SD卡 Bitmap b = onDecodeFile(f); if(b != null) return b; // 从网络 Bitmap bitmap = null; Sysytem.out.println(\"ImageLoader--&gt;download\"); HttpUtil.CopyStream(url,f); bitmap = onDecoderFile(f); return bitmap; &#125;catch(Exception e)&#123; e.printStackTrace(); return null; &#125; &#125; public Bitmap onDecodeFile(File f)&#123; try&#123; return BitmapFactory.decodeStream(new FileInputStream(f)); &#125;catch(FileNotFoundException e)&#123; e.printStackTrace(); &#125; return null; &#125; // 解码图像用来减少内存消耗 public Bitmap decodeFile(File f)&#123; try&#123; // 解码图像大小 BitmapFactory.Options o = new BitmapFactory.Options(); o.inJustDecodeBounds = true; BitmapFactory.decodeStream(new FileInputStream(f),null,o); // 找到正确的刻度值，它应该是2的幂 final int REQUIRED_SIZE = 70; int width_tmp = o.outWidth,height_tmp = o.outHeight; int scale = 1; while(true)&#123; if(width_tmp/2 &lt; REQUIRED_SIZE || height_tmp/2 &lt; REQUIRED_SIZE) break; width_tmp /= 2; height_tmp /= 2; scale *= 2; &#125; BitmapFactory.Options o2 = new BitmapFactory.Options(); o2.inSampleSize = scale; return BitmapFactory.decodeStream(new FileInputStream(f),null,o2); &#125;catch(FileNotFoundException e)&#123; &#125; return null; &#125; // 任务队列 private class PhotToLoad&#123; public String url; public ImageView imageView; public PhotoToLoad(String u,ImageView i)&#123; url = u; imageView = i; &#125; &#125; class PhotosLoader implementsRunnable&#123; PhotoToLoad photoToLoad; PhotoLoader(PhotoToLoad photoToLoad)&#123; this.photoToLoad = photoToLoad; &#125; @Override public void run()&#123; if(imageViewReused(photoToLoad)) return; Bitmap bmp = getBitMap(photoToLoad.url); memoryCache.put(photoToLoade.url.bmp); if(imageViewReused(photoToLoade)) return; BitmapDisplayer bd = new BitmapDisplayer(bmp,photoToLoad); Activity a = (Activity)photoToLoad.imageView.getContext(); a.runOnUiThread(bd); &#125; &#125; boolean imageViewReused(PhotoToLoade photoToLoad)&#123; String tag = imageViews.get(photoToLoad.imageView); if(tag == null ||!tag.equals(pgotoToLoad.url)) return true; return false; &#125; // 在UI线程显示位图 class BitmapDisplayer implements Runnable&#123; Bitmap bitmap; PhotoToLoad photoToLoad; public BitmapDisplayer(Bitmap b,PhotoToLoad p)&#123; bitmap = b; photoToLoad = p; &#125; public void run()&#123; if(imageViewReused(photoToLoad)) return; if(bitmap != unll)&#123; if(isSrc) photoToLoad.imageView.setImageResouce(stub_id); else photoToLoad.imageView.setBackgroundDrawable(new BitmapDrawable(bitmao)); &#125;else&#123; if(isSrc) photoToLoad.imageView.setImageResouce(stub_id); else photoToLoad.imageView.setBackgroundDrawable(new BitmapDrawable(bitmao)); &#125; &#125; &#125; public void clearCache()&#123; memoryCache.clear(); fileCache.clear(); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"Xcode插件管理大师Alcartraz","date":"2014-03-12T04:52:59.000Z","path":"2014/03/12/Xcode插件管理大师Alcartraz/","text":"简介Alcartraz是一个帮助你管理Xcode插件、模板以及颜色配置的工具，集成在Xcode的图形界面中。 安装与卸载安装命令12mkdir -p ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins;curl -L http://git.io/lOQWeA | tar xvz -C ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins 卸载命令12rm -rf ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcpluginrm -rf ~/Library/Application\\ Support/Alcatraz 使用安装成功后重启Xcode，就可以在Xcode的顶部菜单中找到Alcatraz，如下所示：点击“Package Manager”，即可启动插件列表页面，如下所示之后你可以在右上角搜索插件，对于想安装的插件，点击其左边的图标，即可下载安装，如下所示，我正在安装KImageNamed插件：安装完成后，再次点击插件左边的图标，可以将该插件删除。 插件路径Xcode所有的插件都安装在目录~/Library/Application Support/Developer/Shared/Xcode/Plug-ins/下，你也可以手工切换到这个目录来删除插件。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"NSURLSession","date":"2014-03-09T04:51:59.000Z","path":"2014/03/09/NSURLSession/","text":"NSURLSession是iOS7中新的网络接口，它与NSURLConnection是并列的，程序在前台时，NSURLSession与NSURLConnection可以互为替代工作，注意，如果用户强制将小横须关闭，NSURLSession会断掉。 NSURLSession的功能： 通过URL将数据下载到内存 通过URL将数据下载到文件系统 将数据上传到指定URL 在后台完成上述功能 工作流程1.创建一个NSURLSessionConfiguration，用于第二部创建NSSession时设置工作模式和网络设置，工作模式分为： 一般模式（default）：工作模式类似于NSURLConnection，可以使用缓存的Cache，Cookie，鉴权 及时模式（ephemeral）：不使用缓存的Cache，Cookie，鉴权 后台模式（background）：在后台完成下载，创建Configuration对象的时候需要给一个NSString的ID用于跟踪完成工作的Session是哪一个网络设置：参靠NSURLConnection中的设置项。 创建一个NSURLSession。系统提供了两个创建方法 sessionWithConfiguration: sessionWithConfiguration:delegate:delegateQueue: 第一个粒度较低就是根据刚才创建的Configuration创建一个Session，系统默认创建一个新的OperationQueue处理Session的消息。 第二个粒度比较高，可以设定回调的delegate（注意这个回调delegate会被强引用），并且可以设定delegate在哪个OperationQueue回调，如果我们将其设置为[NSOperationQueue mainQueue]就能在主线程进行回调非常的方便。 创建一个NSURLRequest调用刚才的NSURLSession对象提供的Task函数，创建NSURLSessionTask 根据智能不同Task有三个子类： NSURLSessionUploadTask:上传用的Task，传完以后不会再下载返回结果； NSURLSessionDownloadTask:下载用的Task； NSURLSessionDataTask:可以上传内容，上传完成后再进行下载; 得到的Task，调用resume开始工作 如果是细粒度的Session调用，Session与Delegate会在指定的OperationQueue中进行交互，以下载例子，交互的顺序图如下（假设不需要鉴权，即非HTTPS请求）： 当不再需要连接调用Session的invaildateAndCancel直接关闭，或者调用finishTasksAndInvalidate等待当前Task结束后关闭。这时Delegate会收到URLSession:didBeComeInvaliWithErro:这个事件。Delegge收到这个事件之后会被解引用。 如果是一个BackgroundSession，在Task执行的时候，用户切到后台，Session会和ApplicationDelegate做交互，当程序切到后台后，在BackgroundSession中的Task还会继续下载 1）当加入了多个Task，程序没有切换到后台这种情况Task会按照NSURLSessionConfiguration设置正常下载，不和和ApplicationDelegate有交互。 2）当加入了多个Task，程序切换到后台，所有Task都完成下载。在切换到后台之后，Session的Delegate的application:handleEventForBackgroundURLSession:completionHandler:回调，之后“汇报”下载工作，对于每一个后台下载的Task调用Session的Delegate中的URLSession:downloadTask:didFinishDownloadingToURL:（成功的话）和URLSession:task:didCompleteWithError:(成功或者失败都会调用)之后调用Session的Delegate回调URLSessionDidFinishEventsForBackgroundURLSession 注意：在ApplicationDelegate被唤醒后，会有个参数ComplietionHandler，这个参数是个Block，这个参数要在后面Session的Delegate中didFinish的时候调用一下，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@implementation APLAppDelegate - (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)())completionHandler &#123; BLog(); /* Store the completion handler. The completion handler is invoked by the view controller&apos;s checkForAllDownloadsHavingCompleted method (if all the download tasks have been completed). */ self.backgroundSessionCompletionHandler = completionHandler; &#125; //…… @end //Session的Delegate @implementation APLViewController - (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session &#123; APLAppDelegate *appDelegate = (APLAppDelegate *)[[UIApplication sharedApplication] delegate]; if (appDelegate.backgroundSessionCompletionHandler) &#123; void (^completionHandler)() = appDelegate.backgroundSessionCompletionHandler; appDelegate.backgroundSessionCompletionHandler = nil; completionHandler(); &#125; NSLog(@&quot;All tasks are finished&quot;); &#125; @end 3）当加入了多个Task，程序切换到后台，下载完成了几个Task，然后用户又切换到前台。（程序没有退出） 切换到后台之后，Session的Delegate仍然收不到消息，在下载完成几个Task之后再切换到前台，系统会先汇报已经下载完成的Task的情况，然后继续下载没有下载完成的Task。 4）当加入了多个Task，程序切到后台，几个Task已经完成，但还有Task还没有下载完的时候关掉退出程序然后再进入程序的时候。（程序退出了）","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Objective-C块语法","date":"2014-03-08T04:51:07.000Z","path":"2014/03/08/Objective-C块语法/","text":"块语法与其他变量类似，不同的是，代码块存储的数据是一个函数体。使用代码块时，可以想调用其他标准函数一样，传入参数，并得到返回值 脱字符(^)是块的语法标记，按照参数语法定义返回值以及快主题按照调用函数待方式调用块对象变量就可以了：int result = myBlock(4)// result = 28 例子 参数是NSString*的代码块 123456void (^printBlock)(NSString *x)printBlock = ^(NSString* str)&#123; NSLog(@&quot;print:%@&quot;,str);&#125;printBlock(@&quot;hello world&quot;); 代码用在字符串数组排序 1234567NSArray *stringArray = [NSArray arrayWithObjects:@&quot;abc 1&quot;,@&quot;abc2&quot;,@&quot;abc 3&quot;,@&quot;abc 4&quot;,nil];NSCompartor sortBlock = ^(id string2,id string2)&#123; return [string1 compare:string2];&#125;NSArray *sortArray = [stringArray sortedArrayUsingComparator:sortBlock];NSLog(@&quot;sortArray:%@&quot;,sortArray); 代码快的递归调用 12345678static void(^ const blocks)(int) = ^(int)&#123; if(i &gt; 0)&#123; NSLog(@&quot;num:%d&quot;,i); blocks(i - 1); &#125; &#125;;blocks(3); 在代码块中使用局部变量和全局变量 1234567891011121314int global = 1000;int main(int argc,const char * argv[])&#123; @autoreleasepool&#123; void(^block)(void) = ^(void) &#123; global++; NSLog(@&quot;global:%d&quot;,global); &#125; block(); NSLog(@&quot;global:%d&quot;,global); &#125; return 0;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"ReactiveCocoa框架","date":"2014-03-04T04:50:30.000Z","path":"2014/03/04/ReactiveCocoa框架/","text":"ReactiveCocoa是一款FRP（Functional Reactive Programming，响应式编程）框架，简称RAC。可以在GitHub上找到他。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Foundation框架(二)","date":"2014-03-04T04:49:18.000Z","path":"2014/03/04/Foundation框架(二)/","text":"Objective-C集合 大致可分为：NSArray、NSSet、NSDictionary三种体系，NSAarray代表有序、可重复的集合，NSSet代表无序、不可重复的集合，NSDictionary代表具有映射关系的集合。数组（NSArray和NSMutableArray） NSArray代表元素有序、可重复的一个集合，集合中每一个元素都有对应的顺序索引。-常用方法 array:创建一个不包含任何元素的空NSArray arrayWithContentsOfFile:/initWithContentsOfFile:读取文件内容来创建NSArray arrayWithObject:/initWithObject:创建只包含指定元素的NSArray arrayWithObjects:/initWithObjects:创建包含指定N个元素的NSArray objectAtIndex:根据索引返回元素 lastObject:最后一个元素 objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRnnge:NSMakeRange(2,3)] 从索引中2~5的元素组成新集合 indexOfObject:查找元素的位置 indexOfObject: inRange:查找指定范围内元素的位置 arrayByAddingObject: 追加元素 arrayByAddingObjectsFormArray:追加数组集合 writeToFile:写入文件","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Android安全","date":"2014-03-03T11:15:47.000Z","path":"2014/03/03/Android安全(一)/","text":"Android安全概述 安全主要解决4类需求： 保密(Security/Confidentiality 鉴别/认证(Authentication) 完整性(Integrity) 不可否认性(non-repudiation) 好的密码术应该是算法公开，密钥保密的。 对称加密概述 典型的加密模型 秘钥：分为加密秘钥和解密秘钥。 明文：文友进行机密，能够直接表带原文含义的信息。 密文：经过加密处理处理之后，隐藏原文含义的信息。 加密：将明文转换成密文的实施过程。 解密：将密文转换成明文的实施过程。 对称的含义（Symmetric） 加密和解密用同一套Key 置换加密、转置加密和乘积加密 置换加密,又称换位密码,是一个简单的换位，每个置换都可以用一个置换矩阵Ek来表示。每个置换都有一个与之对应的逆置换Dk。 DES AES 优点和缺点 高效 秘钥交换的问题 不如RSA的加密安全程度高，但当选择256bit的AES仍然能胜任大多数安全领域。 非对称加密 非对称加密的模型 公钥和私钥 RSA 建立在分解大树的困难度上，公钥/私钥长度至少1024bit 优点和缺点 安全性足够高 没有密钥交换的问题 效率低，对于大数据加密很慢常见场景 保密会话","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"动画","date":"2014-03-03T04:48:35.000Z","path":"2014/03/03/动画/","text":"CoreAnimation动画 CoreAnimation动画使用CALayer来创建用户界面，每个UIView上可以放置几百个CALayer，各个大小不同的CALayer叠加、组合在一起，各CALayer可以自由地控制它们的位置、大小和形状，这样就可以创建复杂的用户界面。 CoreAnimation床架动画不仅简单而且具有更好的性能，原因如下： CoreAnimation动画在单独的线程中完成，不会阻塞主线程。 CoreAnimation动画只重绘界面上的局部变化（局部刷新）。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Objective-C小知识","date":"2014-02-28T04:47:43.000Z","path":"2014/02/28/Objective-C小知识/","text":"Objective-C里面没有public和private的概念，你可以认为全是public。 NS代表NextStep，CF代表CoreFoudation，CG代表CoreGraphics,CA代表CoreAnimation，UI代表UserInterface id代表万能指针 BOOL本质上是char,NO代表false，YES代表true nil 就是NULL","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"Foundation框架(一)","date":"2014-02-28T04:46:48.000Z","path":"2014/02/28/Foundation框架(一)/","text":"字符串（NSString与NSMutableString） NSString代表字符串序列不可变的字符串，NSMutableString代表序列可变的字符串 NSString常用方法 1234567891011121314151617181920NSString *str = @&quot;This is a String!&quot;;//以字符串常量创建字符串NSString *str = [[NSString alloc] init];str = @&quot;This is a String!&quot;;//创建空字符串，赋值NSString *str = [[NSString alloc] initWithString:@&quot;This is a String!&quot;//初始化字符串char *Cstring = &quot;This is a String!&quot;NSString *str = [[NSString alloc] initWithCString:Cstring];//以标准c字符串初始化创建字符串NSString *str = [[NSString alloc] stringWithFormat:@&quot;%s is a String&quot;,&quot;This&quot;];//格式化创建字符串NSString *path = [[NSBundle mainBundle] pathForResouce:@&quot;text&quot; ofType:@&quot;txt&quot;];NSString *str = [[NSString alloc] initWithContentsOfFile:path];//从文件创建字符串[str writeToFile:path atomically:YES];//写入文件BOOL result = [str1 isEqualToString:str2];//判断相等与否str = [str stringByAppendingString:@&quot;iOS!&quot;];//追加字符串char* cstr = [str UTF8String];//获取字符串对应的C风格字符串[str length];//获取字符串长度[str lengthOfBytesUsingEncoding:NSUTF8StringEncoding];//str按UTF-8字符集解码后字节数[str substringToIndex:10];//获取str的前10个字符组成的字符串[str substringFromIndex:5];/获取从第5个字符串开始，与后面字符组成的字符串[str substringWithRange:NSMakeRange(5,15)];//获取str从第5个字符开始，到第15个字符组成的字符串[str rangeOfString:@&quot;ios&quot;];//返回ios在字符串中出现的位置[str uppercassString];//str所有字符转为大写 NSMutableString可改变序列 NSMutableString常用方法12345[str appendString:@&quot;,iOS&quot;];//追加固定字符串[str appendFormat:@&quot;%s is ios&quot;,@&quot;,iOS&quot;];//追加字符串[str insertString:@&quot;insert&quot; atIndex:6];//指定位置插入字符串[str deleteCharactersInRange:NSMakeRange(6,12)];//删除6到12位置的所有字符串[str replaceCharactersInRange:NSMakeRange(6,9) withString:@&quot;Objective-C&quot;];//替换6到9位置的字符串 日期与时间（NSDate） 常用方法 12345678910111213141516171819NSDate* date1 = [NSDate date];//获取代表当前日期、时间的NSDateNSDate* date2 = [[NSDate alloc] initWithTimeIntervalSinceNow:3600*24];//获取从当前时间开始3天之后的日期NSDate* date3 = [NSDate dateWithTimeIntervalSince1970:3600*24*366*20];//从1970年1月1日开始，20年之后的日期NSLocale* cn = [NSLocale currentLocale];//获取本地位置[dete1 descriptionWithLocal:cn];//过去NSDate在当前位置对应的字符串[date1 earlieDate:date2];//获取两个日期之间较早的日期[date laterDate:date2];//获取两个日期之间较晚的日期switch([date1 compare date2])&#123; case NSOrderedAscending: break; //date1在之前 case NSOrderedSame: break; //date1与date2日期相同 case NSOrderedDescending: break; //date1在之后&#125;[date1 timeIntervalSinceDate:date2];//时间差[date1 timeIntervalSinceNow];//与现在时间差 NSLocale待遇一个语言、国际环境 日期格式器（NSDateFormatter） NSDateFoematter代表一个日期格式器，用来完成NSDate与NSString之间的转换 创建一个NSDateFormatter对象 调用NSDateFormatter的setStyle:、setTimeStyle:方法设置格式化日期、时间的风格，日期、时间风格支持如下的枚举值： NSDateFormatterNoStyle:不显示日期、时间的风格 NSDateFormatterShortStyle:显示“短”的日期、时间风格 NSDateFormatterMediumStyle:显示“中等”的日期、时间风格 NSDateFormatterLongStyle:显示“长”的日期、时间风格 NSDateFormatterFullStyle:显示“完整”的日期、时间风格 NSDate转换成NSString可以调用NSDateFormatter的stringFromDate:方法执行格式化即可 NSString转换成NSDate可以调用NSDateFormatter的dateFromString:方法执行格式化即可1234// 自定义格式式模板NSDateFormatter* df = [[NSDateFormatter alloc]init];[df setDateFormatter:@&quot;公元yyyy年MM月DD日HH时mm分&quot;];NSLog(@&quot;%@&quot;,[df stringFromDate:date]); 日历（NSCalendar）与日期组件（NSDateComponents） NSCalender对象用于处理NSDate对象所包含的各个字段的数据 NSCalendar常用方法 (NSDateComponents*)components:fromDate:从NSDate提取年、月、日、时、分、秒各时间字段的信息。 dateFromComponents:(NSDateComponents*)comps:使用comps对象包含的年、月、日、时、分、秒各时间字段的信息来创建NSDate. 定时器（NSTimer） 调用NSTimer的scheduledTimerWithTimeInterval:invocation:repeats:或scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:类方法来创建NSTimer对象。 timerInterval:指定每个多少秒执行一次任务。 invocation或target与selector:指定重复执行的任务。如果指定target和selector参数，则指定用某个对象的特定方法作为重复执行的任务；如果指定invacation参数，该参数需要传入一个NSInvocation对象，其中NSInvocation对象也是封装target和selector的，其中也是指定用某个对象的特定方法作为重复执行的任务。 userInfo:该参数用于传入额外的附加信息。 repeats:该参数需要指定BOOL值，该参数控制是否需要重复执行任务。 为第一步的任务编写方法。 销毁定时器，调用定时器的invalidate方法即可。 对象复制 NSObject类提供了copy和mutableCopy方法，通过这两个方法即可复制已有对象的副本。 copy方法总是返回不可修改的副本，及时改对象本身是可修改的。 mutableCopy方法用于复制对象的可变副本，即便对象本事是不可修改的，如NSString，返回的是NSMutableString对象。 NSCopying与NSMutableCopy协议 为了保证自定义类能够使用copy、mutableCopy方法，需要做如下的事 让该类实现NSCopying（NSMutableCopying）协议 让该类实现copyWithZone:(mutableCopyWithZone:)方法1234567891011121314-(id)copyWithZone:(NSZone*)zone&#123; ZTApple apple= [[[self class] allocWithZone:zone]init]; ZTApple.color = self.color; ZTApple.weight = self.weight; return apple;&#125;// 如果父类已经实现了NSCopying协议，那么代码就可简化-(id)copyWithZone:(NSZone*)zone&#123; id obj = [super copy]; //... return obj;&#125; 浅复制(shallow copy)与深复制(deep copy) 当对象的实例变量是指针变量时，程序只是复制该指针的地址，而不是真正复制指针指向的对象，这种方式被称为“浅复制”，对浅复制而言，在内存中复制了两个对象，这两个对象的指针变量将会指向同一个对象，也就是两个对象存在公用的部分。 深复制不仅会复制对象本身，而且会“递归”复制每个指针类型的实例变量，直到两个对象没有任何公用的部分。 1234567-(id)copyWithZone:(NSZone*)zone&#123; ZTApple apple= [[[self class] allocWithZone:zone]init]; ZTApple.color = [self.color mutableCopy]; ZTApple.weight = self.weight; return apple;&#125; 一般来说，Foundation框架中的类大部分只实现了浅复制。 setter方法的copy选项 setter的copy只实现copy方法，得到的回事一个不可变的副本。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"NSBundle","date":"2014-02-27T04:45:49.000Z","path":"2014/02/27/NSBundle/","text":"NSBundle用来访问应用自包含的资源文件。 获取NSBundle对象，一般会调用该类的mainBundle方法。 URLForResource:withExtension:subdirectory:根据资源名、扩展名从指定子目录获取对用资源的URL URLForResource:withExtension:根据资源名、扩展名获取该资源对应的URL pathForResouce:ofType:根据资源名、类型名获取该资源对应的路径 URLsForResoucesWithExtension:subdirectory:获取指定子目录下匹配特定扩展名的所有资源对应的URL组成的数组 pathForResouces:ofType:inDirectory:从指定的子目录下，根据资源名,类型名获取该资源对应的路径 pathForResoucesOfType:inDirectory:获取指定子目录下，匹配特定类型名的所有资源对应的路径组成的数组 resoucePath:直接根据完整的资源路径来获取对应的资源12NSString* filePath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;txt&quot;];NSString* content = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"对象归档","date":"2014-02-27T04:45:09.000Z","path":"2014/02/27/对象归档/","text":"归档就是用户某种格式把一个或者多个对象保存到指定的文件中，方便以后从文件中恢复它们。 使用NSKeyedArchiver归档 NSKeyedArchiver负责将对象归档到指定文件中 NSKeyedUnarchiver则负责从文件中恢复对象 直接调用archivedDataWithRootObject:data、archiveRootObject:toFile:file类方法将指定对象作为root进行归档；恢复时，则调用NSKeyedUnarchiver的unarchiveObjectWithData:data或者unarchiveObjectWithFile:file类方法。 1234567// 归档NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:89],@&quot;objc&quot;, [NSNumber numberWithInt:88],@&quot;cpp&quot;, [NSNumber numberWithInt:87],@&quot;java&quot;, nil];[NSKeyedArchiver archiveRootObject:dict toFile:@&quot;myDict.archive&quot;]; 12345// 恢复NSDictionary* dict = [NSKeyedUnarchiver unarchiveObjectWithFile:@&quot;myDict.archive&quot;];NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;objc&quot;]);NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;cpp&quot;]);NSLog(&quot;%d&quot;,[dict valueForKey:@&quot;java&quot;]); 实现NSCoding协议 自定义类要实现归档、恢复，应该实现NSCoding协议，必须实现该协议中的定义的如下两个方法 initWithCoder:该方法负责恢复对象 encodeWithCoder:该方法负责归档对象 归档和恢复基本数据类型 归档数据 恢复数据 encodeBool:forKey decodeBoolForKey encodeInt:forKey decodeIntForKey encodeInt32:forKey decodeInt32ForKey encodeInt64:forKey decodeInt64ForKey encodeFloat:forKey decodeFloatForKey encodeDouble:forKey decodeDoubleForKey 示例 1234567# import &lt;Foundation/Foundation.h&gt;@interface ZTApple : NSObject &lt;NSCoding&gt;@property (nonatomic,copy) NSString* color;@property (nonatomic,assign)double weight;@property (nonatomic,assign)int size;- (id) initWithColor:(NSString*) color weight:(double) weight size:(int) size;@end 123456789101112131415161718192021222324252627282930313233# import &quot;ZTApple.h&quot;@implementation ZTApple@synthesize color = _color;@synthesize weight = _weight;@synthesize size = _size;-(id) initWithColor:(NSString*) color weight:(double) weight size:(int) size&#123; if(self = [super init]) &#123; self.color = color; self.weight = weight; self.size = size; &#125; return self;&#125; -(NSString *)description&#123; return [NSString stringWithFormat:&quot;@&lt;ZTApple[_color=%@,_weigt=%g,_size=%d]&gt;&quot;,self.color,self.weight,self.size];&#125;-(void) encodeWithCoder:(NSCode*) coder&#123; [coder encodeOject:_color forKey:@&quot;color&quot;]; [coder encodeDouble:_weight foeKey:@&quot;weight&quot;]; [coder encodeInt:_size forKey:@&quot;size&quot;];&#125;-(void) initWithCoder:(NSCoder*) coder&#123; _color = [coder decodeObjectForKey:@&quot;color&quot;]; _weight = [coder decodeDoubleForkey:@&quot;weight&quot;]; _size = [coder decodeIntForKey:@&quot;size&quot;]; return self;&#125;@end 使用NSData完成自定义归档 一次性收集多个对象，并将这些对象归档到单个文件中，此时借助NSMutableData来创建NSKeyedArchiver或NSKeyedUnarchiver对象。 归档过程 以NSMutableData作为参数，创建NSKeyedArchiver对象。 反复调用NSKeyedArchiver对象的encodeXxx:forKey:方法来归档所有需要归档到一个文件的对象。 调用NSKeyedArchiver对象的finishEncoding方法来结束归档。 根据需要，程序可以选择将保存归档数据的NSMutableData通过网络或输出到磁盘文件上。1234567891011121314151617NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:66],@&quot;objc&quot;, [NSNumber numberWithInt:76],@&quot;c++&quot;, [NSNumber numberWithInt:86],@&quot;java&quot;,nil];NSSet* set = [NSSet setWithObjects: @&quot;test1&quot;,@&quot;test2&quot;,@&quot;test3&quot;,nil];ZTApple* apple = [[ZTApple alloc] initWithColor:@&quot;红色&quot; weight:3.4 size:20];NSMutableData* data = [[NSMutableData data];NSKeyedArchiver* arch = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];[arch encodeObject:dict forKey:@&quot;dict&quot;];[arch encodeObject:set forKey:@&quot;set&quot;];[arch encodeObject:apple forKey:@&quot;apple&quot;];[arch finishEncoding];if([data writeToFile:@&quot;multi.archive&quot; atomically:YES] == NO)&#123; NSLog(&quot;归档失败&quot;);&#125; 恢复过程 以NSData作为参数，创建NSkeyedUnarchiver对象 重复调用NSKeyedUnarchiver对象的decodeXxx:forKey:方法从文件中恢复所有归档过的对象 调用NSKeyedUnarchiver对象的finishDecoding方法结束恢复123456NSData* data = [NSData dataWithContentsOfFile:@&quot;multi.archive&quot;];NSKeyedUnarchiver* unarch = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];NSDictionary* dict = [unarch decodeObjectForKey:@&quot;dict&quot;];NSSet* set = [unarch decodeObjectForKey:@&quot;set&quot;];NSApple* apple = [unarch decodeObjectForKey:@&quot;apple&quot;];[unarch finishDecoding];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"文件I/O","date":"2014-02-27T04:44:30.000Z","path":"2014/02/27/文件IO/","text":"NSData与NSMutableData 代表数据缓存区，作用有两个①对数据读取NSData、②输出NSData的数据 初始化方法(类方法以data开头，实例方法以init开头) data:：创建一个不包含任何数据的、空的NSData对象 dataWithBytes:length:/initWithBytesNoCopy:length:：复制C数组所包含的数据类初始化NSData的数据 dataWithBytesNoCopy:length:/initWithBytesNoCopy:length:：直接利用C数组所包含数据来初始化NSData对象。当该对象呗执行malloc方法销毁自己时，程序会释放该数组 dataWithBytesNoDopy:length:freeWhenDone:/initWithBytesNoCopy:length:freeWhenDone:：直接利用C数组所包含的数据来初始化NSData对象。只有当最后一个参数为YES，且该对象被执行malloc方法销毁自己时，程序才会释放该C数组 dataWithContentsOfFile:/initWithContentsOfFile:：直接读取文件内容，并利用文件内容来初始化NSData dataWithContentOfURL:/initWithContentOfURL:：直接读取URL关联的内容，并利用该URL关联的内容初始化NSData dataWithData:/initWithData:：直接使用另一个NSData所包含的数据来初始化先创建的NSData 常用方法 bytes:：获取该NSData所包含的数据 getBytes:length:：获取NSData所包含的指定长度的数据 getBytes:range:：获取NSData所包含的指定范围的数据 subdataWithRange:：获取NSData所包含的指定范围的数据组成的NSData对象 writeToFile:atomically:：将NSData的数据写入文件 writeToURL:atomically:：将NSData的数据写入URL对应的资源 NSFileManager NSFileManager代表文件管理器，可以执行文件的移动、复制、链接、删除文件或目录，同时提供一个配套的事件委托（NSFileManagerDelegate），确保文件操作后调用相对应的处理方法。文件名作为文件的唯一标识，可使用绝对路径或相对路径。 NSFileManager访问属性和内容提供如下方法： 方法名 说明 fileExistsAtPath: 判断指定文件名对应的文件是否存在 fileExistsAtPath:isDirectoy: 判断指定文件名对应的文件或者目录是否存在，最后一个参数可用于返回该文件名是否为目录 isReadableFileAtPath: 判断指定目录下的文件是否可读 isWritableFileAtPath: 判断指定目录下的文件是否可写 isExcutableFileAtPath: 判断指定目录下的文件是否可执行 isDeletableFileAtPath: 判断指定目录下的文件是否可删除 componentsToDisplayForPath: 获取指定文件名对应文件的各个路径组件 displayNameAtPath: 获取指定文件名对应文件的简单文件名 attributesOfItemAtPath:error: 获取指定文件名对应文件的属性 attributesOfFileSystemForPath:error: 获取指定文件名对应的文件所在文件系统的属性 setAttributes:ofItemAtPath:error: 设置指定文件名对应文件的属性 contentsAtPath: 获取指定文件名对应文件的内容 contentsEqualAtPath:andPath: 判断两个文件名指定的内容是否相同 NSFileManager为创建、删除、移动、复制文件或目录提供了如下方法 方法名 说明 createDirectoryAtURL:withIntermediateDirectories:attributes:error: 根据指定的URL创建目录 createDirectoryAtPath:withIntermediateDirectories:attributes:error: 根据指定的路径创建目录 createFileAtPath:contents:attributes: 根据指定的文件路径、内容创建文件 removeItemAtURL:error: 删除指定URL对应的文件 removeItemAtPath:error: 删除指定路径对应的文件 copyItemAtURL:toURL:error: 根据指定的URL复制文件或目录 copyItemAtPath:toPath:error: 根据指定的路径复制文件或目录 moveItemAtURL:toURL:error: 根据指定URL移动文件或目录 moveItemAtPath:toPath:error: 根据指定路径移动文件或目录 NSFileManager查看目录包含内容提供了如下方法 方法名 说明 contentsOfDirectoryAtPath:error: enumeratorAtPath: subpathsOf NSURL URL(Uniform Resource Locator)对象表示同意资源定位器，它是指向互联网“资源”的指针。通常情况下，URL由协议名、主机、端口和资源路径组成，格式如下： scheme://host:port/path","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"创建Cocos2d-X工程","date":"2014-02-26T06:46:37.000Z","path":"2014/02/26/创建Cocos2d-X工程/","text":"../cocos2d-x/tools/project-creator目录下的create_project.py输入./create_project.py -project Name -package PackageName -language cpp命令，创建一个名为Name，包名为PackageName，编程语言为c++的一个工程。 环境配置 .bash_profile中加上以下几个路径： 123456export COCOS2DX_ROOT=/Users/zhaitao/Documents/cocos2d-x-2.2.2export ANDROID_SDK_ROOT=/Users/zhaitao/Documents/Android/sdkexport ANDROID_NDK_ROOT=/Users/zhaitao/Documents/Android/android-ndk-r9cexport NDK_ROOT=/Users/zhaitao/Documents/Android/android-ndk-r9cexport PATH=$PATH:$ANDROID_NDK_ROOTexport PATH=$PATH:$ANDROID_SDK_ROOT 修改build_native.sh文件 在路径/Users/user/Documents/cocos2d-x-2.2.2/samples/Cpp/TestCpp/proj.android下找到build_native.sh 在APPNAME=”TestCpp”下添加NDK_ROOT=”/Users/user/Documents/android-ndk-r9c” 命令行执行build_native.sh","tags":[{"name":"Cocos2d-X","slug":"Cocos2d-X","permalink":"http://seniorzhai.github.io/tags/Cocos2d-X/"}]},{"title":"Quartz 2D绘图","date":"2014-02-26T04:43:53.000Z","path":"2014/02/26/Quartz-2D绘图/","text":"使用Quartz 2D绘图的关键步骤有两步：获取CGContextRef，调用CGContextRef的方法进行绘图。 自定义UIView获取CGContextRef 1CGContextRef ctx = UIGraphicsGetCurrentContext(); 创建位图获取CGContextRef&gt; 1234// 创建内存中的图片UIGraphicsBeginImageContext(CGSizeMake(320,480));// 获取想内存中图片执行绘制的CGContextRefCGContextRef ctx = UIGraphicsGetCurrentContext(); Quart2D的绘图相关函数 函数签名 简要说明 void CGContextClearRect(CGContextRef c,CGRect rect) 擦除指定矩形区域上绘制的图形 void CGContextDrawPath(CGContextRef c,CGPathDrawingMode mode) 使用指定模式绘制当前CGContextRef中所包含的路径。第二个参数支持kCGPathFill、kCGPathEOFill、kCGPathStroke、kCGPathFillStroke、kCGPathEOFillStroke void CGContextEOFillPath(CGContextRef c) 用奇偶规则来填充该路径包围的区域，奇偶规则指：如果某个点被路径包围了奇数次，系统绘制该点：如果被路径包围偶数次，系统不绘制该点 void CGContextFillPath(CGContextRef c) 填充该路径包围的区域 void CGContextFillPath(CGContextRef c,CGRect rect) 填充rect代表的矩形 void CGContextFillRects(CGContextRef c,const CGRect rects[],size_t_count) 填充多个矩形 void CGContextFillElipseInRect(CGContextRef context,CGRect rect) 填充rect矩形的内切椭圆 void CGContextStrokePath(CGContextRef c) 使用当前CGContextRef设置的线宽绘制路径 void CGContextStrokeRect(CGContextRef c,CGRect rect) 使用当前CGContextRef设置的线宽绘制矩型 void CGContextStrokeRectWillWidth(CGContextRef c,CGRect rect,CGFloat width) 使用指定线宽绘制矩形框 void CGContextReplacePathWillStrokePath(CGContextRef c) 使用绘制当前路径时覆盖的区域作为当前CGContextRef中的新路径 void CGContextStokrEllipseInRect(CGContextRef context,CGRect rect) 使用当前CGContextRef设置的线宽绘制rect矩形的内切椭圆 void CGContextStrokeLineSegments(CGContextRef c,const CGPoint points[],size_t count) 使用当前CGContextRef设置的线宽绘制多条线段，其中1、2点组成一个线段，3、4组成一条限度，以此类推 设置绘图属性的相关函数 函数签名 简要说明 void CGContextSavaGState(CGContextRef c); 保存CGContextRef当前的绘图状态，以便以后恢复该状态 void CGContextRestoreGState(CGContextRef c); 把CGContextRef的状态恢复到最近一次保存时的状态 CGInterpolationQuality CGContextGetInterpolationQuality(CGContextRef c); 获取当前CGContextRef在放大图片时差值质量 void CGContextSetInterpolationQuality(CGContextRef c,CGInterpolationQuality quality); 设置当前CGContextRef在放大图片时差值质量 void CGContextSetLineCap(CGContextRef c,CGLineCap cap); 设置线段端点的绘制形状，该属性支持如下三个值：kCGLineCapButt：该属性不会只端点，线条结尾处直接结束，此为默认值；kCGLineCapRound：该属性指定绘制原点端点，线条结尾处绘制一个直径为线条宽度的半圆；kCGLineCapSquare:该属性指定绘制方形端点。线条结尾处绘制半个边长为线条宽度的正方形。 void CGContextSetLineDash(CGContextRef c,CGFloat phase,const CGFloat lengths[],size_t count); 设置绘制边框时所用的点线模式 void CGContextSetLineJoin(CGContextRef c,CGLineJoin join); 设置线条连接点的风格支持以下三个值：kCGLineJoinMeter,kCGLineJoinRound,kCGLineJoinBevel void CGContextSetLineWidth(CGContextRef c,CGFloat width); 设置绘制直线、边框时的线条宽度 void CGContextSetMiterLimit(CGContextRef c,CGFloat limit); 当把连接点风格设置为meter风格时，该方法用于控制锐角箭头的长度 void CGContextSetPatternPhase(CGContextRef c,CGSize phase); 设置该CGContextRef采用位图填充的相位 void CGContextSetFillPattern(CGContextRef c,CGPatternRef pattern,const CGFloat components[]); 设置该CGContextRef使用位图填充 void CGContextSetShouldAntialias(CGContextRef c,bool shouldAnitialias); 设置该CGContextRef是否应该抗锯齿 void CGContextSetStrokePattern(CGContextRef c,CGPatternRef pattern,const CGFloat components[]); 设置该CGContextRef使用位图绘制线条、边框 void CGContextSetBlendMode(CGContextRef context,CGBlendMode mode); 设置CGContextRef的叠加模式 void CGContextSetAllowsAntialiasing(CGContext context,bool allowsAntialiasing); 设置该CGContextRef是否允许抗锯齿 void CGContextSetAllowsFontSmoothing(CGContext context,bool allowsFontSmoothing); 设置该CGcontextRef是否允许光滑字体 void CGContextSetShouldSmoothFonts(CGContext c,bool shouldSmoothFonts); 设置该CGcontextRef是否允许光滑字体 void CGContextSetAlpha(CGContext c,CGFloat alpha); 设置全局透明度 void CGContextSetCMKYFillColor(CGContextRef c,CGFloat cyan,CGFloat magenta,CGFloat yellow,CGFloat black,CGFloat alpha); 使用CMYK颜色模式来设置该CGContextRef的填充颜色 void CGContextSetCMYKStrokeColor(CGContextRef c,CGFloat cyan,CGFloat magenta,CGFloat yellow,CGFloat black,CGFloat alpha) 使用CMYK颜色模式来设置该CGContextRef的线条颜色 void CGContextSetFillColorWithColor(CGContextRef c,CGColorRef color); 使用指定颜色来设置该CGContextRef的填充颜色 void CGContextSetStrokeColorWithColor(CGContextRef c,CGColorRef color); 使用指定颜色来设置该CGContextRef的线条颜色 void CGContextSetGrayFillColor(CGContextRef c,CGFloat gray,CGFloat alpha); 使用灰色来设置该CGContextRef的填充颜色 void CGContextSetGrayStrokeColor(CGContextRef c,CGFloat gray,CGFloat alpha); 使用灰色来设置该CGContextRef的线条颜色 void CGContextSetRGBFillColor(CGContextRef c,CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha); 使用RGB颜色模式来设置该CGContextRef的填充颜色 void CGContextSetRGBStoreColor(CGContextRef c,CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha); 使用GRB颜色模式来设置该CGContextRef的线条颜色 void CGContextSetShadow(CGContext context,CGSize offset,CGFloat blur); 设置阴影在X,Y方向上的偏移，以及模糊度（blur值越大，阴影越模糊），默认模糊颜色为RGBA(0,0,0,1/3.0) void CGContextSetShadowWithColor(CGContextRef context,CGSize offset,CGFloat blur,CGColorRef color); 设置阴影在X、Y方向上的偏移，以及模糊度和阴影颜色 点线模式 Quartz 2D绘制线段或边框时，默认总是使用实线，使用点线进行绘制，可调用CGContextRefLineDash(CGContextRef c,CGFloat phase,const CGFloat lengths[],size_t count)进行设置。 绘制文本 CGContextRef为绘制文字提供了如下函数 CGAffineTransform CGContextGetTextMartix(CGContextRef c):：获取当前对文本执行变换的变换矩阵。 CGPoint CGContextGetTextPosition(CGContextRef c):：获取该CGContextRef中当前绘制文本的位置。 CGContextSelectFont(CGContextRef c,const char *name,CGFloat size,CGTextEncoding textEncoding):：设置该CGContextRef当前绘制文本的字体、字体大小。 void CGContextSetCharacterSpacing(CGContextRef c,CGFloat spacing):：设置该CGContextRef中绘制文本的字符间距。 void CGContextSetFont(CGContextRef c,CGFonRef font):：设置该CGContextRef中绘制文本的字体。 void CGContextSetFontSize(CGContextRef c,CGFloat size):：设置该CGContextRef中绘制文本的字体大小。 CGContextSetTextDrawingMode(CGContextRef c,CGTextDrawingMode mode):：设置该CGContextRef绘制文本的绘制模式。该函数支持kCGTextFill、kCGTextStroke、kCGTextFillStroke等绘制模式。 void CGContextSetTextMatrix(CGContextRef c,CGAffineTransform t):：设置对将要绘制的文本执行指定的变换。 void CGContextSetTextPosition(CGContextRef c,CGFloat x,CGFloat y):：设置CGContextRef的一个文本绘制位置。 void CGContextShowText(CGContextRef c,const char* string,size_t length):：控制CGContextRef在当前绘制点绘制指定文本。 void CGContextShowTextAtPoint(CGContextRef c,CGFloat x,CGFloat y,const char *string,size_t length):：控制CGContextRef在指定绘制点绘制文本。 使用CGContextRef绘制文本的步骤： 获取绘图的CGContextRef 设置绘制文本的相关属性 如果只是绘制不需要进行变换的文本，直接调用NSString的drawAtPoint:withAttributes:、drawInAttrubutes:withFont:等方法绘制即可。如果需要绘制文本进行变换，则需要先调用CGContextSetTextMatrix()函数设置变换矩阵，再调用CGContextShowTextAtPoint()方法绘制文本。 使用路径-绘制复杂的图形，需要使用路径 创建路径的相关函数|函数签名|简要说明||—|:—||void CGContextBeginPath(CGContextRef c);|开始定义路径||void CGContextClosePath(CGContextRef c);|关闭前面定义的路径||void CGContextAddArc(CGContextRef c,CGFloat x,CGFloat y,CGFloat radius,CGFloat startAngle,CGFloat endAngle,int clockwise);|向CGContextRef的当前路径添加一段弧||void CGContextAddArcToPoint(CGContextRef c,CGFloat x1,CGFloat y1,CGFloat x2,CGFloat y2,CGFloat radius);|向CGContextRef的当前路径添加一段贝塞尔曲线||void CGContextAddCurveToPoint(CGContextRef c,CGFloat cp1x,CGFloat cp1y,CGFloat cp2x,CGFloat cp2y,CGFloat x,CGFloat y);|向CGContextRef的当前路径添加一段贝塞尔曲线||void CGContextAddLines(CGContextRef c,const CGPoint points[],size_t count);|向CGContextRef的当前路径上添加多条线段。该方法需要传入N个CGPoint组成的数组，其中1、2点组成第一条线段，2、3点组成一条线段……||void CGContextAddLineToPoint(CGContextRef c,CGFloat x,CGFloat y);|把CGContextRef的当前路径从当前结束点连接到x、y对应的点||void CGContextAddQuadCurveToPoint(CGContextRef c,CGFloat cpx,CGFloat cpy,CGFloat x,CGFloat y);|向CGContextRef的当前路径从当前结束点连接到x、y对应的点||void CGContextAddRect(CGContextRef c,CGRect rect);|向CGContextRef的当前路径添加一个矩形||void CGContextAddRects(CGContextRef c,const CGRect rects[],size_t count);|向CGContextRef的当前路径添加多个矩形||void CGContextMoveToPoint(CGContextRef c,CGFloat x,CGFloat y);|向CGContextRef的当前结束点移动到x、y对应的点||void GCContextAddEllipseInRect(CGContextRef c,CGRect rect);|向CGContextRef的当前路径添加一个椭圆||CGPathRef CGContextCopyPath(CGContextRef context);|复制当前CGContextRef包含的路径，该函数返回的CGPathRef代表当前CGContextRef包含的路径||void CGContextAddPath(CGContextref context,CGPathRef path);|将已有的CGPathRef代表的路径添加到当前CGContextRef的路径中| 获取CGContextRef所包含的路径信息的函数 bool CGContextIsPathEmpty(CGContextRef c)::该函数用于判断指定CGContextRef包含的路径是否为空。 CGPoint CGContextGetPathCurrentPoint(CGContextRef c):：该函数用于返回指定CGContextRef包含的路径的当前点。 CGRect CGContextGetPathBoundingBox(CGContextRef c):：该函数用于返回指定CGContextRef中能完整包围所有路径的最小矩形。 bool CGContextPathContainsPoint(CGContextRef context,CGPoint point,CGPathDrawingMode mode):：该函数判断指定CGContextRef包含的路径按指定绘制模式进行绘制时，是否需要绘制point点。 使用路径绘制步骤 调用CGContextBeginPath()函数开始定义路径 添加子路径 调用CGContextClosePath()函数关闭路径 调用CGContextDrawPath()、CGContextEOFFillPath()、CGContextFillPath()、CGContextStrokePath()函数来填充路径或绘制路径边框。 CGContextDrawPath() 可以代替其他三个方法，它可以使用特定的模式绘制图形 kCGPathFill:指定填充路径 kCGPathEOFill:指定采用even-odd模式填充路径 kCGPathStroke:指定只绘制路径 kCGPathFillStroke:指定既绘制路径，也填充路径 kCGPathEOFillStroke:指定既绘制路径，也采用even-odd模式填充路径 Core Image滤镜 IOS5新增框架，可以对图像进行各种特效处理，包括进行色彩调节、降噪、扭曲等。 Core Image的三个核心API： CIContext：处理的核心API，所有图片的处理都在它的管理下完成。 CIFilter：过滤器，所有的过滤器都由该CIFilter代表，在创建CIFilter时，需要传入不同的参数即可创建不同类型的过滤器。 CIImage：被处理的图片，可通过UIImage、图片文件或像素数据来创建CIImage。 使用CoreImage的步骤 创建CIContext对象 创建基于CPU的CIContext对象 1ctx = [CIContext contextWithOptions:[NSDicationary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]]; 创建基于GPU的CIContext对象 1ctx = [CIContext contextWithOptions:nil] 创建基于OpenGL优化CIContext对象，可获得实时性能 12EAGLContext * eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];ctx = [CIContext contextWithEAGLContext:eaglctx]; 创建CIFilter过滤器，CIFilter提供了filterWithName：类方法来创建CIFilter对象。该方法需要传入过滤器的名字，根据不同名字创建不同的过滤器，可在在此处查看。 创建CIImage对象，该CIImage将要作为过滤器处理的源图片。 调用CIFilter的[filter setValue:behinImage for:@”inputImage”]方法为inputImage属性赋值，该属性用于指定该过滤器将要处理的源图片。 根据需要，为不同的过滤器设置不同的过滤参数。 调用CIFilter的outputImage属性获取该过滤器处理后的图片，程序返回的是CIImage对象。 调用CIContext的不同方法将CIImage转换成CGImageRef或将CImage绘制到指定区域中。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"iOS应用生命周期","date":"2014-02-26T04:43:11.000Z","path":"2014/02/26/iOS应用生命周期/","text":"iOS应用状态 Not running(未运行):应用程序未启动或者应用被系统终止 Inactive(不活动):程序在前台运行，但不能接受事件处理。当应用从一个状态切换到另一个状态时，中途过渡会短暂停留在此状态。 Active(活动):程序在前台运行且能接收到事件，这是应用在前台运行时所处的正常状态。 Background(后台):应用处在后台运行，并且还在执行代码。大多数将要进入Suspended做状态的应用，会先短暂进入状态。如果一个应用要求启动时直接进入后台运行，这样应用会直接从Not running状态进入Background状态，中途不会经过Inactive状态。 Suspended(挂起):应用处在后台，并且没有执行任何代码。系统会自动将应用转入该状态，并且不会发出任何通知。当处在该状态时，应用依然驻留内存，但不执行任何程序代码。App Delegate对应的回调方法 application:willFinishLaunchingWithOptions:程序将要启动时自动调用该方法，该方法是应用程序启动时第一次执行自定义代码的机会。 application:didFinishLaunchingWithOptions:应用程序启动时自动调用该方法，开发者可以在该方法中执行初始化相关的代码。 applicationDidBecomeActive:应用在转入前台，并进入活动状态时回调该方法（当应用从启动到进入前台，或从后台转入前台都会调用该方法），可重写该方法执行最后的准备工作。 applicationWillResignActive:应用正要从前台运行状态离开时将会调用该方法。 applicationDidEnterBackground:应用在正处于Background状态，且随时可能进入Suspended状态时将会调用该方法。 applicationWillEnterForeground:应用正从后台转入前台运行状态，但暂时还没有到达Active状态时将会调用该方法。 applicationWillTerminate:该应用程序即将被终止时调用该方法，如果应用当前处在Suspended状态，此方法将不会被调用。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"编辑表格","date":"2014-02-26T04:42:16.000Z","path":"2014/02/26/编辑表格/","text":"UITableView支持对表格行执行移动、删除和插入操作。 UITableView提供了editing属性来判断该表格控件是否处于编辑状态。可以使用setEdting:animated:方法切换表格的编辑状态。 UITableView提供了如下的方法来插入、删除和移动表格栏 -beginUpdates:在执行多个连续编辑之前，先调用该方法开始更新。 -endUpdates:在执行多个连续编辑之后，调用该方法提交更新。 -insertRowsAtIndexPaths:withRowAnimation:在一个或多个NSIndexPath处插入表格行。 -deleteRowsAtIndexPaths:withRowAnimation:删除一个或多个NSIndexPath处的表格行。 -moveRowAtIndex:toIndexPath:将指定NSIndexPath处的表格行移动到另一个NSIndexPath处。 -insertSections:withRowAnimation:在指定NSIndexPath所包含的一个或多个分区号对应的位置插入分区。 -deleteSections:withRowAnimation:删除指定NSIndexPath所包含的一个或多个分区对应的分区。 -moveSection:toSection:将指定区域移动到另一个位置。 动态编辑表格，必须实现UITableView对应dataSource对象中的如下方法： -tableView:canEditRowAtIndexPath:该方法的返回值决定指定NSIndexPath对应的表格行是否可编辑。 -tableView:commitEditingStyle:forRowAtIndexPath:该方法的返回值决定指定表格行编辑完成时激发。 -tableView:canMoveRowAtIndexPath:该方法的返回值决定指定的NSIndexPath对应的表格栏是否可移动。 -tableView:moveRowAtIndexPath:toIndexPath:该方法告诉该DataSource将指定的表格行移动到另一个位置。 UITableViewDelegate协议为编辑表格定义了如下方法： -tableView:willBeginEditingRowAtIndexPath:开始编辑某个表格行时激发委托对象的该方法。 -tableView:didEndEditingRowAtIndexPath:当编辑完某个表格行是激发委托对象的该方法。 -tableView:editingStyleForRowAtIndexPath:该方法的返回值决定了该表格行的编辑状态。可以返回UITableViewCellEditingStyleNone、UITableViewCellEditingStyleDelete、UITableViewCellEditingStyleInsert这三个枚举值之一。 -tableView:titleForDeleteConfirmationButtonForRowAtIndexPath:该方法返回的NSString将会作为删除指定表格行时确定按钮的文本。 -tableView:shouldIndetWhileEditingRowAtIndexPath:该方法返回的BOOL值决定指定表格行处于编辑状态时，该表格行是否应该缩进。默认编辑状态都会缩进。 多分区表格以及分区索引 UITableView生成表格控件包含更多的分区，需要为表格的dataSource对象实现更多的方法。 -numberOfSectionsInTableView:该方法的返回值决定表格包含多少个分区。 -sectionIndexTitlesForTableView:该方法的返回值用于在表格右边建立一列浮动的索引。 -tableView:titleForHeaderInSection:该方法的返回值决定指定分区的页眉。 -tableView:titleForFooterInSection:该方法的返回值决定分区的页脚。 直接使用UITableViewController 只显示一个表格的话，可以之间继承UITableViewController，其已经实现了UITableViewDataSource和UITableViewDelegate协议。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UITabBarController","date":"2014-02-24T04:41:38.000Z","path":"2014/02/24/UITabBarController/","text":"UITabBarController的基本概念 UITabBarController和UINavigationController一样是用来管理视图控制器的。 UINavigationController是用来管理视图之间的导航，UITabBarController是管理固定的几个视图控制器，子控制器是并列的。可以任意切换显示。 UITabBarController基本样式 UITabBarController初始化 1234567891011121314151617UIViewController *viewCtrl1 = [[UIViewController alloc] init];viewCtrl.title = @&quot;主页&quot;;UIViewController *viewCtrl2 = [[UIViewController alloc] init];viewCtr2.title = @&quot;消息&quot;;UIViewController *viewCtrl3 = [[UIViewController alloc] init];viewCtr3.title = @&quot;搜索&quot;;UIViewController *viewCtrl4 = [[UIViewController alloc] init];viewCtr4.title = @&quot;设置&quot;;NSArray *viewControllers = [NSArray arrayWitjObjects:viewCtr1,viewCtrl2,viewCtrl3,viewCtrl3,viewCtrl4,nil];UITabBarController *mainViewController = [[UITabBarController alloc] init];mainViewController.viewControllers = viewControllers;[self.window setRootViewController:mainViewController]; 示例代码 1234567891011121314151617181920212223242526272829303132/* ... *//* * 1.创建若干个子视图控制器，它们是并列关系 * 2.创建一个数组，将已创建的子视图控制器，添加到数组中 * 3.创建UITabBarContrller实例 * 4.tabBarController.viewContrllers = viewContollers; * 5.添加到window的rootViewController */UIViewController *vc1 = [[UIViewController alloc]init];vc1.title = @&quot;首页&quot;；vc1.view.backgroundColor = [UIColor redColor];UIViewController *vc2 = [[UIViewController alloc]init];vc2.title = @&quot;新闻&quot;；vc2.view.backgroundColor = [UIColor blueColor];UIViewController *vc3 = [[UIViewController alloc]init];vc3.title = @&quot;历史&quot;；vc3.view.backgroundColor = [UIColor yellowColor];UIViewController *vc4 = [[UIViewController alloc]init];vc4.title = @&quot;搜索&quot;；vc4.view.backgroundColor = [UIColor purpColor];UIViewController *vc5 = [[UIViewController alloc]init];vc5.title = @&quot;设置&quot;；vc5.view.backgroundColor = [UIColor orangeColor];NSArray *viewControllers = @[vc1,vc2,vc3,vc4,vc5];UITabBarController tabBarController = [[UITabBarController alloc] init];[UITabBarController setViewContronllers:viewControllers animated:YES];self.window.rootViewController = tabBarController; UITabBarController结构图 Tab控制器用数组管理视图，视图间是平级的。 TabBarController类图分析 一个分栏视图控制器控制着若干视图控制器，由一个数组管理 每个分栏控制器只有一个UITabBar视图，用于显示UITabItem实例 UITabBarItem由当前的视图控制器管理 UITabBarController系统样式 +TabBar只能显示5个Tab Item，超过5个则会自动生成个More标签显示剩余的Tab，这些Tab可以通过编辑显示在UITabBar上。如果将视图添加到导航控制器中，默认出现编辑按钮，可以自由移动item实例。 实例代码 创建系统自带的TabBarController12345678TabBarViewController *tabBarController = [[UITabBarViewController alloc]init];FirstViewController *firstItem = [[FirstViewController alloc] init];UITabBarItem *firstItem = [[UITabBarItem alloc]initWithTabBarSystemItem:UITabBarSystemItemFavorites tag:1];firstViewController.tabBarItem = firstItem;// ......NSArray *viewControllers = @[firstItem,secondItem,thirdItem];[tabBarController setViewControllers:viewControllers animated:YES];self.window.rootViewController = tabBarController; 自定义UITabBarItem 图片大小3030px(视网膜屏6060) 图片需要使用淡灰色或者半透明效果，选择系统自动填充蓝色 123FirstViewController *firstVC = [[FirstViewController alloc]init];UITabBarItem *firstItem = [[UITabBarItem alloc] initWithTitle:@&quot;主页&quot; image:[UIImage imageNamed:@&quot;image.ong&quot;]tag:1];firstVC.tabBarItem = firstItem; UITabBarController代理方法 12345678-(BOOL)tabBarController:(UITabBarController *)tabBarController shouldSelectViewController:(UIViewController *)viewController&#123; // 视图将被切换时调用，viewController为将被显示的控制器&#125;- (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController&#123;// 视图已经被切换后调用，viewController为已经显示的控制器&#125; 基层分栏控制器和导航控制器 在Tab Bar控制器中某一个Tab中使用Navigation控制器。 实现代码12345678FirstViewController *firstVC = [[FirstViewController alloc] init];UINavigationController * fNav = [[UINavigation alloc] initWithRootViewController:firstVC];SecondViewController * secondVC = [[SecondViewController alloc] init];//......NSArray *viewControllers = [NSArray arrayWithObjects:firstVC,secondVC,nil];UITabBarController*tabController = [[UITabBarController alloc] init];tabController.viewControllers = viewControllers;self.window.rootViewController = tabController;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"自定义导航栏","date":"2014-02-24T04:41:01.000Z","path":"2014/02/24/自定义导航栏/","text":"设置背景需要通过类别修改drawRect方法。5.0以上SDK提供了设置背景图片的方法。 12345678910// 5.0之前，类别扩展给UINavagationBar设置图片背景@implementation UINavigationBar (CustomNavigationBar)- (void)drawRect:(CGRect)rect&#123; UIImage * image = [UIImage imageNamed:@&quot;image.png&quot;]; [image drawInRect:rect];&#125;@end// 5.x新增了serBackgroundImage方法来设定图片背景UINavigationController *navigation = [[UINavigationController alloc] initWithRootViewController:viewController];[navigation.navigationBar setBackgroundImage:[UIImage imageNamed:@&quot;image.png&quot;] forBarMetrics:UIBarMetricsDefault]; 小结 一个UINavigationController对应一个NavigationBar实例 一个UINavigationController可以包含多个UIViewController 每一个UIViewController对应一个UINavigationItem实例 UINavagationItem控制多个UIBarButtonItem 一个UINavigationController控制着一个UIToolBar实例 UIToolBar中的UIBarButtonItem由当前的视图控制器管理，而不是由导航控制器控制","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"进度条","date":"2014-02-23T04:40:21.000Z","path":"2014/02/23/进度条/","text":"UIProgressView 属性 Style Default:默认风格 Bar:工具条风格+Progress 设置0.0~1.0之间的浮点值，1.0代表全部完成。+Progress Tint 已完成进度的颜色 Track Tink 设置进度条轨迹颜色。 progressImage:设置该进度条完成部分的图片 tracjImage:设置进度条的轨道图片 ImageView图像拉伸 默认情况下，iOS将会对该图像整体缩放，从而让图片被拉伸、变形。+为了精确地控制只对制定区域进行缩放，可通过uIImage来创建“可拉伸”图片。当通过一个UIEdgeInsets结构体（包括left、top、right、bottom）定义图片的拉伸区域。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"NDK Samples","date":"2014-02-22T14:15:09.000Z","path":"2014/02/22/NDK-Samples/","text":"在NDk的目录下有一个例子\\android-ndk\\samples\\hello-jni 将它导入到eclipse开发环境中（最好选择cpoy到自己的工作空间） 在命令行进入该项目的路径，执行ndk-build命令，编译程序 在eclipse上试运行（注：在4.x的版本要将Dependencies包去掉，貌似这个包是做低版本支持的，在高版本中会出错） 运行成功 12345678910111213141516171819202122232425262728//hello-jni.c# include &lt;string.h&gt;# include &lt;jni.h&gt;// &lt;jni.h&gt;用于java的调用jstring// 名字即包名加函数名Java_com_example_hellojni_HelloJni_stringFromJNI( JNIEnv* env, jobject thiz )&#123;# if defined(__arm__) # if defined(__ARM_ARCH_7A__) # if defined(__ARM_NEON__) # define ABI \"armeabi-v7a/NEON\" # else # define ABI \"armeabi-v7a\" # endif # else # define ABI \"armeabi\" # endif# elif defined(__i386__) # define ABI \"x86\"# elif defined(__mips__) # define ABI \"mips\"# else # define ABI \"unknown\"# endif // env为java与C交互的结构，返回UTF编码的字符串 return (*env)-&gt;NewStringUTF(env, \"Hello from JNI ! Compiled with ABI \" ABI \".\");&#125; 1234567891011121314151617public class HelloJni extends Activity&#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); TextView tv = new TextView(this); tv.setText(stringFromJNI() ); setContentView(tv); &#125; // 声明一个native方法，即.c的函数 public native String stringFromJNI(); public native String unimplementedStringFromJNI(); static &#123; System.loadLibrary(\"hello-jni\"); &#125;&#125; 在adb shell中运行c程序 在\\android-ndk\\samples\\test-libstdc++下有这样一个例子，我们进行修改后然后在设备上运行它。 将jni目录下的test-libstl.cpp的文件进行修改 12345678# include &lt;cerrno&gt;# include &lt;cstddef&gt;# include &lt;stdio.h&gt;int main(void)&#123; printf(\"Zoe\\n\"); return 0;&#125; 在命令行下使用ndk-build编译该项目 将项目目录下的\\libs\\armeabi\\test-libstl文件拷贝到设备的/data/data目录下(你需要该目录的写权限) 进入设备的shell，并获取权限 切换到/data/data目录，修改test-libstl文件的权限，并执行它 编写自己的程序 在任意目录下，创建jni文件夹 创建一个你的程序，如：MyDemo.c 1234567# include &lt;stdio.h&gt;void main()&#123; int a,b,c; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;c); printf(\"%d+%d+%d=%d\\n\",a,b,c,a+b+c);&#125; 创建Android.mk文件，注意LOCAL_MODULE、LOCAL_SRC_FILES属性 12345LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := MyDemoLOCAL_SRC_FILES := MyDemo.cinclude $(BUILD_EXECUTABLE) 按上一个例子编译、拷贝、执行","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"UITextView多行文本控件","date":"2014-02-22T06:39:44.000Z","path":"2014/02/22/UITextView多行文本控件/","text":"继承了UIScrollView:UIView控件，默认带有滚动条 UITextView与UITextField的区别 UITextView是一个多行文本框，UITextField只是单行文本 UITextView没有继承UIControl控件 UITextView继承了UIScrollView，所以它具有UISrollView的功能和行为。UIScrollView支持的属性 控制显示区域的属性 contentSize:该属性是一个CGSize类型的值，制定显示内容的完整宽度和完整高度。 contentInset:该属性是一个UIEdgeInsets类型的值，表示所需要内容在上下左右的留白。 contentOffset:该属性是一个CGPoint值，表示可视区域在显示内容上滚动的距离。 属性设置1.Scrollers Shows Horizontal Scrllers:当用户水平滚动该控件时，该控件会显示水平滚动条。 Shows Vertical Scrollers: 当用户垂直滚动该控件时，该控件会显示垂直滚动条。 Scrolling Enabled:控件能否滚动。 Paging Enabled:是否分页。 Direction Lock Enabled:第一次滚动后，不允许向其他方向滚动。 Bounce Bounce :弹回效果。 Bounce Horizontally:水平弹回效果。 Bounce Vertically:垂直弹回效果。 Zoom Min 最小的可缩放比例。 Max 最大的可缩放比例。 Touch Bounces Zoom:内容缩放是否有弹性。 Delays Content Touches:真正确定滚动意图才去处理触碰手势。 Cancellable Content Touches:勾选后，如果该UIScrollView中的内容已经跟踪用户手势触碰动作的情况下，且用户拖动手指足以启动一个滚动事件，该UISrollView控件会调用touchesCancelled:withEvent:方法，并将该手指拖动事件当成滚动该UISroll控件。如果不勾选，UIScrollView控件已经跟踪某个手指动作，将不会理会其他的手指动作。 使用委托对象处理UITextView事件 委托对象必须实现UITextViewDelegate协议，协议定义了如下方法。 -textViewShouldBeginEdting:将要开始编辑内容时回调。 -textViewDidBeginEdting:开始编辑内容时回调。 -textViewShouldEndEdting:将要结束时回调。 -textViewDidEndEdting:结束编辑时回调。 -textView:shouldChangeTextInRange:replacementText:指定范围内的文本内容将要被替换是回调。 -textViewDidChange:文本内容发生改变时回调。 -textViewDidChangeSelection:文本内某些文本改变时回调。 实例","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"xib文件注意点","date":"2014-02-22T06:38:34.000Z","path":"2014/02/22/xib文件注意点/","text":"创建控制器. File-&gt;New File-&gt;Iphone OS-&gt;Cocoa Touch Class-&gt;UIViewController subclass; 创建xib. File-&gt;New File-&gt;Iphone OS-&gt;User Interface-&gt;View XIB 绑定controller和view. 用Interface Builder打开xxx.xib, 点击Files’ Owner, 在Identity Inspector里面的Class Identity, 选择Step 1创建的控制器类, 接着拖拽File’s Owner到View中, 选择Outlets-&gt;view.先选中file’s owner(这个很重要) 定制iOS应用图标 需要57X57、114X114、120X120的图片作为图标。 需要320X480、640X960、640X1136的素材作为启动画面。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UIImageView-UIAlertView-UIActionSheet.","date":"2014-02-21T06:35:32.000Z","path":"2014/02/21/UIImageView-UIAlertView-UIActionSheet/","text":"UIImageView 一个显示图片控件，直接继承了UIView基类，没有继承UIControl，不能接受用户输入，不能与用户交互。 常用属性image:访问或设置该控件显示的图片highlighteImage:访问或设置该控件出于高亮状态时显示的图片 UIImage还可以使用动画显示一组图片animationImages:访问或者设置该UIImageView需要动画显示的多张图片，该属性的值为NSArray对象。highlightedAnimationImages:访问或设置该UIImageView高亮状态下需要动画显示的多张图片，该属性的值为NSArray对象。animationDuration:访问或设置该UIImageView的动画持续时间。animationRepeatCout:访问或设置该UIImageView的动画重复次数。startAnimating:开始播放动画。stopAnimating:停止播放动画。isAnimationg:该方法判断该UIImageView是否正在播放动画。 缩放模式Scale To Fill:不保持纵横比缩放图片，使图片完全适应该UIImageView控件。Aspect Fit:保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。Aspect Fill:保持纵横比缩放图片，只保证短边完全显示出来。Center:不缩放图片，只显示图片的中间区域。Top:不缩放图片，只显示图片的顶部区域。Bottom:不缩放图片，只显示图片的底部区域。Left:不缩放图片，只显示图片的左边区域。Right:不缩放图片，只显示图片的右边区域。Top Right:不缩放图片，只显示图片的右上边区域。Top Left:不缩放图片，只显示图片的左上边区域。Bottom Left:不缩放图片，只显示图片的左下边区域。Bottom Right:不缩放图片，只显示图片的右下边区域。UIAlertView(警告框) UIAlertView 显示在屏幕中央的弹出式警告框。 基本用法 创建UIAlertView,指定标题、消息内容、包含多少个按钮、指定UIAlertViewDelegate委托对象。 调用UIAlertView显示出来。 实现UIAlertViewDelegate协议中的方法。 实例代码 12345678910111213141516171819202122232425-(void)viewDidLoad&#123; [super viewDidLoad];&#125;-(IBAction)clicked:(id)sender&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;警告框信息&quot; deledgate:self cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:@&quot;按钮一&quot;,@&quot;按钮二&quot;,@&quot;按钮三&quot;,nil]; [alert show];&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; NSString* msg = [NSString stringWithFormat:@&quot;你点击了第%d按钮&quot;,buttonIndex]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:msg delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]&#125; UIAlertViewDelegate协议中常用的方法 1234567891011121314-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex://当用户点击该警告框中某个按钮时激发该方法，buttonIndex参数代表用户单击按钮的索引，索引从0开始。-(void)willPresenAlertView:(UIAlertView *)alertView://当该警告框将要显示出来时将会激发该方法。-(void)didPresenAlertView:(UIAlertView *)alertView://当该警告框将要显示出来后将会激发该方法。-(BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView://当该警告框第一个非Cancel按钮被启用时激发该方法。-(void)alertView:(UIAlertView *)alerView willDismissWithButtonIndex:(NSInteger)buttonIndex://当用户单击某个按钮将要隐藏该警告框时激发该用法。-(void)alertViewCancel:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInterger)buttonIndex://当用户通过单击某个按钮完全隐藏该警告框时激发该方法。-(void)alertViewCancel:(UIAlertView *)alertView://当该警告框被取消时（如用户单击了Home键）激发该方法。 带输入框的UIAlertView UIAlertView支持actionSheetStyle属性，用于设置该UIAlert的风格，支持如下枚举值： UIAlertViewStyleDefault：默认的警告框风格。UIAlertViewStyleSecureTextInput：警告框中包含一个密码输入框。UIAlertViewStylePlainTextInput：警告框中包含一个普通的输入框。UIAlertViewStyleLoginAndPasswordInput：警告框中包含用户名、密码两个输入框。 实例代码123456789101112131415161718192021222324252627282930313233343536373839404142-(void)viewDidLoad&#123; [super viewDidLoad];&#125;-(IBAction)clicked:(id)sender&#123; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;登录&quot; message:@&quot;&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:@&quot;确定&quot;,nil]; alert.alertViewStyle = UIAlertViewStyleLoginAndPasswordInput; [alert textFieldAtIndex:1].keyboardType = UIKeyboardTypeNumberPad; [alert show];&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInterger)buttonIndex&#123; if(buttonIndex == 1)&#123; UITextField* nameField = [alertView textFieldAtIndex:0]; UITextField* passField = [alertView textFieldAtIndex:1]; NSString* msg = [NSString stringWithFormat:&quot;输入的用户名为：%@，密码为%@&quot;,nameField.text,passField.text]; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:msg delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show]; &#125;&#125;-(void)willPresentAlerView:(UIAlertView *)alertView&#123; for(UIView * view in alertView.subViews) &#123; if([view isKindOfClass[UILabel class]) &#123; UILabel* label = (UILabel*)view; label.textAlignment=UITextAlignmentLeft; &#125; &#125;&#125; UIActionSheet 显示在底部的按钮列表，用户通过单击某个按钮来表明自己的态度。 风格(actionSheetStyle)： UIActionSheetStyleDefault:默认风格，灰色背景上显示白色文字。UIActionSheetStyleBlackTranslucent:在透明的黑色背景上显示白色文字。UIActionSheetStyleBlackOpaque:在纯黑的背景上显示白色文字 示例代码1234567891011121314151617181920212223-(void)viewDidLoad&#123; [super viewDidLoad];&#125;-(IBAction)clicked:(id)sender&#123; UIActionSheet* sheet = [[UIActionSheet alloc] initWithTitle:@&quot;请确认是否确认&quot; delegate:self cancelButton:@&quot;取消&quot; destrutiveButtonTitle:@&quot;确定&quot; otherButtonTitle:@&quot;按钮一&quot;,@&quot;按钮二&quot;,nil]; sheet.actionSheetStyle = UIActionSheetStyleAutomaic; [sheet showInView:self.view];&#125;-(void)actionSheet:(UIActionSheet *)actionSheetclickedButtonAtIndex:(NSInteger)buttonIndex&#123; UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:[NSString stringWithFormat:@&quot;你单击了第%d个按钮&quot;,buttonIndex delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alert show];&#125;","tags":[{"name":"UIImageView","slug":"UIImageView","permalink":"http://seniorzhai.github.io/tags/UIImageView/"},{"name":"UIAlertView","slug":"UIAlertView","permalink":"http://seniorzhai.github.io/tags/UIAlertView/"},{"name":"UIActionSheet.","slug":"UIActionSheet","permalink":"http://seniorzhai.github.io/tags/UIActionSheet/"}]},{"title":"Anroid NDK的安装与配置","date":"2014-02-20T14:14:20.000Z","path":"2014/02/20/Anroid-NDK的安装与配置/","text":"Mac版 到Google的官网下载Andorid NDK 解压到你要存放的位置 开启终端，输入命令pico .bash_profile 添加NDK的绝对路径export PATH=${PATH}:/Users/userName/Documents/android-ndk-r9cA_NDK_ROOT=/Users/userName/Documents/android-ndk-r8dexport A_NDK_ROOT 注：图片中有SDK的部分，具体路径视个人情况而定。 测试：关闭终端后重启，输入ndk-build,出现以下提示，证明配置成功 Windows版 到Google的官网下载Andorid NDK 解压到你要存放的位置 计算机-属性-高级系统设置-高级-环境变量-系统环境变量-编辑Path变量-添加NDK的存放路径 测试：在命令行中输入ndk-build,出现以下提示，证明配置成功","tags":[{"name":"Android","slug":"Android","permalink":"http://seniorzhai.github.io/tags/Android/"}]},{"title":"导航栏","date":"2014-02-20T07:34:50.000Z","path":"2014/02/20/导航栏/","text":"UINavigationBar 一个导航栏一般包括四个对象：UINavigationController、UINavigationBar、UIViewControllerUINavigationItem;其中UINavigationItem存放在UINavigationBar上。 导航栏结构剖析图 定制标题视图 通过NavigationItem的titleView属性，定制标题视图，titleView属性是一个视图类，因此可以添加一个UIView的实例，也可以添加UIView的子类，也可以在UIView的实例中添加子视图。1234UIView *cView = [[UIView alloc]initWithFrame:CGRectMake(0,0,160,44)];cView = [UIColor redColor];self.navigationItem.titleView = cView;[cView release]; 定制左、右栏目 NavigationItem实例有一个leftBarButtonItem和reightBarButtonItem，而这两个属性又是UIBatButtonItem的实例，可以通过初始化实例，定制。 UIBarButtonItem类提供了常用的四个初始化方法，通过这些不同的初始化方法，用户可以得到不同风格的Item。12345678// 初始化一个UIBarButtonItem的实例，初始化一个系统的Item-(id)initWithBarButtonSystemItem:(UIBarButtonSystemItem)systemItem taget:(id)target action:(SEL)action;// 初始化一个带图片的UIButtonItem实例-(id)initWithImage:(UIImage *)image style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;// 初始化一个自带标题的UIBarButtonItem实例-(id)initWithTitle:(NSString *)title style:(UIBarButtonItemStyle)style target:(id)target action:(SEL)action;// 初始化一个自定义视图-(id)initWithCustomView:(UIView *)customView; 设置风格 1234// 设置导航栏的风格为黑色self.navigationController.navigationBar.barStyle = UIBarStyleBlack;// 设置导航栏为透明self.navigationController.navigationBar.translucent = YES; 设置颜色 123456// 设置导航栏的颜色self.navigationController.navigationBar。tintColor = [UIColor redColor];// 设置自定义颜色，注意每一个颜色的范围是0~1之间[UIColor colorWithRed:0/255.0 green:225/255.0 blue:122/255.0 alpha:1];// 以图片作为颜色，注意这里是无法设置NavigationBar[UIColor colorWithPatternImage:[UIImage imageNamed:@&quot;img.png&quot;]]; 隐藏返回按钮 123// 隐藏返回按钮，后者带动画效果[self.navigationItem setHidesBackButton:YES];[self.navigationController setToolbarHidden：YES animated:YES]; 设置prompt属性 导航栏的prompt属性，通过navigationItem来设置，其主要作用是用于提示用户。比如，用户正在请求网络数据时，提示用户数据正在被加载，待加载完成后可以将它的值设置为nil，取消显示。工具栏 创建UIToolBar的实例 1234567UIToolBar *toolBar = [[UIToolBar alloc]initWithFrame:CFrectMake(0,460-88,320,44)];// 初始化UIToolBar的UIBarButtonItem实例，与UINavigationItem中左、右栏目是相同的UIBarButtonItem *item1 = [[UIBarButtonItem alloc] initWithTitle:@&quot;天气&quot; style:UIBarButtonItemStyleBordered target:self action:nil];// 向UIToolBar添加UIBarButtonItemNSArray *itemArray = [NSArray arrayWithObjects:item1,nil];// 设置UIToolBar的间隔，前者是item之前选择一个合适的列宽，后者用户可以自定义item之间的列宽，需要通过UIBar实例中的width属性来设置。UIBarButtonSystemItemFlexibleSpace|UIBarButtonSystemItemFixedSpace 导航控制器中的UIToolBar 在导航控制器中会带有一个UIToolBar的实例，但默认是隐藏的，如果需要显示，需要通过[self.navigationController setToolbarHidden:No animated:YES]将其打开。 导航控制器只拥有一个UIToolBar实例，但UIToolBar所拥有的UIBarButtonItem实例，由视图控制器管理。1234// 将UIBarButtonItem放入数组中，最后添加至UIToolBar中，self表示视图控制器[self setToolbarItems:itemArray animated:YES];// 以下代码UIBarButtonItem不会出现在UIToolBar中，且toolbar是制度属性[self.navigationController.toolbar setItem:itemsArray animated:YES]; 1234567891011UIToolbar *toolBar = [[UIToolbar alloc] initWithFrame:CGRectMake(0,460-44-44,320,44)];toolBar.barStyle = UIBarStyleDefault;[self.view addSubView:toolBar];[toolBar release];UIBarButtonItem *addItem = [[UIBarButton alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemAdd target:self action:nil];UIBarButtonItem *saveItem = [[UIBarButton alloc]initWithBarButtonSystemItem:UIBarButtonSystemItemSave target:self action:nil];UIBarButtonItem *titleItem = [[UIBarButton alloc]initWithTitle:@&quot;title&quot; style:UIBarButtonItemStylePlain target:self action:nil];UIBarButtonItem *imageItem = [[UIBarButton alloc]initWithImage:[UIImage imageNamed:@&quot;1&quot;] style:UIBarButtonItemStylePlain target:self action:nil];UIBarButtonItem *flexibleItem = [[UIBar]NSArray *items = @[addItem,saveItem,titleItem,imageItem];[toolBar setItems:items animated:Yes];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UIControl","date":"2014-02-20T07:33:50.000Z","path":"2014/02/20/UIControl/","text":"UIControl 作用：具有事件处理的控件的父类 事件响应的3种形式：基于触摸、基于值、基于编辑 常用方法 12-(void)addTarget:(id)taget action:(SEL)action forControlEvent:(UIControlEvents)controlEvents //添加一个事件-(void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents // 移除某一个事件 事件处理 12345678910111213141516171819202122232425262728293031323334// 按下时触发UIControlEventTouchDown// 多击触发UIControlEventTouchDownRepeat// 控件内拖动触发UIControlEventTouchDragInside// 控件外拖动触发UIControlEventTouchDrageOutside// 当触摸从控件外拖动到控件内部时UIControlEventTouchDragEnter// 当触摸从控件内拖动到控件外部时UIControlEventTouchDragExit// 控件之内触摸抬起时UIControlEventTouchupInside// 控件之外触摸抬起时UIControlEventTouchUpOutside// 触摸事件取消UIControlEventTouchCancel// 当控件的值发生改变时UIControlEventTouchValueChanged// 文本控件中开始编辑UIControlEventEditingDidBegin// 文本控件中的文本被改变UIControlEventEditingChanged// 文本孔家中编辑结束UIControlEventEditingDidEnd// 文本孔家中通过按下回车键结束编辑时UIControlEventEditingDidOnExit// 所有触摸事件UIControlEventAlltouchEvents// 所有编辑事件UIControlEventAllEditingEvents// 所有事件UIControlEventAllEvents 导航控制器 基本概念 +UINavigationController用于构建分层应用程序的主要工具，管理着多个内容视图的换入（压入）和换出（弹出）。自身提供了视图切换的动画效果。 它的父类是UIViewController，是所有视图控件器的基类。 导航控制器以栈的形式来实现。 栈的基本概念和性质 栈是一种先进后出（后进先出）的数据结构，导航控制器以栈的形式来管理视图控制器，任何视图控制器都可以放入栈中。 向栈添加一个对象的操作称为入栈（push） 第一个入栈的对象叫做基栈 最后一个入栈的对象叫栈顶 栈删除一个对象的操作叫做出栈（pop） 当前现实点视图控制器，即为栈顶。选择”返回”时，这个视图控制器就出栈了。 基本样式 蓝色部分：导航控制器的导航栏（NavigationBar） 橙色部分：控制器包含的内容视图 绿色部分：导航控制器的工具栏（UIToolBar，默认是隐藏的） 元素尺寸 代码示例 1234567891011121314// 控制器的初始化，为控制器添加导航控制器RootViewController *rootVC = [[RootViewController alloc] init];UINavigationController *navigation = [[UINavigationController alloc] initWithRootViewController:rootVC];// 子控制器设置title，显示在导航栏上的标题self.title = @&quot;根控制器&quot;；// 控制器之间的导航SecondViewController *secondVC = [[SecondViewController alloc] init];[self.navigationController pushViewController:secondVC animated:YES];[secondVC release];// 隐藏（显示）导航栏、工具栏目[self.navigationController setNavigationBarHidden:NO animated:YES];[self.navigationController setToolbarHidden:NO animated:YES];// 延时调用hidden方法[self performSelector:@selector(hidden) withObject:nil afterDelay:0.3]; Demo代码片段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// AppDelegate.m// didFinshLunchingWithOptions()// ...RootViewcController * rootViewController = [[RootViewcController alloc] init];UINavigationController *navigation = [[UINavigationController alloc]initWithRootViewController:rootViewController];self.window.rootViewController = navigation;[rootViewController release];[navigation release];//RootController.m -(void)loagView&#123; UIView *baseView = [[UIView alloc] initWithFrame:[UIScreen mainScreen] applicationFrame]; baseView.backgroundColor = [UIColor purpleColor]; self.view = baseView; [baseView release]; UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [button setTitle:@&quot;Push&quot; forState:UIControlStateNormal]; [button setFrame:CGRectMake(90,100,140,35)]; [button addTaget:self action:@selector(pushVC) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:button];&#125;-(void)pushVC&#123; SencondViewController *secondVC = [[SencondViewController alloc] init]; [self navigationController pushViewController:secondVC animated:YES]; [secondVC release];&#125;//SencondViewController.m-(void)loagView&#123; UIView *baseView = [[UIView alloc] initWithFrame:[UIScreen mainScreen] applicationFrame]; baseView.backgroundColor = [UIColor orangeColor]; self.view = baseView; [baseView release]; UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [button setTitle:@&quot;HiidenOrShow&quot; forState:UIControlStateNormal]; [button setFrame:CGRectMake(90,150,140,35)]; [button addTaget:self action:@selector(hiddenOrShow) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:button]; UIButton *back = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [back setTitle:@&quot;backRootVC&quot; forState:UIControlStateNormal]; [back setFrame:CGRectMake(90,200,140,35)]; [back addTaget:self action:@selector(hiddenOrShow) forControlEvents:UIControlEventTouchUpInside]; [self addSubview:back];&#125;-(void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self.navigationController setToolBarHidden:YES animated:YES];&#125;-(void)hiddenOrShow&#123; if(self.navigationController.toolbarHidden) &#123; [self.navigationController setToolBarHidden:NO animated:YES]; [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125;else&#123; [self.navigationController setToolBarHidden:YES animated:YES]; [self.navigationController setNavigationBarHidden:NO animated:YES]; &#125;&#125;-(void)backRootVC&#123; [self.navigationController popViewControllerAnimated:YES];&#125; 导航控制器常用属性 12345678910// 获取到在栈中最顶层的视图控制器@property(nonatomic,readonly,retain)UIViewController *topViewController;// 获取到在斩重当前显示的视图控制器@property(nonatomic,readonly,retain)UIViewController *visibleViewController;// 在栈中当前视图控制器@property(nonatomic,copy)NSAraay *viewControllers;// 隐藏导航栏，默认不隐藏@property(nonatomic,getter=isNavigationBarHidden)BOOL navigationBarHidden;// 获取到导航栏@property(nonatomic,readonly)UINavigationBar *navigatuonBar; 导航控制器常用方法 12345678910// 初始化一个根视图控制器，在栈的最底层-(id)initWithRootViewController:(UIViewController *)rootViewController;// 压入一个新的视图控制器-(void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated;// 弹出一个新的视图控制器-(UIViewController *)popViewControllerAnimated:(BOOL)animated;// 弹出到指定的视图控制器-(NSArray *)popToViewController:(UIViewController *)viewController animated:(BOOL)animated;// 回到跟视图控制器-(NSArray *)popToRootViewControllerAnimated:(BOOL)animated;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"常用UIView组件","date":"2014-02-18T04:46:08.000Z","path":"2014/02/18/常用UIView组件/","text":"UIButton 常用属性 1.Type + Custom:选择此属性外观主要依靠自定义实现。 + System:系统能够默认风格。 + Detail Disclosure:详情标示。 + Info Light:显示“i”图标的图形按钮。 + IndoDark:显示“i”图标的图形按钮。 + Add Contact:显示黑色“+”图标图形按钮。 State Config 按钮的状态 默认状态（Default） 高亮状态（Highlighted） 选中状态（Selected） 禁用状态（Disable） Title 可以选择Plain和Attributed文本方式 制定显示的字符信息 Font 文本字体、大小、字体风格 Text Color 文本的颜色 Shadow Color 阴影颜色 Image 设置为图片按钮，Title属性将不会起作用。 Background 设置背景图片 Shadow Offset 文本和阴影的偏移量 Link Break 省略方式 Edge Content:内容作为边界 Title:文本作为边界 Image:图片作为边界 Inset 边界距离 UIAlert And UIActionSheet12UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;title&quot; message:@&quot;message&quot; delegate:nil cencelButtonTitle:@&quot;cancel&quot; otherButtonTitles:@&quot;other&quot;,nil];[alertView show]; 1234UIActionSheet *actionSheet = [[UIActionSheet alloc] initWIthTitle:@&quot;title&quot; delegate:nil cancelButtonTitle:@&quot;cancel&quot;destructiveButtonTitle:@&quot;destrutive&quot;otherButtonTitles:@&quot;other1&quot;,nil];[actionSheet show]; UIButton UIButton 作用：响应用户的点击事件的View 常用方法 12345678910// 设置指定状态对应的标题文本-(void)setTitle:(NSString *)title forState:(UIControlState)state;// 设置指定状态对应的标题颜色-(void)setTitleColor:(UIColor *)color forState:(UIControlState)state;// 设置指定状态对应的显示图片-(void)setImage:(UIImage *)image forState:(UIControlState)state;// 设置指定状态对应的背景图片-(void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state;// 为按钮添加事件-(void)addtarget:(id *)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents; UIButton状态 123456UICtrolStateNormal // 正常状态UICtrolStateHighlighted // 高亮状态UICtrolStateDisabled // 禁用状态UICtrolStateSelected // 选中状态UICtrolStateApplicationUICtrolStateReserved 事件处理 123456789101112131415161718// 用户按下时触发UIControlEventTouchDown// 点击计数大于1的触发UIControlEventTouchDownRepeat// 当触摸在控件内部拖动时触发UIControlEventTouchDragInside// 当触摸在控件之外拖动时触发UIControlEventTouchDragDutside// 当触摸从控件之外拖到内部时UIControlEventTouchDragEnter// 当触摸从控件内部拖到外部时UIControlEventTouchDragExit// 控件之内触摸抬起时UIControlEventTouchUpInside// 控件之外触摸抬起时UIControlEventTouchUpOutside// 触摸取消时间，设备被上锁或者电话呼叫打断UIControlEventTouchCanel 代码示例 1234567UIButton *button = [UIButton buttonWithType:UIButttonTypeRoundedRect];[button setTitle:@&quot;Normal&quot; forState:UIControlNormal];[button setTitle:@&quot;Highlighted&quot; forState:UIControlHighlighted];[button setTitle:@&quot;Disabled&quot; forState:UIControlDisabled];[button setTitle:@&quot;Selected&quot; forState:UIControlSelected];button.frame = CGRectMake(90,100,140,40);[self.window.addSubview:button]; 图片视图 UIImageView 作用：专用于显示图片的视图 常用属性和方法 12345678910// 初始化图片-(id)initWithImage:(UIImage *)image;// 初始化高亮的图片-(id)initWithImage:(UIImage *)image hightlightedImage:(UIImage *)highlightedImage// 点语法设置图片@property(nonatomic,retain)UIImage *image;// 点语法设置高亮图片@property(nonatomic,retain)UIImage *highlightedImage;// 是否打开用户交互，默认为NO@preperty(nonatomic,getter=isUserInteractionEnabled)BOOL userInteractionEnabled; 示例代码 1234UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0,0,100,100)];imageView.image = [UIImage imageNamed:@&quot;t.png&quot;];imageView.highlightImage = [UIImage imageNamed:@&quot;t1.png&quot;];imageView.userInteractionEnabled = YES; UIActivityIndicatorView UIActivityIndicatorView 作用：提示用户当前页面正在加载数据 常用属性和方法 123456789101112// 设置风格@property(nonatomic)UIActivityIndicatorViewStylr;// 停止时、隐藏视图，默认为YES@property(nonatomic)BOOL hideWhenStopped;// 修改颜色、注意版本问题@property(readWrite,nonatomic,retain)UIColor *color;// 开始动画-(void)startAnimating;// 停止动画-(void)stopAnimating;// 判断动画的状态（停止或开始）-(BOOL)isAnimating; 示例代码 123UIActivityIndicatorView *activityView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorViewStyleWhite];activityView.frame = CGRectMake(0,0,100,100);[activityView startAnimating]; 滑动控件 UISlider视图 作用：控制系统声音，或者表示播放进度等等 常用属性 123456789101112// 设置获取slider的value值@property(nonatomic)float value;// 设置slider的最小值@property(nonatomic)float minimumValue;// 设置slider的最大值@property(nonatomic)float maximumValue;// 设置图片@property(nonatomic,retain)UIImage *minimumValueImage;// 设置图片@property(nonatomic,retain)UIImage *maximumValueImage;// 设置slider的value值，是否存在动画-(void)setValue:(float)value animated:(BOOL)animated; 示例代码 12345UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(20,0,150,25)];[slider addTarget:self action:@selector(sliderAction:) forControlEvent:UIControlEventValueChanged];slider.maxmumValue = 100;slider.minmumValue = 0;slider.value = 50; 分段控件 UISegmentedControl 作用：分段控件、页面切换等 示例代码123456NSArray *array = [NSArray arrayWithObjects:@&quot;选择&quot;,@&quot;搜索&quot;,@&quot;工具&quot;,nil];UISegmentedControl *segmentCtrl = [[UISegmentedControl alloc] initWithItems:array];segmentCtrl.frame = CGRectMake(20,0,150,25);segmentCtrl.segmentedControlStyle = UISegmentedControlStyleBar;segmentCtrl.selectedSegmentIndex = 0;[segmentCtrl addTarget:self action:@selector(segmentAction:) forControlEvents:UIControlEventValueChanged]; 分页控件 UIPageControl 作用：通常和UIScrollView连用，提示用户当前显示页数 常用属性和方法 12345678// 共有几个分页“圆圈”@property(nonatomic)NSInteger numberOfPages;// 显示当前的页@property(nonatomic)NSInteger currentPage;// 只存在一页时，是否隐藏，默认为YES@property(nonatomic)BOOL hidesForSinglePage;// 刷新视图-(void)updateCurrentPageDisplay; 示例代码 12345UIPageControl *pageControl = [[UIPageControl alloc]initWithFrame:CGRectMake(0,100,320,40)];pageControl.numberOfPages = 10;pageControl.currentPage = 2;pageControl.backgroundColor = [UIColor grayColor];[pageControl addTarget:self action:@selector(change:) froControlEvents:UIControlEventValueChanged]; UITextField 常用代理方法1234567891011121314151617// 将要开始输入时调用-(BOOL)textFieldShoudBeginEdting:(UITextField *)textField&#123; return YES;&#125;// 将要输入结束时调用-(BOOL)textFieldShouldEndEditing:(UITextField *)textField&#123; return YES;&#125;// 清除文字按钮点击事件-(BOOL)textFieldShouldClear:(UITextField *)textField&#123; return YES;&#125;// 键盘上的return按钮-(BOOL)textFieldShouldReturn:(UITextField *)textField&#123; [textField resignFirstResponder]; return YES;&#125; UILabel UILabel 作用：显示文本 常用属性 1234567891011121314151617181920// 设置文本内容，默认为nil@property(nonatomic,copy)NSString *text;// 设置字体大小@property(nonatomic,retain)UIFont *font;// 设置字体颜色@property(nonatomic,retain)UIColor *textColor;// 设置阴影，默认没有阴影，若果设置需要设置偏移量@property(nonatomic,retain)UIColor *shadowColor;// 设置偏移量@property(nonatomic）CGSize shadowOffset;// 文本内容对齐方式@property(nonatomic)NSTextAlignment textAlignment;// 当文本超出frame时，文本截取的方式@property(nonatomic)NSLineBreakMode lineBreakMode;// 文本选中时，高亮的颜色@property(nanatomic,retain)UIColor *highlightedTextColor;// 是否存在高亮，默认为nil@property(nanatomic,getter=isHighlighted)BOOL highlighted;// 交互是否打开，默认为NO@property(nanatomic,getter=isUserInteractionEnabled)BOOL userInteractionEnabled; 示例代码 123456789UILabel *label = [[UILabel alloc]initWithFrame:CGRectMake(90,100,140,40)];label.text = @&quot;text&quot;;label.backgroundColor = [UIColor redColor];label.textAligment = NSTextAligmentCenter;label.textColor = [UIColor blueColor];label.shadowColor = [UIColor yellowColor];label.shadowOffset = CGSizeMake(-2,2);[self.window addSubview:label];[label release];","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"利用代理","date":"2014-02-18T04:01:25.000Z","path":"2014/02/18/利用代理/","text":"代理是一种简单而功能强大的设计模式，这种模式用于一个对象“代表”另外一个对象和程序中其他的对象进行交互。 主对象（这里指的是delegating object）中维护一个代理（delegate）的引用并且在合适的时候向这个代理发送消息。这个消息通知“代理”主对象即将处理或是已经处理完了某一个事件。这个代理可以通过更新自己或是其它对象的UI界面或是其它状态来响应主对象所发送过来的这个事件的消息。或是在某些情况下能返回一个值来影响其它即将发生的事件该如何来处理。代理的主要价值是它可以让你容易的定制各种对象的行为。注意这里的代理是个名词，它本身是一个对象，这个对象是专门代表被代理对象来和程序中其他对象打交道的。 12345678910111213// RootViewController.h# import &quot;ModalViewContorller.h&quot;@optional//optional 强制必须实现的方法-(void)changeLabelText:(NSString *)text;@end@interface ModalViewController:UIViewController&#123;@private UITextField *textFiled;&#125;@property(nonatomic,assign)id &lt;ModalViewControllerDelegate&gt; delegate;@end 123456789101112131415161718192021222324252627282930313233343536373839// RootViewController.m-(void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor redColor]; UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect]; button.tag = 101; button.frame = CGRectMake(320/2-140/2,200,140,40); [button setTile:@&quot;进入&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector(presentModalVC) forControlEvent:UIControlEventTouchUpInside]; [self.view addSubiew:button]; UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(90,100,140,40)]; label.text = @&quot;hello world&quot;; label.tag = 102; label.textAligment = NSTextAligmentCenter; [self.view addSubView:label];&#125;-(void)presentModalVC&#123; ModalViewController *modalVc = [[ModalViewController alloc] init]; modalVc.delegate = self; // 动画效果 modalVc.modalTranstionSyle = UIModalTransitionStylePatialCurl; if([[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0)&#123; [self.presentModalViewController:modalVc animated:YES]; &#125;else&#123; [self.presentModalViewController:modalVc animated:YES completion:^&#123; NSLog(@&quot;call back&quot;); &#125;]; [modalVC relese]; &#125;&#125;-(void)changeLabelText:(NSString *)text&#123; UILabel *label = (UILable *)[self.view viewWithTag:102]; label.text = text; &#125; 12345678910111213// ModalViewController.h@protocol ModalViewControllerDelegate &lt;NSObject&gt;@optional//optional 强制必须实现的方法-(void)changeLabelText:(NSString *)text;@end@interface ModalViewController:UIViewController&#123;@private UITextField *textFiled;&#125;@property(nonatomic,assign)id &lt;ModalViewControllerDelegate&gt; delegate;@end 12345678910111213141516171819202122232425//ModalViewController.m-(void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor greenColor]; *textField = [[UIText alloc] initWithFrame:CGRectMake(70,100,100,30)]; textField.borderStyle = UITextBorderStyleRoundedRect; [self.view addSubview:textField]; UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect]; button.frame = CGRectMake(320/2-140/2,100,140,40); [button setTitle:@&quot;dismiss&quot; forState:UIControlEvent:UIControlEventTouchUpInside]; [self.view addSubview:button];&#125;-(void)dismiss&#123; if([self.delegate respondsToSelector:@selector(changeLabelText:)])&#123; [self.delegate changeLabelText:textField.text]; &#125; // 将模态视图关闭 [self dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;dismiss&quot;)]; &#125;];&#125; 利用通知123// 在通知中心注册一条名为ChangeLabelTextNotification的通知[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(changeLabelText:) name:@&quot;ChangeLabelTextNotification&quot; object:nil];// deallco时需要删除 123456-(void)changeLabelText:(NSNotification *)notification&#123; id text = notification.object; UILabel *label = (UILabel *)[self.view viewWithTag:102]; label.text = text;&#125; 1[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;ChangeLabelTextNotification&quot; object:_textField.text]","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UIView","date":"2014-02-17T06:00:00.000Z","path":"2014/02/17/UIView/","text":"视图，表示屏幕上的一块矩形区域，同时处理该区域的绘制和触屏事件。 一个视图也可以作为其他视图的父视图，同时决定着这些子视图的位置和大小. UIView类做了大量的工作去管理这些内部视图的关系。 视图同时也是App中MVC的View部分 iPhone的视图以左上角为原点 每个View的frame所使用的坐标系以它的父视图的左上角为坐关函数 视图结构和相123CGPoint Point = CGPointMake(x,y);//设置CGSize size = CGSizeMake(width,height);//大小CGRect rect = CGRectMake(x,y,width,height);//位置和大小 Frame和Bounds Frame以其父视图为起点，得出它自己的位置信息 Bounds以iOS系统的坐标原点为起点，坐标是(0,0) Center表示视图中心所在的位置，设置此属性可改变视图的位置 默认情况下，视图边框并不会被父视图的边框裁剪。如果需要裁剪，将其clipsToBounds属性设置为YES. 创建UIView 创建UI有两种方式，xib文件和代码创建 12345//通过xib方式来创建视图对象NSBundle *bundle = [NSBundle mainBundle];NSArray *arr = [bundle loadNibNamed:@&quot;myView&quot; owner:selfoptions:nil];UIView *myView = [arr objectAtIndex:0]; 123//代码创建视图对象CGRect viewRect = CGRectMake(0,0,100,100);UIView *myView =[[UIView alloc] initWithFrame:viewRect]; 视图的层次结构 UIView层次结构可以理解为“视图树”————view hierarychy 一个视图就是一个容器，当一个视图包含其他的视图的时候，两个视图之间就建立了一个父子关系，被包含的视图被称为“姿势图（subView）”，包含的视图称为“父视图（superView）” 从视觉上看，子视图会覆盖父视图的内容，设置透明属性可以看到父视图的内容。 每个父视图都有一个有序的数组存储着它的子视图，存储的顺序就会影响到每个子视图的显示效果，后加的视图会覆盖之前的视图。 一个视图可以嵌入多个subView，但是只能有一个superView。 视图的常用方法12345678addSubView: // 添加子视图insertSubview:atIndex: // 视图插入到指定索引位置insertSubview:ahoveSubview: // 视图插入指定视图之上insertSubview:belowSubview: // 视图插入指定视图之下bringSubviewToFront: // 把视图移动到最顶层sendSubviewToBack: // 把视图移动到最底层exchangeSubViewAtIndex:withSubviewAtIndex://把两个索引对应的视图调换位置removeFromSuperview: // 把视图从父视图中移除 查找视图 UIView类中有一个tag属性，通过这个属性可以标志一个视图对象（整数） 获取的方法，viewWithTag:方法来检索标志过的子视图 1234UIView *myView = [[UIView alloc] initWithFrame:CGRectmake(0,0,100,100)];myView.tag = 100;// 通过tag查找viewUIView *myView = [self.view vieWithTag:100]; UIView的常用属性 alpha // 透明度 backgroundColor // 背景颜色 subViews // 子视图集合 hidden // 是否隐藏 tag // 标签值 superview // 父视图 mulitpleTouchEnaled // 是否开启多点触摸 userInteractionEnabled // 是否响应触摸事件 坐标系统变换 坐标变换通过transform属性来改变 CGAffineTransformScale 对视图比例缩放 CGAffineTransformRotae 对视图做变焦旋转 CGAffineTransformTranslate 对视图相对原位置做平移123456789101112131415161718192021 CGAffineTransform transform = rootView.transform; rootView.transform = CGAffineTransformScale(transform,0.5,0.5); rootView.transform = CGAffineTransformRotae(transform,0.33); CGAffineTransformScale(transform,0.5,0.5); rootView.transform = CGAffineTransformTranslate(transform,100,100); ## 视图的内容模式- 视图的contentMode属性决定了边界变化和缩放操作```Objective-c UIImageView *imgeView1 = [[UIImageView alloc] initWithFrame:CFRectMake(320/2-200/2,30,200,200)]; imgeView1.imge = [UIImage imageNamed:@&quot;01&quot;]; imgeView1.backgroundColor = [UIColor redColor]; imgeView1.contentMode = UIViewContentModeScaleAspectFit; [self.window addSubview:imgeView1]; [imView1 release]; UIImageView *imgeView2 = [[UIImageView alloc] initWithFrame:CFRectMake(320/2-200/2,240,200,200)]; imgeView2.backgroundColor = [UIColor yelloColor]; imgeView2.contentMode = UIViewContentModeBottom; [self.window addSubview:imgeView2]; [imView2 release]; UIView属性的动画 UIView类的很多属性都被设计为动画，动画的属性是指当属性从一个值变为另一个值的时候，可以半自动地支持动画，你仍然必须告诉UIKit希望执行什么类型的动画，但是动画一旦开始，Core Animation就会全权负责。UIView对象中支持动画的属性有如下几个： frame - 动画的改变视图的尺寸和位置 bounds - 动画的改变视图的尺寸 center - 动画的改变视图的位置 transform - 动画的翻转或者缩放视x图 alpha - 动画的改变视图的透明度 backgroundColor - 改变视图的背景色 contentStetch - 改变视图内容如何拉伸配置动画委托 可以为动画分配一个委托，并通过该委托接受动画开始和结束的消息。当需要在动画开始前和动画结束后极力执行其他任务时，可能就需要设置委托。 通过UIView调用setAnmationDelegate:方法来设置委托，并通过setAnimationWillStartSelector:和setAnimationDidStopSelector:方法来指定接受消息的选择器方法。消息处理方法形式如下:(void)animationWillStart:(NSString *)animationID context:(void *)context;(void)animationDidStop:(NSString *)animationID finished context:(void *)context;上面的两个方法的animationID和context参数和动画块开始时传给beginAnimations:context:方法的参数相同 animationID - 应用程序提供的字符串，用于标识一个动画块中的动画 context - 应用程序提供的对象，用于向委托对象传递额外的信息 setAnimationDidStopSelector:选择器方法还有一个参数——即一个布尔值。如果动画顺利完成，没有被其他动画取消或停止，则该值为YES。 配置动画的参数 用setAnimationStartDateS方法来设置动画在commitAnimations:方法返回之后的发生日期。 用setAnimationDelay:方法来设置实际发生动画和commitAnimations:方法返回的时间点之间的间隔 用setAnimationDuration:方法来设置动画的持续秒数 用setAnimationCurve:方法来设置动画过程的相对速度，比如动画可能在启动阶段逐渐加速、而在结束阶段逐渐减少，或者这个过程都保持相同的速度 用setAnimationRepeatCount:方法来设置动画的重复次数 用setAnimationRepeatAutoreverses:方法来指定动画在到达目标值时是否自动反向播放。可是结合使用这个方法和setAnimationRepeatCount:方法，使各个属性在初始值和目标值之间平滑切换一段时间。 缺省情况下，所有支持动画的属性在动画块中发生的变化都会形成动画。如果希望让动画块中发生的某些变化不产生动画效果，可以通过setAnimationsEnableed:方法来暂时禁止动画，在完成修改后才重新激活动画，在调用setAnimationsEnabled:方法并传入NO值之后，所有的改变都不会产生动画效果，指定用YES值再次调用这个方法或者提交这个动画块是，动画才会恢复，可以用areAnimationsEnable:方法来确定当前是否激活动画。12345678910111213141516-(void)animationAlpha&#123; [UIView beginAnimations:nil context:NULL];// 需要设置代理时 [UIView setAnimationDuration:1];// 动画的持续时间 [UIview setAnimationDelay:1];// 动画延迟时间 view2.apleha = 0.0; [UIView commitAnimations];// 标记着动画块的结束&#125;-(void)animationFrame&#123; [UIView beginAnimations:nil context:NULL]; [UIView setAnimationDuration:5]; [UIView setAnimationCurve:UIViewAnimationCurveEaseOut];// 动画相对速度，开始和结束的时候慢，中间快 view.center = CGPointMake(0,0); [UIView commitAnimations];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"视图控制器与通知","date":"2014-02-17T04:00:50.000Z","path":"2014/02/17/视图控制器与通知/","text":"UIViewController 视图控制器是数据和视图之间的桥梁，视图供职器提供了一个基本的框架来构建应用程序。 UIViewController是所有视图控制器的父类 iOS提供了许多内置的视图控制器，以支持标准的用户界面部分，比如导航控制器UINavigationController，标签栏控制器UITabBarController,表视图控制器UITableViewController等 视图控制器与视图的关系 视图控制器是传统Modle-View-Controller(MVC)设计模式中————控制器对象 视图控制器提供了许多控制器的基本功能 对于某些功能，基类提供了解决方案的一部分，其他的自定义的功能由视图控制器的子类去实现，比如：用户选择设备，可以由子类去控制是否旋转 视图控制器负责创建和管理一组视图，它本身提供一个视图，称为该试图控制器的根视图，协调管理数据的视图之间的交互 UIScreen对象时链接物理屏幕的标示 UIWindow为UIScreen对象提供画布 一组UIView对象就可以显示内容 每个视图控制器管理和控制一系列的视图 永远不要把UIView添加到UIWindow上，二是添加一个UIViewController 视图控制器(UIViewController)的创建1234567// 代码创建UIViewController *mainViewController = [[UIViewCtroller alloc] init];mainViewController.view.backgroundColor = [UIColor redColor];self.window.rootViewController = mainViewCtroller;// nib创建RootViewController *rootViewController = [[RootViewController alloc] initWithNibName:@&quot;view&quot; bundle:nil];self.window.rootViewController = rootViewController; UIViewController生命周期1234567-(void)loadView&#123; // 调用父类来创建view // 从nib、storybord加载View，否则创建一个empty view // 创建一个自定义的视图，覆盖即可&#125;-(void)view 加载过程 首先去访问view属性 如果存在view，判断之间加载。否则，则UIViewCtroller调用loadView方法 loadView方法执行如下操作 如果覆盖了该方法，则必须创建View给UIViewCtroller的View属性 如果没有覆盖该方法，UIViewControlller会调用父类的方法各个方法执行顺序 (id)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil (void)loadView (void)viewDidLoad (void)viewWillAppear:(BOOL)animated (void)viewDidAppear:(BOOL)animated (void)viewWillDisappear:(BOOL)animated (void)viewDidDisappear:(BOOL)animated 视图卸载 iOS6之前使用viewDidUnload:方法来释放对象的引用 iOS6之后使用didRecevelMemoryWarning内存紧张的时候调用 viewWillDisappear 视图将被从屏幕上移除之前执行 viewDidDisappear 视图已经被从屏幕上移除，用户看不到这个视图 dealloc 视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放 试图控制器的响应链 事件传递流程 当前触发的事件-&gt;视图控制器的跟视图-&gt;视图控制器-&gt;窗口-&gt;UIApplication对象-&gt;不处理 模态视图 模态视图不是特定的某个类，而是通过视图控制器的pressntModalViewController:方法弹出的视图称为模态视图 模态视图出现的场景一般是临时弹出的窗口，譬如：登入窗口 模态视图弹出时通过modalTransitionStyle属性设置不同的动画效果 调用dismissModalViewControllerAnimated:方法关闭窗口 123456789101112131415161718192021222324-(void)viewDidLoad&#123; [super viewDidLoad]; self.view.backgroundColor = [UIColor purpleColor]; UIButton *button = [UIButton buttonWithType:UIButtonTypeRoundeRect]; button.frame = CGRectMake(320/2 - 140/2,80,140,40); [button setTitle:@&quot;Present&quot; forState:UIControlStateNormal]; [button addTarget:self action:@selector[presentModalVc] forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:button];&#125;-(void)presentModalVC&#123; ModalViewController *modalVc = [[ModalViewController alloc] init]; // 动画效果 modalVc.modalTranstionSyle = UIModalTransitionStylePatialCurl; if([[UIDevice currentDevice].systemVersion floatValue] &lt; 6.0)&#123; [self.presentModalViewController:modalVc animated:YES]; &#125;else&#123; [self.presentModalViewController:modalVc animated:YES completion:^&#123; NSLog(@&quot;call back&quot;); &#125;]; [modalVC relese]; &#125;&#125; 12345678//ModalViewController.m-(void)dismiss&#123; // 将模态视图关闭 [self dismissViewControllerAnimated:YES completion:^&#123; NSLog(@&quot;dismiss&quot;)]; &#125;];&#125; 支持多个方向 iOS设备中的加速计可以确定设备的当前方向。默认情况下，一个应用支持纵向和横向。当设备方向改变时，系统会发送UIDiviceOrientationDidChangeNotfication通知，默认情况下UIKit框架监听这个通知，并自定义更新这个方向。123456789101112131415161718192021222324252627282930313233343536-(void)viewDidLoad&#123; // ... // 采用通知获取屏幕方向切换 [[UINotificationCenter defaultCenter] addObserver:self selector:@selector(deviceOrientation:)name:UIDeviceOrientationDidChangeNotifitation object:nil];&#125;-(void)deviceOrientation:(NSNotification *)notification&#123; UIDevice *device = (UIDevice *)[notification object]; NSLog(@&quot;device:%d&quot;,device.orientation);&#125;-(BOOL)shoudlAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123; return NO; //NO为不支持 // return (toInterfaceOrientation != UIterfaceOrientationLandscapeLeft); // 不支持一个方向&#125;# pragma mark - Orientation iOS 3.0_5.0-(BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrienttation)toInterfaceOrientation&#123; return NO;&#125;# pragma mark - Orientation iOS 6.0-(BOOL)shouldAutorotate&#123; return YES;&#125;-(void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration&#123; NSLog(@&quot;duration:%f&quot;,duration); UIView* button = [self.view viewWithTag:101]; if(toInterfaceOrientation == UIInterfaceOrientationPortrait)&#123; button.frame = CGRectMake(320/2-140/2,80,140,40); &#125;else&#123; button.frame = CGRectMake(480/2-140/2,80,140,40); &#125;&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]},{"title":"UIKIT框架","date":"2014-02-17T03:59:00.000Z","path":"2014/02/17/UIKIT框架/","text":"UIView是视图的基类 UIViewController视图控制器的基类 UIResponder表示一个可以接受触摸屏上触摸事件的对象 UIWin（窗口）是视图的一个子类，窗口的主要功能：1、提供一个区域来显示视图，2、将事件（event）分发给视图。123self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen] bounds];self.window.rootViewController = self.viewController;[self.window makeKeyAndVisible]; UIScreen- UIScreen对象可以充当iOS设备物理屏幕的替代者，通过`[[UIScreen mainScreen] bounds]`可以获得设备的屏幕大小 UIWindow- 通过UIApplication获取当前keyWindow，keyWindow是用来管理键盘以及触摸类的消息，并且只能有一个window是keyWindow. - UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow; - 每个UIWindow对象配置windowLevel属性，大部分时候不应该去改变windowL. - UIWindow有3个级别，对应了3种显示优先级。通过windowLevel设置，优先级为：UIWindowLevel &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal 123456789101112//didFinishLauchingWithOptionsself.windonw = [[[UIWindow alloc] initWithFrame:[[UIScreen mainScrren] bounds]];self.window.backgrondColor = [UIColor whiteColor];[self.window makeKeyAndVisible];NSLog(@&quot;self.window level: %@&quot;,self.windonw.level);UIButton *startButton = [UIButton buttonWithType:UIButtonTypeRounedRect];startButton.frame = CCRectMake(320/2-120/2,180,120,35);[startButton setTile:@&quot;警告&quot; action:@selector(alertUser) forControlEvents:UIControlEventTouchUpInside];[self.window addSubview:startButton];return YES; 1234567891011// alerUser-(void)alertUser&#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;提示&quot; message:@&quot;警告框是alert Level级别的&quot; delegate:nil cancelButtonTitle:@&quot;确定&quot; otherButtonTitles:nil]; [alertView show];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"http://seniorzhai.github.io/tags/iOS/"}]}]